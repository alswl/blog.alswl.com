<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>coding on Log4D</title>
    <link>https://blog.alswl.com/categories/coding/</link>
    <description>Recent content in coding on Log4D</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 29 Jul 2023 14:54:27 +0800</lastBuildDate><atom:link href="https://blog.alswl.com/categories/coding/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>架构设计 the Easy Way</title>
      <link>https://blog.alswl.com/2023/07/architecture-design-the-easy-way/</link>
      <pubDate>Sat, 29 Jul 2023 14:54:27 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2023/07/architecture-design-the-easy-way/</guid>
      <description>image via Pixabay 概览 前几日，我在团队内部举行了一场技术分享，我介绍了关于架构设计的最佳实践。将这些实践凝练成了 20 字口诀： 架构看问题 需求看用例 设计看模型 细节看时序 我将顺口溜转到了 Twitter，不少朋友对这些顺口溜产生了浓厚兴趣，希望深入了解。因此，我将我分享中的观点扩展成了这篇文章。 架构设计和系统分析 让我们首先澄清 什么是架构设计和系统分析（简称系分）。有些朋友对前者很熟悉，对后者却不太了解。 不过没关系，以下</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/arch-easy.png" alt="arch-easy"  />


</p>
<p><small>image via <a href="https://pixabay.com/photos/child-tower-building-blocks-blocks-1864718/">Pixabay</a></small></p>
<h2 id="概览">概览</h2>
<p>前几日，我在团队内部举行了一场技术分享，我介绍了关于架构设计的最佳实践。将这些实践凝练成了 <mark>20 字口诀</mark>：</p>
<ol>
<li>架构看问题</li>
<li>需求看用例</li>
<li>设计看模型</li>
<li>细节看时序</li>
</ol>
<p>我将顺口溜转到了 <a href="https://twitter.com/alswl/status/1683778487726006272">Twitter</a>，不少朋友对这些顺口溜产生了浓厚兴趣，希望深入了解。因此，我将我分享中的观点扩展成了这篇文章。</p>
<h2 id="架构设计和系统分析">架构设计和系统分析</h2>
<p>让我们首先澄清 <mark>什么是架构设计和系统分析</mark>（简称系分）。有些朋友对前者很熟悉，对后者却不太了解。
不过没关系，以下是维基百科上的介绍：</p>
<blockquote>
<p>架构，<strong>软件架构</strong>是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。</p>
<p>系统分析，旨在研究特定系统结构中各部分（各子系统）的相互作用，系统的对外接口与界面，以及该系统整体的行为、
功能和局限，从而为系统未来的变迁与有关决策提供参考和依据。</p>
</blockquote>
<p>来看一下英文定义可能会更清晰：</p>
<ul>
<li>架构 = 软件架构（设计） = Software Architecture <a href="https://en.wikipedia.org/wiki/Software_architecture">Software architecture - Wikipedia</a></li>
<li>系分 = 系统分析 = System Analysis
<a href="https://en.wikipedia.org/wiki/Systems_analysis">Systems analysis - Wikipedia</a> + <a href="https://en.wikipedia.org/wiki/Systems_design">Systems design - Wikipedia</a></li>
</ul>
<p>我们有时候提到的设计文档，可能涵盖整个设计过程，包括架构设计、系统分析以及其他设计活动（交流、PoC）。</p>
<p>软件架构（设计）= Software Architecture</p>
<ul>
<li>设计和实现软件系统的基本结构和组织形式</li>
<li>在业务层面：明确问题，厘定概念，呈现价值</li>
<li>在技术层面：确定基础框架，将不确定性转化为确定性</li>
<li>工程层面：识别边界和拆分各个模块，提高应用开发效率</li>
</ul>
<p>系统分析 = System Analysis</p>
<ul>
<li>对业务需求和问题进行分析和研究的过程</li>
<li>在业务层面：需求收集、需求分析</li>
<li>在技术层面：建模，绘制流程图、数据流图和接口设计</li>
<li>工程层面：在应用、系统框架内实现需求</li>
</ul>
<p>最后，我来解释一下我对这两者边界的理解。实际上，我认为<mark>架构设计和系统分析并没有明显的界限</mark>。
一个系统或模块不管如何都会进行系统分析，而当出现以下几个特征时，就开始考虑架构设计问题：</p>
<ul>
<li>当有超过 3 个团队在协作时，因为这时涉及到利益和边界的问题。</li>
<li>当开始主动或被动引入不确定性。</li>
<li>当开始平衡取舍，需要先做到什么程度，再做到什么程度。</li>
<li>当不系统过于复杂，太容易达成一致，开始有解释成本时。</li>
<li>当能够提供别人不了解的信息。</li>
</ul>
<h2 id="什么是架构">什么是架构</h2>
<p>在这里，我们讨论的是技术架构，不会涉及业务架构或产品架构等方面。
技术方面的讨论重点是<mark>如何更高效地利用技术能力和方法来解决特定类型的问题</mark>。</p>
<p>进一步地，技术架构可以分为两种：一种是<mark>从顶层向下</mark>看，包括业务、战略和框架划分；
另一种是<mark>关注工程实现（编码）</mark>层面需要解决的架构问题。</p>
<p>那些经验丰富的人常常有较宏观的视角，使用的常见名词有：全局、宏观、领域、战略、平衡、规划。我将这些词汇整理成了一个词云如下：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/word-cloud-arch-biz.png" alt="word-cloud-arch-biz"  />


</p>
<p><small>generted by <a href="https://tendcode.com/tool/word-cloud/">https://tendcode.com/tool/word-cloud/</a></small></p>
<p>以上这些概念在架构设计和系统分析中都非常重要，因为它们帮助我们在整体上考虑问题，甚至超越技术层面，
从业务价值、商业策略和业务战略的角度思考问题。</p>
<p>另一种架构偏重于工程设计和实现。常见的关键词有：领域建模、UML、GoF23，SOLID，高内聚低耦合等等。对应的词云如下：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/word-cloud-arch-impl.png" alt="word-cloud-arch-impl"  />


</p>
<p><small>generted by <a href="https://tendcode.com/tool/word-cloud/">https://tendcode.com/tool/word-cloud/</a></small></p>
<p>架构的话题非常广泛，本文选择从一个切入点出发：<mark>通过实践和方法论，使架构意识在日常工作中发挥作用，以满足 80%的工程设计开发场景</mark>。
我称之为「架构设计 the easy way」。</p>
<h2 id="极简架构设计---架构看问题">极简架构设计 - 架构看问题</h2>
<p>理解架构的第一步，也是最重要的一步，就是关注「问题」。也就是说，<mark>你遇到了什么问题，你将如何去解决它</mark>？</p>
<p>通常情况下，如果我们的业务和系统都稳定运行，没有遇到任何问题，我们就不太需要进行架构设计。但是，只要涉及到架构设计，
必定是因为我们遇到了问题。这些问题可能源自新的需求，也可能是外部环境的变化，
亦或是系统自身随着时间的发展而出现的。无论问题的来源如何，我们都遇到了问题。</p>
<p>遇到问题之后，我们该如何解决？就像将大象装进冰箱一样，需要分成几个步骤。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/elephant.png" alt="把大象装进冰箱"  />


</p>
<p><small>image via unkown</small></p>
<p>因此，解决问题也有三个步骤：第一步是将问题描述清楚，第二步是进行协商和决策达成一致，第三步则是着手解决问题。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/q-n-a.png" alt="问题-一致-行动"  />


</p>
<p>我还想问一个听上去很愚蠢的问题：为什么不能直接解决问题？</p>
<p>因为问题是复杂的，有许多解决路径，不同的解决方案各有优劣和成本。在架构设计中，我们需要完成这些决策。</p>
<p>那为什么不直接进行决策，甚至直接开始动手？</p>
<p>首先可能涉及到职权问题，架构师未必有最终决策权，需要有决策权的人来做最后的决定。
第二个原因是架构师未必是方方面面的专家，设计一个复杂系统时候需要协调多个部分和领域专家来一起评估决策。</p>
<h3 id="案例">案例</h3>
<p>我举 Prometheus 的架构设计来作为例子。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/prometheus-architecture.png" alt="Prometheus architecture"  />


</p>
<p><small>image via <a href="https://prometheus.io/docs/introduction/overview/">Prometheus</a></small></p>
<p>这个架构图回答了很多问题，我举几个例子：</p>
<ul>
<li>问题：数据采集使用 Push 还是 Pull？使用什么存储？如何设计告警链路？</li>
<li>决策：采用 Pull（少量情况下使用 Pushgateway）；使用自己实现的 TSDB；使用 Alertmanager 与外部系统对接</li>
<li>ROI：采用 Pull 降低 Target 观测成本，不需要使用 Push-based 的 Registry；
没有现成的外部实现（当时）；提供 Router / Sub 的告警机制以便灵活接入外部系统</li>
</ul>
<h3 id="小结">小结</h3>
<p>问题驱动架构变化，架构方案应对问题，架构评审统一解决方案。</p>
<p>关于决策拍板问题。我强烈推崇架构师根据自己具备的领域知识、对行业的判断以及对现状的了解，
做出自己的思考和独立判断。这些思考过程应该有因果关系的支持，<mark>一个优秀的架构师必定拥有自己的观点</mark>。</p>
<p>最后，我补充一个小问题：为什么这里没有提到架构分层、模块分层？</p>
<p>不是因为分层和框架不重要，而是在因为大家都很专业。分层和模块化已经是基本常识和技能，因此反而往往不会成为争论和决策的焦点。
如果分层和框架无法快速形成一致，有可能团队构成上存在问题，也可能问题过于复杂已经不是 80% case。</p>
<p>在本阶段，产出的成果包括架构图以及对问题、价值、成本、风险和分工达成一致的认识。</p>
<h2 id="极简架构设计---需求看用例">极简架构设计 - 需求看用例</h2>
<p>需求是对问题的解答。我个人喜欢用<mark>思维导图或白纸来画图</mark>，将需求讲清楚。
画什么内容呢？理清角色，并列出各种动作和行为。</p>
<p>那有什么技巧可以将事项都整理出来呢？我经常使用<mark>主谓宾状从</mark>的方法。
也就是说，明确哪些人，在什么场景（可选），以什么状态（可选）做着什么事情。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/gramma.jpg" alt="主谓宾"  />


</p>
<p><small>image via unkown</small></p>
<p>通过用例将需求清晰地拆解，并在这个过程中不断与需求提供方进行交流和沟通。</p>
<p><mark>Demo 稿是产品经理的武器，而需求用例则是工程师的武器。</mark></p>
<p>有些初入职场的研发人员会不自然地变成需求的执行者。我比较果断地判断，不了解业务的工程师和外包没什么区别。而需求分析环节是最重要的，
是对业务输入进行理解、梳理、重新设计的机会。通过用例的整理，我们可以将一些不切实际、不可靠的需求反馈给需求方。</p>
<p>这是少数可以推动（反馈）需求方的阶段，一定要珍惜。</p>
<h3 id="案例-1">案例</h3>
<p>这里有一个产品用例的范例：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/netease-music.png" alt="网易云音乐"  />


</p>
<p><small>image via <a href="https://www.woshipm.com/evaluating/3493594.html">网易云音乐产品分析报告</a></small></p>
<p>实际上，这个用例是敌对势力那边总结的 😄，但仍然能够体现用例的重要性。</p>
<h3 id="小结-1">小结</h3>
<p>除了使用主谓宾的方式来进行设计，还有一些其他技巧：</p>
<ul>
<li>使用动线（行动路线）：想象用户（或行动者）完成他们目标的行动路线</li>
<li>可以优先考虑解决核心路径中的 20%问题</li>
<li>通过分角色、正交拆分等方式将用例整理得更加清晰；将用例分类分到各个模块</li>
</ul>
<p>本阶段的产出物包括：Demo 稿、用例图。</p>
<h2 id="极简架构设计---设计看模型">极简架构设计 - 设计看模型</h2>
<p>在我看来，设计的核心在于模型：<mark>模型确定了数据的载体和边界</mark>。而<mark>数据确定了组成部分，边界则确定了归属和职责</mark>。
在 UML 中，大量的 Entity 和 Object 用于确定模型的边界。
随着业务系统复杂程度的增加，建模也会面临更加复杂的挑战。</p>
<p>我总结了一下我建模的几个要点：</p>
<ul>
<li>明确术语（中英文）、含义、备注。</li>
<li>确定核心模型（重点放在最关键的 20%）。</li>
<li>提炼和抽象模型。</li>
<li>明确模型之间的关联关系。</li>
<li>结合动态和静态：少量模型具有行为，关注其提供的功能（Functions）。</li>
<li>业务模型 &lt;-&gt; 数据模型转换。</li>
</ul>
<p>很多人对中英文术语表不屑一顾，但我却很在意这点。有一个效应叫做「外语陌生感」（Foreign Language Effect），
就像博物学使用拉丁语 / 希腊语来描述物种一样。我们非英语母语的工程师，使用英文描述术语可以快速地聚焦问题。</p>
<p>始终牢记 80/20 原则的存在，特别是在设计阶段，一定要关注核心对象，将其放大而非过度关注细节。
一般来说，关注最核心的 20%模型就可以满足大部分场景。</p>
<p>在模型的提炼和抽象过程中要反复斟酌，并且可以将这个过程联动到前期的用例定义和后期的时序设计，
这需要大量领域知识的支持。我个人喜欢在这个阶段参考外部的代码和设计。</p>
<p>模型之间的关联关系主要是 1:1 / 1:N / M:N 关系，需要使用箭头清楚地标记主从关系。主从关系意味着从属关系，
这会影响后续一系列细节设计（如 URL、数据库、生命周期管理等）。
我个人推荐避免使用 M:N 关系，这种形式通常表明中间会有一个凭证（Credential）或关系（Relationship / Binding）。</p>
<p>除了关注静态的数据，还要关注模型的行为（极少量模型才有）。这个阶段可以进一步做一些识别，方便下一步的细节设计。</p>
<p>完成业务模型设计之后，同时要考虑数据模型。对于普通业务系统，这个转换会非常直观简单。业务系统通常是无状态系统，
完全依赖数据库进行存储。如果面临 DIA（Data Intensive Application）系统，就要考虑运行时数据的管理，
以及一系列复杂的生命周期管理和可用性管理（我估计有这个需求的朋友，不会看到这里了）。</p>
<h3 id="案例-2">案例</h3>
<p>我举例一个 Kubernetes 的 RBAC（Role-Based Access Control）系统，这是常见的 AuthZ 授权鉴权系统（注意，不是 AuthN 认证系统）。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/rbac.png" alt="Kubernetes RBAC"  />


</p>
<p><small>image via <a href="https://dev.to/alcide/kubernetes-rbac-moving-from-it-s-complicated-to-in-a-relationship-1bbm">Kubernetes RBAC  - DEV Community</a></small></p>
<p>这里我抛几个问题：</p>
<ul>
<li>为什么需要使用 Role / ClusterRole 两种？它们的结构如何？</li>
<li>为什么不使用 ACL？使用 ACL 和使用 RBAC 有什么差异？</li>
<li>为什么不用 Policy？为什么不使用 Policy？</li>
</ul>
<p>这些答案都需要建模来回答的。</p>
<h3 id="非业务系统的模型">非业务系统的模型</h3>
<p>在我们的讨论中，更多关注的是业务模型，即用户能感知并产品能理解的模型，通常需要存储在数据库中。</p>
<p>但在基础设施领域，也是有模型的，有时候称之为&quot;概念&quot;（Concept）。基础设施领域的模型通常会简单得多，
而业务模型可能会非常复杂，因为世界本身就很复杂，而基础设施则专注于解决非常垂直领域的问题，因此相对简单。</p>
<p>此外，基础设施领域的特殊性会导致有很多抽象的建模，例如最简单到我们常常忽略的（Manager / Service）类别。
一些带有数据和状态的模型，比如 Executor，是常见的概念，而 Registry / Queue 也是常见的概念。</p>
<p>这是 Kubernetes的 <a href="https://kubernetes.io/docs/concepts/">Concepts</a>，十几个子类，上百个概念更显这个系统的复杂性。</p>
<h3 id="小结-2">小结</h3>
<p>模型不仅仅是数据，还涉及边界，边界决定了其归属和职责。</p>
<p>模型的设计需要动静结合来看，静态方面关注其持有的内容，动态方面则关注其提供的功能。</p>
<p>在基础设施领域，模型的产出可能包括 UML Model 图、ER 图、数据库 DML、类文件、OpenAPI Swagger（部分）等。</p>
<h2 id="极简架构设计---细节看时序">极简架构设计 - 细节看时序</h2>
<blockquote>
<p>程序设计 = 数据结构 + 算法 + 流程控制</p>
</blockquote>
<p>在将设计转换为模型之前，最后一个重要的步骤是控制细节。对于需求方和决策者来说，这一步可能并不重要，
但对于实施方（开发团队）来说，这个步骤直接影响交付结果的质量和时间。</p>
<p>我认为细节应该在时序图上进行呈现。</p>
<p>通常我们有两种常用的图形来展示细节：<mark>流程图和时序图</mark>。两者实际上有很多相似之处，
但我个人更喜欢时序图，因为它不仅包含顺序的概念，还清晰地展示了流程和系统之间的交互边界。</p>
<p>我的技巧是，一般每个用例都会对应一个时序图。</p>
<h3 id="案例-3">案例</h3>
<p>这里以 AWS 一个官方博客作为范例：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/aws-seq.png" alt="Header-based API Gateway versioning with CloudFront"  />


</p>
<p><small>via <a href="https://aws.amazon.com/blogs/architecture/sequence-diagrams-enrich-your-understanding-of-distributed-architectures/">AWS Architecture Blog</a></small></p>
<p>在上图中，展示了 AWS 中使用 CloudFront 的一个时序图，从时序图中可以清晰地看到多个系统之间请求的流转以及多种异常状态的处理。</p>
<h3 id="小结-3">小结</h3>
<p>这里我总结一下时序图的小技巧：</p>
<ul>
<li>用户动作是发起</li>
<li>系统边界要清晰</li>
<li>有去有回是同步</li>
<li>有去无回是异步</li>
</ul>
<p>一般来说，时序图画好了，就可以放心地交给项目团队开始实施，不会有大的错误。如果没有时序图，依赖的就完全是彼此之间的合作经验和信任度了。</p>
<p>产出：时序图、API 文档（Open API Swagger）、前端 service 生成（如果有）。</p>
<h2 id="极简架构设计---小结">极简架构设计 - 小结</h2>
<p>在这个阶段，尽管我们还没有开始编写代码，但已经清楚了需要做什么，以及实现的样子。
我们也有了类结构、API 定义、前端服务生成等产出。多个团队可以同时开始协作，没有明显的瓶颈。</p>
<ul>
<li>✅ 问题定义</li>
<li>✅ 解决方法</li>
<li>✅ 类结构、API 定义</li>
<li>✅ 服务端代码生成</li>
<li>✅ 流程确定</li>
<li>✅ 汇报材料 1/3</li>
<li>✅ 技术分享材料 1/2</li>
</ul>
<p>如果未来需要汇报，汇报材料已经有了 1/3 的内容。如果需要撰写技术分享文档，也已经具备了 1/2 的内容。</p>
<p>如果这个项目是一个简单的 CRUD 应用系统，那么基本不会有什么难点。</p>
<p>如果是一个 DIA 系统（Data Intensive Application），则需要开始设计和实施数据存储部分，并考虑数据一致性和并发相关的问题。对于一个复杂的系统，
还需要继续实施多个系统连接处是否存在不确定性。如果在工程上面临同步方面的挑战，例如应用框架改造、通讯系统改造等，
也要提前进行风险排除。（我认为同时进行技术升级和业务开发并不明智）。</p>
<h2 id="番外---画图工具">番外 - 画图工具</h2>
<p>我有一套自己的画图工具套件，涵盖了系统架构图、流程图等绘制。
PS：我甚至还给自己的产品设计 Logo，或许这与我内心渴望成为一名设计师有关吧~</p>
<p>作为一名工程师，必须积累自己的画图 UI Kit，熟练掌握其技巧，构建一套属于自己的工具包，
从而能够将脑海中的构思快速还原到文档中。</p>
<p>我的画图工具组合相当丰富。用于绘制架构图的工具包括：</p>
<ul>
<li>框图
<ul>
<li>OmniGraffle（收费，复杂、美观）</li>
<li>Excalidraw（简单、随性）</li>
</ul>
</li>
<li>部署图
<ul>
<li>Excalidraw</li>
</ul>
</li>
<li>脑图 MindMap
<ul>
<li>SimpleMind（收费）</li>
<li>XMind（收费）</li>
</ul>
</li>
</ul>
<p>用来做工程设计（UML）的工具如下：</p>
<ul>
<li>use case 用例
<ul>
<li>语雀画图</li>
<li>plantuml（语雀支持渲染）</li>
</ul>
</li>
<li>sequence 时序图
<ul>
<li>plantuml</li>
</ul>
</li>
<li>state 状态图
<ul>
<li>语雀</li>
</ul>
</li>
<li>ER 图
<ul>
<li>Excalidraw</li>
</ul>
</li>
<li>Gantt 甘特图
<ul>
<li>plantuml</li>
</ul>
</li>
</ul>
<p>这里我再软广一下我维护的 <a href="https://excalidraw.alswl.com/">Excalidraw（Fork）</a>，支持中文手写字体，保持风格的统一。</p>
<h2 id="番外---the-hard-way">番外 - the Hard Way</h2>
<p>回到本次分享的出发点，给大家一份简单可行的架构设计方案。
但是对于你这样好学的人来说，肯定不会满足于如此简单的流程，
毕竟还有那 20% 的复杂场景无法完全涵盖。
我给你一个关键词列表和一些建议的书单，帮助你进一步加深学习：</p>
<ul>
<li>原则</li>
<li>理念</li>
<li>思想</li>
<li>规律</li>
<li>方法论</li>
<li>案例</li>
</ul>
<p>以下是一些书单，可以帮助你深入学习：</p>
<ul>
<li>业务架构
<ul>
<li><a href="https://book.douban.com/subject/1792387/">UML 和模式应用 - Craig Larman</a></li>
<li><a href="https://book.douban.com/subject/5344973/">领域驱动设计 - Eric Evans</a></li>
</ul>
</li>
<li>技术架构
<ul>
<li><a href="https://book.douban.com/subject/30468597/">重构 - Martin Fowler</a></li>
<li><a href="https://book.douban.com/subject/4199741/">代码整洁之道 - Robert C. Martin</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>实用 Web API 规范</title>
      <link>https://blog.alswl.com/2023/04/web-api-guidelines/</link>
      <pubDate>Mon, 03 Apr 2023 11:34:18 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2023/04/web-api-guidelines/</guid>
      <description>当开始创建一个新系统，或参与一个新团队或项目时，都会面临一个简单却深刻的问题：这个系统（Web Server）的 API 是否有设计规范？ image by stable difussion, prompt by alswl 这个问题困扰了我很长时间，始于我求学时期，每一次都需要与团队成员进行交流和讨论。 从最初的自由风格到后来的 REST，我经常向项目组引用 Github v3 和 Foursqure API（已经无法访问，暴露年龄） 文档。 然而，在实践过程中，仍然会有一些与实际工作或公司通用规范不匹配的情况， 这时候我需</description>
      <content:encoded><![CDATA[<p>当开始创建一个新系统，或参与一个新团队或项目时，都会面临一个简单却深刻的问题：这个系统（Web Server）的 API 是否有设计规范？</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202304/pyramid.png" alt="pyramid"  />


</p>
<p><small>image by stable difussion, prompt by alswl</small></p>
<p>这个问题困扰了我很长时间，始于我求学时期，每一次都需要与团队成员进行交流和讨论。
从最初的自由风格到后来的 REST，我经常向项目组引用 <a href="https://docs.github.com/en/rest?apiVersion=2022-11-28">Github v3</a> 和
Foursqure API（已经无法访问，暴露年龄） 文档。
然而，在实践过程中，仍然会有一些与实际工作或公司通用规范不匹配的情况，
这时候我需要做一些补充工作。最终，我会撰写一个简要的 <code>DEVELOPMENT.md</code> 文档，以描述设计方案。</p>
<p>但我对该文档一直有更多的想法，它还不够完善。因此，我想整理出一份<mark>简单（Simple）而实用（Pragmatic）</mark>的 Web API 最佳实践，也就是本文。</p>
<h2 id="为什么我们需要-api-统一规范">为什么我们需要 API 统一规范</h2>
<p>这个问题似乎很明显，但是深入剖析涉及团队协作效率和工程设计哲学。</p>
<p>API（Application Programming Interface，应用程序编程接口）是不同软件系统之间交互的桥梁。在不同软件系统之间进行通信时，
API 可以通过标准化的方式进行数据传输和处理，从而实现各种应用程序的集成。</p>
<p>当我们开始撰写 API 文档时，就会出现一个范式（Design Pattern），这是显式还是隐式的，
是每个人一套还是公用同一套。这就像我们使用统一的 USB 接口一样，统一降低了成本，避免了可能存在的错误。具体来说，这有以下几个原因：</p>
<ul>
<li>容易理解，提高效率：服务提供方和消费方使用统一形式、结构和使用方式，以及统一的生产消费协议，从而减少沟通成本。</li>
<li>专家经验：它包含最佳的工程实践，常见场景都有对应的解决方案，避免了每个人都要重新思考整个 API 系统。
例如，如何处理 API 缓存？如何进行鉴权？如何进行数据格式处理？</li>
<li>面向未来的扩展，需要稳定的协议：协议是抽象的、独立于实现的，不是每个人都具备
设计面向不确定系统的能力，一些广泛使用的技术则为更广泛的场景做了规划。</li>
</ul>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202304/why.png" alt="why"  />


</p>
<p><small>image by alswl</small></p>
<p>虽然使用统一规范确实有一些成本，需要框架性的了解和推广，但我相信在大部分场景下，
统一规范所带来的收益远远高于这些成本。</p>
<p>然而，并非所有的情况下都需要考虑 API 规范。对于一些短生命周期的项目、影响面非常小的内部项目和产品，
可能并不需要过多关注规范。 此外，在一些特殊的业务场景下，
协议底层可能会发生变化，这时候既有的规范可能不再适用。但即使如此，我仍然建议重新起草新的规范，而不是放弃规范不顾。</p>
<h2 id="规范的原则">规范的原则</h2>
<p>在制定 API 规范时，我们应该遵循一些基本原则，以应对技术上的分歧，我总结了三个获得广泛认可的原则：</p>
<ul>
<li>简洁：简洁是抵抗复杂性的最直接和最有效的策略，利用简洁原则降低复杂度，避免复杂性的滋生和扩散；</li>
<li>一致性：统一的设计模式和延续的设计风格有助于降低工程成本和工程师的心理负担；</li>
<li>遵循现实：遵循现有工程领域的抽象和分层（例如 HTTP，REST，RBAC，OIDC 等），不要自己发明新的概念，
要始终思考这个问题是否只有自己遇到了（答案肯定是否定的）。</li>
</ul>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202304/principle.png" alt="principle"  />


</p>
<p><small>image by alswl</small></p>
<h2 id="rest-到底行不行">REST 到底行不行？</h2>
<p>在 Web API 领域，<a href="https://en.wikipedia.org/wiki/Representational_state_transfer">RESTful API</a> 已经成为广受欢迎的协议。
其广泛适用性和受众范围之广源于其与 HTTP 协议的绑定，这使得 RESTful API 能够轻松地与现有的 Web 技术进行交互。如果您对 REST 不熟悉，
可以查看 <a href="https://www.ruanyifeng.com/blog/2014/05/restful_api.html">阮一峰的 RESTful API 设计指南</a> 以及
<a href="https://www.oschina.net/translate/best-practices-for-a-pragmatic-restful-api?print">RESTful API 设计最佳实践</a>。</p>
<p>REST 是一种成熟度较高的协议，<a href="https://martinfowler.com/articles/richardsonMaturityModel.html#level0">Leonard Richardson</a>
将其描述为四种成熟度级别：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202304/rest-four-level.png" alt="rest-four-level"  />


</p>
<p><small>image by alswl</small></p>
<ol>
<li>The Swamp of POX，使用 HTTP 承载 Legacy 协议（XML）</li>
<li>Resources：使用资源抽象</li>
<li>HTTP Verbs：使用丰富的 HTTP Verbs</li>
<li>Hypermedia Controls：使用 <code>rel</code> 链接进行 API 资源整合，<a href="https://jsonapi.org/">JSON:API</a> 是登峰造极的表现</li>
</ol>
<p>REST 的核心优势在于：</p>
<ul>
<li>它充分利用了 HTTP 协议的设计（HTTP Protocol）</li>
<li>它具有出色的资源定位能力（Identification of resources）</li>
<li>它设计了完备的资源操作方式（Manipulation of resources）</li>
<li>它具备自解释性（Self-descriptive messages）</li>
<li>它支持多种形态的呈现方式（hypermedia as the engine of application state）</li>
</ul>
<p>然而，<mark>REST 并非一种具体的协议或规范，而是一种风格理念</mark>。尽管 REST 定义了一些规则和原则，如资源的标识、统一接口、无状态通信等，
但它并没有规定一种具体的实现方式。因此，在实际开发中，不同的团队可能会有不同的理解和实践，
从而导致 API 的不一致性和可维护性降低。</p>
<p>此外，REST 也有一些局限性和缺陷：</p>
<ul>
<li>并非所有请求都可以用资源描述，比如登录（<code>/login</code>）操作，转换成 <code>session</code> 就非常绕口；
同样的问题在转账这种业务也会出现。HTTP 有限的动词无法支撑所有业务场景。</li>
<li>REST 并未提供针对必然面临的问题，如分页、返回体具体结构、错误处理和鉴权等，明确的解决方案。</li>
<li>对于复杂的查询（如搜索 Search），RESTful API 的查询参数可能会变得非常复杂，难以维护。</li>
</ul>
<p>因此，虽然 REST 风格是一个不错的指导思想，但在具体实现时需要结合具体业务需求和技术特点，有所取舍，才能实现良好的 API 设计。
最后，我们是否需要 Web API 设计规范，遵循 REST 风格呢？我认为 REST 能够解决 90% 的问题，但还有 10% 需要明确规定细节。</p>
<h2 id="web-api-规范的选择题">Web API 规范的选择题</h2>
<p>因为我们的协议基于 HTTP 和 REST 设计，我们将以 HTTP 请求的四个核心部分为基础展
开讨论，这些部分分别是：URL、Header、Request 和 Response。</p>
<h3 id="url-最佳实践">URL 最佳实践</h3>
<p>我的 URL 设计启蒙来自于 <a href="https://guides.rubyonrails.org/routing.html">Ruby on Rails</a>。
在此之前，我总是本能地将模型信息放到 URL 之上，但实际上良好的 URL 设计应该是针对系统信息结构的规划。
因此，URL 设计不仅仅要考虑 API，还要考虑面向用户的 Web URL。</p>
<p>为了达到良好的 URL 设计，我总结了以下几个规则：</p>
<ul>
<li>定位资源（这就回答分页是否应该在 Header）</li>
<li>自解释（可读性强，URL 自身即包含核心信息）</li>
<li>安全（不能包含用户认证信息，OAuth 为了解这个花了很多精力，防伪造）</li>
</ul>
<p>通常情况下，URL 的模型如下所示：</p>
<p><code>/$(prefix)/$(module)/$(model)/$(sub-model)/$(verb)?$(query)#${fragment}</code></p>
<p>其中，Prefix 可能是 API 的版本，也可能是特殊限定，如有些公司会靠此进行接入层分流；
Module 是业务模块，也可以省略；Model 是模型；SubModel 是子模型，可以省略；
Verb 是动词，也可以省略；Query 是请求参数；Fragment 是 HTTP 原语 Fragment。</p>
<p>需要注意的是，并非所有的组成部分都是必须出现的。例如，SubModel 和 Verb 等字段可
以在不同的 URL 风格中被允许隐藏。</p>
<p><strong>设计风格选择</strong></p>
<p>注：<strong>请注意，方案 A / B / C 之间没有关联，每行上下也没有关联</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>解释（见下方单列分析）</th>
<th>方案 A</th>
<th>方案 B</th>
<th>方案 C</th>
</tr>
</thead>
<tbody>
<tr>
<td>API Path 里面 Prefix</td>
<td></td>
<td><code>/apis</code></td>
<td><code>/api</code></td>
<td>二级域名</td>
</tr>
<tr>
<td>Path 里面是否包含 API 版本</td>
<td><strong>版本在 URL 的优势</strong></td>
<td>✅</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>Path 是否包含 Group</td>
<td></td>
<td>✅</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>Path 是否包含动作</td>
<td><strong>HTTP Verb 不够用的情况</strong></td>
<td>✅</td>
<td>🚫 （纯 REST）</td>
<td>看情况（如果 HTTP Verb CRUD 无法满足就包含）</td>
</tr>
<tr>
<td>模型 ID 形式</td>
<td><strong>Readable Stable Identity 解释</strong></td>
<td>自增 ID</td>
<td>GUID</td>
<td><mark>Readable Stable ID</mark></td>
</tr>
<tr>
<td>URL 中模型单数还是复数</td>
<td></td>
<td>单数</td>
<td>复数</td>
<td>列表复数，单向单数</td>
</tr>
<tr>
<td>资源是一级（平铺）还是多级（嵌套）</td>
<td><strong>一级和多级的解释</strong></td>
<td>一级（平铺）</td>
<td>多级（嵌套）</td>
<td></td>
</tr>
<tr>
<td>搜索如何实现，独立接口（<code>/models/search</code>）还是基于列表<code>/models/</code> 接口</td>
<td></td>
<td>独立</td>
<td>合并</td>
<td></td>
</tr>
<tr>
<td>是否有 Alias URL</td>
<td><strong>Alias URL 解释</strong></td>
<td>✅</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>URL 中模型是否允许缩写（或精简）</td>
<td><strong>模型缩写解释</strong></td>
<td>✅</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>URL 中模型多个词语拼接的连字符</td>
<td></td>
<td><code>-</code></td>
<td><code>_</code></td>
<td>Camel</td>
</tr>
<tr>
<td>是否要区分 Web API 以及 Open API（面向非浏览器）</td>
<td></td>
<td>✅</td>
<td>🚫</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>版本在 URL 的优势</strong></p>
<p>我们在设计 URL 时遵循一致性的原则，无论是哪种身份或状态，都会使用相同的 URL 来访问同一个资源。
这也是 Uniform Resource Location 的基本原则。虽然我们可以接受不同的内容格式（例如 JSON / YAML / HTML / PDF / etc），
但是我们希望资源的位置是唯一的。</p>
<p>然而，问题是，对于同一资源在不同版本之间的呈现，是否应该在 URL 中体现呢？这取决于设计者是否认为版本化属于位置信息的范畴。</p>
<p>根据 RFC 的设计，除了 URL 还有 <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Name">URN（Uniform Resource Name）</a>，
后者是用来标识资源的，而 URL 则指向资源地址。实际上，URN 没有得到广泛的使用，以至于 URI 几乎等同于 URL。</p>
<p><strong>HTTP Verb 不够用的情况</strong></p>
<p>在 REST 设计中，我们需要使用 HTTP 的 GET / POST / PUT / DELETE / PATCH / HEAD 等动词对资源进行操作。
比如使用 API <code>GET /apis/books</code> 查看书籍列别，这个自然且合理。
但是，当需要执行类似「借一本书」这样的动作时，
我们没有合适的动词（BORROW）来表示。针对这种情况，有两种可行的选择：</p>
<ol>
<li>使用 POST 方法与自定义动词，例如 <code>POST /apis/books/borrow</code>，表示借书这一动作；</li>
<li>创建一个借书记录，使用资源新增方式来结构不存在的动作，例如 <code>POST /apis/books/borrow-log/</code>；</li>
</ol>
<p>这个问题在复杂的场景中会经常出现，例如用户登录（<code>POST /api/auth/login</code> vs <code>POST /api/session</code>）和帐户转账（vs 转账记录创建）等等。
<mark>API 抽象还是具体，始终离不开业务的解释。</mark>我们不能简单地将所有业务都笼统概括到 CRUD 上面，
而是需要合理划分业务，以便更清晰地实现和让用户理解。</p>
<p>在进行设计时，我们可以考虑是否需要为每个 API 创建一个对应的按钮来方便用户的操作。
如果系统中只有一个名为 <code>/api/do</code> 的 API 并将所有业务都绑定在其中，虽然技术上可行，
但这种设计不符合业务需求，每一层的抽象都是为了标准化解决特定问题的解法，TCP L7 设计就是这种理念的体现。</p>
<p><strong>Readable Stable Identity 解释</strong></p>
<p>在标记一个资源时，我们通常有几种选择：</p>
<ul>
<li>使用 ID：ID 通常与数据库自增 ID 绑定。</li>
<li>使用 GUID：例如 UUID，尽管不那么精确。</li>
<li>使用可读性和稳定性标识符（Readable Stable Identity）：通常使用名称、UID 或特定 ID（如主机名、IP 地址或序列号）来标识，
要求该标识符具有稳定性且全局唯一，在内部系统中非常有用。</li>
</ul>
<p>我个人有一个设计小技巧：使用 <code>${type}/${type-id}</code> 形式的 slug 来描述标识符。Slug 是一种人类可读的唯一标识符，
例如 <code>hostname/abc.sqa</code> 或 <code>ip/172.133.2.1</code>。
这种设计方式可以在可读性和唯一性之间实现很好的平衡。</p>
<blockquote>
<p>A slug is a human-readable, unique identifier, used to identify a resource instead of a less human-readable identifier like an id .</p>
</blockquote>
<p>from <a href="https://itnext.io/whats-a-slug-f7e74b6c23e0">What’s a slug. and why would I use one? | by Dave Sag</a></p>
<p>PS：文章最末我还会介绍一套 Apple Music 方案，这个方案兼顾了 ID / Readable / Stable 的特性。</p>
<p><strong>一级和多级的解释</strong></p>
<p>URL 的层级设计可以根据建模来进行，也可以采用直接单层结构的设计。具体问题的解决方式，
例如在设计用户拥有的书籍时，可以选择多级结构的 <code>/api/users/foo/books</code> 或一级结构的 <code>/api/books?owner=foo</code>。</p>
<p>技术上这两种方案都可以，<mark>前者尊重模型的归属关系，后者则是注重 URL 结构的简单</mark>。</p>
<p>多级结构更直观，但也需要解决可能存在的多种组织方式的问题，例如图书馆中书籍按照作者或类别进行组织？
这种情况下，可以考虑在多级结构中明确模型的归属关系，
例如 <code>/api/author/foo/books</code>（基于作者）或 <code>/api/category/computer/books</code>（基于类别）。</p>
<p><strong>Alias URL 解释</strong></p>
<p>对于一些频繁使用的 URL，虽然可以按照 URL 规则进行设计，但我们仍然可以设计出一个更为简洁的 URL，
以方便用户的展示和使用。这种设计在 Web URL 中尤其常见。比如一个图书馆最热门书籍的 API：</p>
<pre tabindex="0"><code># 原始 URL
https://test.com/apis/v3/books?sort=hot&amp;limit=10

# Alias URL
https://test.com/apis/v3/books/hot
</code></pre><p><strong>模型缩写解释</strong></p>
<p>通常，在对资源进行建模时，会使用较长的名称来命名，例如书籍索引可能被命名为 <code>BookIndex</code> ，而不是 <code>Index</code>。
在 URL 中呈现时，由于 <code>/book/book-index</code> 的 URL 前缀包含了 Book，我们可以减少一层描述，
使 URL 更为简洁，例如使用 <code>/book/index</code>。这种技巧在 Web URL 设计中非常常见。</p>
<p>此外，还有一种模型缩写的策略，即提供一套完整的别名注册方案。别名是全局唯一的，
例如在 Kubernetes 中， <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#deployment-v1-apps">Deployment</a>
是一种常见的命名，而 <code>apps/v1/Deployment</code> 是通过添加 Group 限定来表示完整的名称，
同时还有一个简写为 <code>deploy</code>。这个机制依赖于 Kubernetes 的 API Schema 系统进行注册和工作。</p>
<h3 id="header-最佳实践">Header 最佳实践</h3>
<p>我们常常会忽略 Header 的重要性。实际上，HTTP 动词的选择、HTTP 状态码以及各种身
份验证逻辑（例如 Cookie / Basic Auth / Berear Token）都依赖于 Header 的设计。</p>
<p><strong>设计风格选择</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>解释（见下方单列分析）</th>
<th>方案 A</th>
<th>方案 B</th>
<th>方案 C</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否所有 Verb 都使用 POST</td>
<td><strong>关于全盘 POST</strong></td>
<td>✅</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>修改（Modify）动作是 POST 还是 PATCH？</td>
<td></td>
<td>POST</td>
<td>PATCH</td>
<td></td>
</tr>
<tr>
<td>HTTP Status 返回值</td>
<td><strong>2XX 家族</strong></td>
<td>充分利用 HTTP Status</td>
<td>只用核心状态（200 404 302 等）</td>
<td>只用 200</td>
</tr>
<tr>
<td>是否使用考虑限流系统</td>
<td></td>
<td>✅ 429</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>是否使用缓存系统</td>
<td></td>
<td>✅  ETag / Last Modify</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>是否校验 UserAgent</td>
<td></td>
<td>✅</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>是否校验  Referrral</td>
<td></td>
<td>✅</td>
<td>🚫</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>关于全盘 POST</strong></p>
<p>有些新手（或者自认为有经验的人）可能得出一个错误的结论，即除了 GET 请求以外，
所有的 HTTP 请求都应该使用 POST 方法。甚至有些人要求 <a href="https://www.zhihu.com/question/336797348">所有行为（即使是只读的请求）也应该使用 POST 方法</a>。
这种观点通常会以“简单一致”、“避免缓存”或者“运营商的要求”为由来支持。</p>
<p>然而，我们必须明白 HTTP 方法的设计初衷：它是用来描述资源操作类型的，从而派生出了包括缓存、安全、幂等性等一系列问题。
在相对简单的场景下，省略掉这一层抽象的确不会带来太大的问题，但一旦进入到复杂的领域中，
使用 HTTP 方法这一层抽象就显得非常重要了。<mark>这是否遵循标准将决定你是否能够获得标准化带来的好处</mark>，
类比一下就像一个新的手机厂商可以选择不使用 USB TypeC 接口。
技术上来说是可行的，但同时也失去了很多标准化支持和大家心智上的约定俗成。</p>
<p>我特别喜欢一位 <a href="https://www.zhihu.com/people/huixiong-19">知乎网友</a> 的
<a href="https://www.zhihu.com/question/336797348/answer/2198634068">评论</a>：「<mark>路由没有消失，只是转移了</mark>」。</p>
<p><strong>2XX 家族</strong></p>
<p>HTTP 状态码的用途在于表明客户端与服务器间通信的结果。2XX 状态码系列代表服务器已经成功接收、
理解并处理了客户端请求，回应的内容是成功的。以下是 2XX 系列中常见的状态码及其含义：</p>
<ul>
<li>200 OK：请求已成功处理，服务器返回了响应。</li>
<li>201 Created：请求已经被成功处理，并且在服务器上创建了一个新的资源。</li>
<li>202 Accepted：请求已被服务器接受，但尚未执行。该状态码通常用于异步处理。</li>
<li>204 No Content：请求已成功处理，但是服务器没有返回任何响应体内容。</li>
</ul>
<p>2XX 系列的状态码表示请求已被成功处理，这些状态码可以让客户端明确知晓请求已被正确处理，从而进行下一步操作。</p>
<p>是否需要全面使用 2XX 系列的状态码，取决于是否需要向客户端明确/显示的信息，
告知它下一步动作。如果已经通过其他方式（包括文档、口头协议）描述清楚，
那么确实可以通盘使用 200 状态码进行返回。但基于行为传递含义，
或是基于文档（甚至口头协议）传递含义，哪种更优秀呢？是更为复杂还是更为简洁？</p>
<h3 id="request-最佳实践">Request 最佳实践</h3>
<p><strong>设计风格选择</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>解释（见下方单列分析）</th>
<th>方案 A</th>
<th>方案 B</th>
<th>方案 C</th>
</tr>
</thead>
<tbody>
<tr>
<td>复杂的参数是放到 Form Fields 还是单独一个 JSON Body</td>
<td></td>
<td>Form Fields</td>
<td>Body</td>
<td></td>
</tr>
<tr>
<td>子资源是一次性查询还是独立查询</td>
<td></td>
<td>嵌套</td>
<td>独立查询</td>
<td></td>
</tr>
<tr>
<td>分页参数存放</td>
<td></td>
<td>Header</td>
<td>URL Query</td>
<td></td>
</tr>
<tr>
<td>分页方式</td>
<td><strong>分页方式解释</strong></td>
<td>Page based</td>
<td>Offset based</td>
<td>Continuation token</td>
</tr>
<tr>
<td>分页控制者</td>
<td><strong>分页控制者解释</strong></td>
<td>客户端</td>
<td>服务端</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>分页方式解释</strong></p>
<p>我们最为常见的两种分页方式是 Page-based 和 Offset-based，可以通过公式进行映射。
此外，还存在一种称为 Continuation Token 的方式，其技术类似于 Oracle 的
<a href="https://stackoverflow.com/questions/241622/paging-with-oracle">rownum 分页方案</a>，使用参数 <code>start-from=?</code> 进行描述。
虽然 Continuation Token 的优缺点都十分突出，使用此种方式可以将顺序性用于替代随机性。</p>
<p><strong>分页控制者解释</strong></p>
<p>在某些情况下，我们需要区分客户端分页（Client Pagination）和服务器分页（Server Pagniation）。
客户端分页是指下一页的参数由客户端计算而来，而服务器分页则是由服务器返回 <code>rel</code> 或 JSON.API 等协议。
使用服务器分页可以避免一些问题，例如批量屏蔽了一些内容，如果使用客户端分页，可能会导致缺页或者白屏。</p>
<h3 id="response-最佳实践">Response 最佳实践</h3>
<p><strong>设计风格选择</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>解释（见下方单列分析）</th>
<th>方案 A</th>
<th>方案 B</th>
<th>方案 C</th>
</tr>
</thead>
<tbody>
<tr>
<td>模型呈现种类</td>
<td><strong>模型的几种形式</strong></td>
<td>单一模型</td>
<td>多种模型</td>
<td></td>
</tr>
<tr>
<td>大模型如何包含子模型模型</td>
<td><strong>模型的连接、侧载和嵌入</strong></td>
<td>嵌入</td>
<td>核心模型 + 多次关联资源查询</td>
<td>链接</td>
</tr>
<tr>
<td>字段返回是按需还是归并还是统一</td>
<td></td>
<td>统一</td>
<td>使用 <code>fields</code> 字段按需</td>
<td></td>
</tr>
<tr>
<td>字段表现格式</td>
<td></td>
<td>Snake</td>
<td>Camel</td>
<td></td>
</tr>
<tr>
<td>错误码</td>
<td></td>
<td>无自定，使用 Message</td>
<td>自定义</td>
<td></td>
</tr>
<tr>
<td>错误格式</td>
<td></td>
<td>全局统一</td>
<td>按需</td>
<td></td>
</tr>
<tr>
<td>时区</td>
<td></td>
<td>UTC</td>
<td>Local</td>
<td>Local + TZ</td>
</tr>
<tr>
<td>HATEOAS</td>
<td></td>
<td>✅</td>
<td>🚫</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>模型的几种形式</strong></p>
<p>在 API 设计中，对于模型的表现形式有多种定义。虽然这并不是 API 规范必须讨论的话题，但它对于 API 设计来说是非常重要的。</p>
<p>我将模型常说的模型呈现方式分为一下几类，这并非是专业的界定，借用了 Java 语境下面的一些定义。
这些名称在不同公司甚至不同团队会有不一样的叫法：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202304/models.png" alt="models"  />


</p>
<p><small>image by alswl</small></p>
<ul>
<li>Business Object（BO）：原始的业务模型</li>
<li>Data Object（DO）：存储到 RDBMS 的模型，所以必须是打平的字段结构，有时候一个 BO 会对应到多个 DO</li>
<li>View Object（VO）：呈现到表现层的模型，只保留用户需要看到信息，比如会去掉敏感信息</li>
<li>Data Transfer Object（DTO）：用来在 RPC 系统进行传输的模型，一般和 原始的 Model 差异不大，根据不同序列化系统会有差异
（比如枚举的处理）</li>
</ul>
<p>除此之外，还经常使用两类：Rich Model 和 Tiny Model（请忽略命名，不同团队叫法差异比较大）：</p>
<ul>
<li>Rich Model：用来描述一个丰富模型，这个模型包含了几乎所有需要用的的数据，也允许子资源进行嵌套</li>
<li>Tiny Model：是一个精简模型，往往用来在列表 API 里面被使用</li>
</ul>
<p><strong>模型的连接、侧载和嵌入</strong></p>
<p>在 API 设计中，我们经常需要处理一个模型中包含多个子模型的情况，例如 Book 包含 Comments。
对于这种情况，通常有三种表现形式可供选择：链接（Link）、侧载（Side）和嵌入（Embed）。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202304/models-with-children.png" alt="models-with-children"  />


</p>
<p><small>image by alswl</small></p>
<p>链接（有时候这个 URL 也会隐藏，基于客户端和服务端的隐式协议进行请求）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;朝花夕拾&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;relationships&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;comments&#34;</span><span class="p">:</span> <span class="s2">&#34;http://www.domain.com/book/42/comments&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;author&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;http://www.domain.com/author/鲁迅&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>侧载：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;朝花夕拾&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;relationships&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;comments&#34;</span><span class="p">:</span> <span class="s2">&#34;http://www.domain.com/book/42/comments&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;authors&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;http://www.domain.com/author/鲁迅&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;includes&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;comments&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">91</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;author&#34;</span><span class="p">:</span> <span class="s2">&#34;匿名&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;content&#34;</span><span class="p">:</span> <span class="s2">&#34;非常棒&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;authors&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;鲁迅&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;鲁迅原名周树人&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>嵌入：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;朝花夕拾&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;comments&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">91</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;author&#34;</span><span class="p">:</span> <span class="s2">&#34;匿名&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;content&#34;</span><span class="p">:</span> <span class="s2">&#34;非常棒&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;authors&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;鲁迅&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;鲁迅原名周树人&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="其他">其他</h3>
<p>还有一些问题没有收敛在四要素里面，但是我们在工程实践中也经常遇到，我将其捋出来：</p>
<p><strong>我不是 HTTP 协议，怎么办？</strong></p>
<p>Web API 中较少遇到非 HTTP 协议，新建一套协议的成本太高了。在某些特定领域会引入一些协议，
比如 IoT 领域的 <a href="https://mqtt.org/">MQTT</a>。</p>
<p>此外，RPC 是一个涉及广泛领域的概念，其内容远远不止于协议层面。
通常我们会将 HTTP 和 RPC 的传输协议以及序列化协议进行对比。
我认为，本文中的许多讨论也对 RPC 领域具有重要意义。</p>
<p>有些团队或个人计划使用自己创建的协议，但我的观点是应尽量避免自建协议，因为真正需要创建协议的情况非常罕见。
如果确实存在强烈的需要，那么我会问两个问题：是否通读过 HTTP RFC 文档和 HTTP/2 RFC 文档？</p>
<p><strong>我不是远程服务（RPC / HTTP 等），而是 SDK 怎么办？</strong></p>
<p>本文主要讨论的是 Web API（HTTP）的设计规范，并且其中一些规则可以借鉴到 RPC 系统中。
然而，讨论的基础都是建立在远程服务（Remote Service）的基础之上的。
如果你是 SDK 开发人员，你会有两个角色，可能会作为客户端和远程服务器进行通信，
同时还会作为 SDK 提供面向开发人员的接口。对于后者，以下几个规范可以作为参考：</p>
<p>后者可以参考一下这么几个规范：</p>
<ul>
<li>Azure SDK 设计规范 <a href="https://azure.github.io/azure-sdk/general_design.html">General Guidelines: API Design | Azure SDKs</a></li>
<li>Posix API 范例（比如 File <a href="https://www.gnu.org/software/libc/manual/html_node/Low_002dLevel-I_002fO.html">Low-Level I/O (The GNU C Library)</a>)</li>
</ul>
<p><strong>认证鉴权方案</strong></p>
<p>一般而言，Web API 设计中会明确描述所采用的认证和鉴权系统。
需要注意区分「认证」和「鉴权」两个概念。关于「认证」这一话题，可以在单独的章节中进行讨论，因此本文不会展开这一方面的内容。</p>
<p>在 Web API 设计中，常见的认证方式包括：HTTP Basic Auth、OAuth2 和账号密码登录等。
常用的状态管理方式则有 Bearer Token 和 Cookie。此外，在防篡改等方面，还会采用基于 HMac 算法的防重放和篡改方案。</p>
<p><strong>忽略掉的话题</strong></p>
<p>在本次讨论中，我未涉及以下话题：异步协议（Web Socket / Long Pulling / 轮训）、CORS、以及安全问题。
虽然这些话题重要，但是在本文中不予展开。</p>
<p><strong>什么时候打破规则</strong></p>
<p>有些开发者认为规则就是为了打破而存在的。现实往往非常复杂，我们难以讨论清楚各个细节。
如果开发者觉得规则不符合实际需求，有两种处理方式：修改规则或打破规则。
然而，我更倾向于讨论和更新规则，明确规范不足之处，确定是否存在特殊情况。
如果确实需要创建特例，一定要在文档中详细描述，告知接任者和消费者这是一个特例，说明特例产生的原因以及特例是如何应对的。</p>
<h2 id="一张风格-checklist">一张风格 Checklist</h2>
<h3 id="github-风格">Github 风格</h3>
<p>Github 的 API 是我常常参考的对象。它对其业务领域建模非常清晰，提供了详尽的文档，使得沟通成本大大降低。
我主要参考以下两个链接：
API 定义 <a href="https://docs.github.com/en/rest?apiVersion=2022-11-28">GitHub REST API documentation</a> 和
面向应用程序提供的 API 列表 <a href="https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps?apiVersion=2022-11-28">Endpoints available for GitHub Apps</a>
，该列表几乎包含了 Github 的全部 API。</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>选择</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>URL</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>API Path 里面 Prefix</td>
<td>二级域名</td>
<td><a href="https://api.github.com">https://api.github.com</a></td>
</tr>
<tr>
<td>Path 里面是否包含 API 版本</td>
<td>🚫</td>
<td>Header <code>X-GitHub-Api-Version</code> <a href="https://docs.github.com/en/rest/overview/api-versions?apiVersion=2022-11-28">API Versions</a></td>
</tr>
<tr>
<td>Path 是否包含 Group</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>Path 是否包含动作</td>
<td>看情况（如果 HTTP Verb CRUD 无法满足就包含）</td>
<td>比如 <code>PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge</code> <code>POST /repos/{owner}/{repo}/releases/generate-notes</code></td>
</tr>
<tr>
<td>模型 ID 形式</td>
<td>Readable Stable Identity</td>
<td></td>
</tr>
<tr>
<td>URL 中模型单数还是复数</td>
<td>复数</td>
<td></td>
</tr>
<tr>
<td>资源是一级（平铺）还是多级（嵌套）</td>
<td>多级</td>
<td></td>
</tr>
<tr>
<td>搜索如何实现，独立接口（<code>/models/search</code>）还是基于列表<code>/models/</code> 接口</td>
<td>独立</td>
<td></td>
</tr>
<tr>
<td>是否有 Alias URL</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>URL 中模型是否允许缩写（或精简）</td>
<td>🚫</td>
<td>没有看到明显信息，基于多级模型也不需要，但是存在 <code>GET /orgs/{org}/actions/required_workflows</code></td>
</tr>
<tr>
<td>URL 中模型多个词语拼接的连字符</td>
<td><code>-</code> 和 <code>_</code></td>
<td><code>GET /repos/{owner}/{repo}/git/matching-refs/{ref}</code> vs <code>GET /orgs/{org}/actions/required_workflows</code></td>
</tr>
<tr>
<td>是否要区分 Web API 以及 Open API（面向非浏览器）</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td><strong>Header</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>是否所有 Verb 都使用 POST</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>修改（Modify）动作是 POST 还是 PATCH？</td>
<td>PATCH</td>
<td></td>
</tr>
<tr>
<td>HTTP Status 返回值</td>
<td>充分利用 HTTP Status</td>
<td>常用，包括限流洗损</td>
</tr>
<tr>
<td>是否使用考虑限流系统</td>
<td>✅ 429</td>
<td></td>
</tr>
<tr>
<td>是否使用缓存系统</td>
<td>✅  ETag / Last Modify</td>
<td><a href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api?apiVersion=2022-11-28#client-errors">Resources in the REST API#client-errors</a></td>
</tr>
<tr>
<td>是否校验 UserAgent</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>是否校验 Referrral</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td><strong>Request</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>复杂的参数是放到 Form Fields 还是单独一个 JSON Body</td>
<td>Body</td>
<td>参考 <a href="https://docs.github.com/en/rest/pulls/pulls?apiVersion=2022-11-28#create-a-pull-request">Pulls#create-a-pull-request</a></td>
</tr>
<tr>
<td>子资源是一次性查询还是独立查询</td>
<td>嵌套</td>
<td>从 Pulls 进行判断</td>
</tr>
<tr>
<td>分页参数存放</td>
<td>URL Query</td>
<td></td>
</tr>
<tr>
<td>分页方式</td>
<td>Page</td>
<td><a href="https://docs.github.com/en/rest/guides/using-pagination-in-the-rest-api?apiVersion=2022-11-28">Using pagination in the REST API</a></td>
</tr>
<tr>
<td>分页控制者</td>
<td>服务端</td>
<td>同上</td>
</tr>
<tr>
<td><strong>Response</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>模型呈现种类</td>
<td>多种模型</td>
<td>比如 Commits 里面的 明细和 Parent <a href="https://docs.github.com/en/rest/commits/commits?apiVersion=2022-11-28">Commits</a></td>
</tr>
<tr>
<td>大模型如何包含子模型模型</td>
<td>核心模型 + 多次关联资源查询？</td>
<td>没有明确说明，根据几个核心 API 反推</td>
</tr>
<tr>
<td>字段返回是按需还是归并还是统一</td>
<td>统一</td>
<td></td>
</tr>
<tr>
<td>字段表现格式</td>
<td>Snake</td>
<td></td>
</tr>
<tr>
<td>错误码</td>
<td>无</td>
<td><a href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api?apiVersion=2022-11-28#client-errors">Resources in the REST API#client-errors</a></td>
</tr>
<tr>
<td>错误格式</td>
<td>全局统一</td>
<td><a href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api?apiVersion=2022-11-28#client-errors">Resources in the REST API#client-errors</a></td>
</tr>
<tr>
<td>时区</td>
<td>复合方案（ISO 8601 &gt; Time-Zone Header &gt; User Last &gt; UTC）</td>
<td><a href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api?apiVersion=2022-11-28#timezones">Resources in the REST API#Timezones</a></td>
</tr>
<tr>
<td>HATEOAS</td>
<td>🚫</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="azure-风格">Azure 风格</h3>
<p>Azure 的 API 设计遵循 <a href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md">api-guidelines/Guidelines.md at master · microsoft/api-guidelines</a>，
这篇文章偏原理性，另外还有一份实用指导手册在 <a href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/index-best-practices">Best practices in cloud applications</a>
和 <a href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design">Web API design best practices</a>。</p>
<p>需要注意的是，Azure 的产品线远比 Github 丰富，一些 API 也没有遵循 Azure 自己的规范。
在找实例时候，我主要参考
<a href="https://learn.microsoft.com/en-us/rest/api/?view=Azure">REST API Browser </a>，
<a href="https://learn.microsoft.com/en-us/rest/api/storageservices/">Azure Storage REST API Reference </a>。
如果具体实现和 Guidelines.md 冲突，我会采用 Guidelines.md 结论。</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>选择</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>URL</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>API Path 里面 Prefix</td>
<td>二级域名</td>
<td></td>
</tr>
<tr>
<td>Path 里面是否包含 API 版本</td>
<td>🚫</td>
<td><code>x-ms-version</code></td>
</tr>
<tr>
<td>Path 是否包含 Group</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>Path 是否包含动作</td>
<td>🚫？</td>
<td>没有明确说明，但是有倾向使用 <code>comp</code> 参数来进行动作，保持 URL 的 RESTful 参考 <a href="https://learn.microsoft.com/en-us/rest/api/storageservices/lease-container?tabs=azure-ad">Lease Container (REST API) - Azure Storage</a></td>
</tr>
<tr>
<td>模型 ID 形式</td>
<td>Readable Stable Identity</td>
<td><a href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#73-canonical-identifier">Guidelines.md#73-canonical-identifier</a></td>
</tr>
<tr>
<td>URL 中模型单数还是复数</td>
<td>复数</td>
<td><a href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#93-collection-url-patterns">Guidelines.md#93-collection-url-patterns</a></td>
</tr>
<tr>
<td>资源是一级（平铺）还是多级（嵌套）</td>
<td>多级 / 一级</td>
<td><a href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design#define-api-operations-in-terms-of-http-methods">api-design#define-api-operations-in-terms-of-http-methods</a>，注 MS 有 <code>comp=?</code> 这种参数，用来处理特别的命令</td>
</tr>
<tr>
<td>搜索如何实现，独立接口（<code>/models/search</code>）还是基于列表<code>/models/</code> 接口</td>
<td>?</td>
<td>倾向于基于列表，因为大量使用 <code>comp=</code> 这个 URL Param 来进行子命令，比如 <a href="https://learn.microsoft.com/en-us/rest/api/storageservices/incremental-copy-blob">Incremental Copy Blob (REST API) - Azure Storage</a></td>
</tr>
<tr>
<td>是否有 Alias URL</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>URL 中模型是否允许缩写（或精简）</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>URL 中模型多个词语拼接的连字符</td>
<td>Camel</td>
<td><a href="https://learn.microsoft.com/en-us/rest/api/storagemover/job-runs/list?tabs=HTTP">Job Runs - List - REST API (Azure Storage Mover)</a></td>
</tr>
<tr>
<td>是否要区分 Web API 以及 Open API（面向非浏览器）</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td><strong>Header</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>是否所有 Verb 都使用 POST</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>修改（Modify）动作是 POST 还是 PATCH？</td>
<td>PATCH</td>
<td><a href="https://learn.microsoft.com/en-us/rest/api/storagemover/agents/update?tabs=HTTP">Agents - Update - REST API (Azure Storage Mover)</a></td>
</tr>
<tr>
<td>HTTP Status 返回值</td>
<td>充分利用 HTTP Status</td>
<td><a href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#711-http-status-codes">Guidelines.md#711-http-status-codes</a></td>
</tr>
<tr>
<td>是否使用考虑限流系统</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>是否使用缓存系统</td>
<td>✅</td>
<td><a href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#75-standard-request-headers">Guidelines.md#75-standard-request-headers</a></td>
</tr>
<tr>
<td>是否校验 UserAgent</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>是否校验 Referrral</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td><strong>Request</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>复杂的参数是放到 Form Fields 还是单独一个 JSON Body</td>
<td>Body</td>
<td>参考 <a href="https://learn.microsoft.com/en-us/rest/api/storagemover/agents/create-or-update?tabs=HTTP">Agents - Create Or Update - REST API (Azure Storage Mover)</a></td>
</tr>
<tr>
<td>子资源是一次性查询还是独立查询</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>分页参数存放</td>
<td>?</td>
<td>没有结论</td>
</tr>
<tr>
<td>分页方式</td>
<td>Page based</td>
<td></td>
</tr>
<tr>
<td>分页控制者</td>
<td>服务端</td>
<td><a href="https://learn.microsoft.com/en-us/rest/api/storagemover/agents/list?tabs=HTTP">Agents - List - REST API (Azure Storage Mover)</a></td>
</tr>
<tr>
<td><strong>Response</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>模型呈现种类</td>
<td>单一模型</td>
<td>推测</td>
</tr>
<tr>
<td>大模型如何包含子模型模型</td>
<td>?</td>
<td>场景过于复杂，没有单一结论</td>
</tr>
<tr>
<td>字段返回是按需还是归并还是统一</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>字段表现格式</td>
<td>Camel</td>
<td></td>
</tr>
<tr>
<td>错误码</td>
<td>使用自定错误码清单</td>
<td>至少在各自产品内</td>
</tr>
<tr>
<td>错误格式</td>
<td>自定义</td>
<td></td>
</tr>
<tr>
<td>时区</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>HATEOAS</td>
<td>?</td>
<td><a href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design#use-hateoas-to-enable-navigation-to-related-resources">api-design#use-hateoas-to-enable-navigation-to-related-resources</a></td>
</tr>
</tbody>
</table>
<p>Azure 的整体设计风格要比 Github API 更复杂，同一个产品的也有多个版本的差异，看
上去统一性要更差一些。这种复杂场景想用单一的规范约束所有团队的确也是更困难的。
我们可以看到 Azaure 团队在 Guidelines 上面努力，他们最近正在推出 vNext 规范。</p>
<h3 id="我个人风格">我个人风格</h3>
<p>我个人风格基本继承自 Github API 风格，做了一些微调，更适合中小型产品开发。
我的改动原因都在备注中解释，改动出发点是：简化 / 减少歧义 / 考虑实际成本。如果备注里面标记了「注」，则是遵循 Github 方案并添加一些观点。</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>选择</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>URL</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>API Path 里面 Prefix</td>
<td><code>/apis</code></td>
<td>我们往往只有一个系统，一个域名要承载 API 和 Web Page</td>
</tr>
<tr>
<td>Path 里面是否包含 API 版本</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>Path 是否包含 Group</td>
<td>✅</td>
<td>做一层业务模块拆分，隔离一定合作边界</td>
</tr>
<tr>
<td>Path 是否包含动作</td>
<td>看情况（如果 HTTP Verb CRUD 无法满足就包含）</td>
<td></td>
</tr>
<tr>
<td>模型 ID 形式</td>
<td>Readable Stable Identity</td>
<td></td>
</tr>
<tr>
<td>URL 中模型单数还是复数</td>
<td>复数</td>
<td></td>
</tr>
<tr>
<td>资源是一级（平铺）还是多级（嵌套）</td>
<td>多级 + 一级</td>
<td>注：80% 情况都是遵循模型的归属，少量情况（常见在搜索）使用一级</td>
</tr>
<tr>
<td>搜索如何实现，独立接口（<code>/models/search</code>）还是基于列表<code>/models/</code> 接口</td>
<td>统一 &gt; 独立</td>
<td>低成本实现一些（早期 Github Issue 也是没有 <code>/search</code> 接口</td>
</tr>
<tr>
<td>是否有 Alias URL</td>
<td>🚫</td>
<td>简单点</td>
</tr>
<tr>
<td>URL 中模型是否允许缩写（或精简）</td>
<td>✅</td>
<td>一旦做了精简，需要在术语表标记出来</td>
</tr>
<tr>
<td>URL 中模型多个词语拼接的连字符</td>
<td><code>-</code></td>
<td></td>
</tr>
<tr>
<td>是否要区分 Web API 以及 Open API（面向非浏览器）</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td><strong>Header</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>是否所有 Verb 都使用 POST</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td>修改（Modify）动作是 POST 还是 PATCH？</td>
<td>PATCH</td>
<td></td>
</tr>
<tr>
<td>HTTP Status 返回值</td>
<td>充分利用 HTTP Status</td>
<td></td>
</tr>
<tr>
<td>是否使用考虑限流系统</td>
<td>✅ 429</td>
<td></td>
</tr>
<tr>
<td>是否使用缓存系统</td>
<td>🚫</td>
<td>简单一些，使用动态数据，去除缓存能力</td>
</tr>
<tr>
<td>是否校验 UserAgent</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>是否校验 Referrral</td>
<td>🚫</td>
<td></td>
</tr>
<tr>
<td><strong>Request</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>复杂的参数是放到 Form Fields 还是单独一个 JSON Body</td>
<td>Body</td>
<td></td>
</tr>
<tr>
<td>子资源是一次性查询还是独立查询</td>
<td>嵌套</td>
<td></td>
</tr>
<tr>
<td>分页参数存放</td>
<td>URL Query</td>
<td></td>
</tr>
<tr>
<td>分页方式</td>
<td>Page</td>
<td></td>
</tr>
<tr>
<td>分页控制者</td>
<td>客户端</td>
<td>降低服务端成本，容忍极端情况空白</td>
</tr>
<tr>
<td><strong>Response</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>模型呈现种类</td>
<td>多种模型</td>
<td>使用的 BO / VO / Tiny / Rich</td>
</tr>
<tr>
<td>大模型如何包含子模型模型</td>
<td>核心模型 + 多次关联资源查询</td>
<td></td>
</tr>
<tr>
<td>字段返回是按需还是归并还是统一</td>
<td>统一</td>
<td>Tiny Model（可选） / Model（默认） / Rich Model（可选）</td>
</tr>
<tr>
<td>字段表现格式</td>
<td>Snake</td>
<td></td>
</tr>
<tr>
<td>错误码</td>
<td>无</td>
<td>注：很多场景只要 message</td>
</tr>
<tr>
<td>错误格式</td>
<td>全局统一</td>
<td></td>
</tr>
<tr>
<td>时区</td>
<td>ISO 8601</td>
<td>只使用一种格式，不再支持多种方案</td>
</tr>
<tr>
<td>HATEOAS</td>
<td>🚫</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="题外话---apple-music-的一个有趣设计">题外话 - Apple Music 的一个有趣设计</h2>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202304/apple-music.png" alt="Apple Music"  />


</p>
<p><small>image from Apple Music</small></p>
<p>我最近在使用 Apple Music 时注意到了其 Web 页面的 URL 结构：</p>
<p><code>/cn/album/we-sing-we-dance-we-steal-things/277635758?l=en</code></p>
<p>仔细看这个 URL 结构，可以发现其中 Path 包含了人类可读的 slug，分为三个部分：<code>alumn/$(name)/$(id)</code> （其中包含了 ID）。
我立即想到了一个问题：中间的可读名称是否无机器意义，纯粹面向自然人？
于是我测试了一个捏造的地址：<code>/cn/album/foobar/277635758?l=en</code>。
在您尝试访问之前，您能猜出结果是否可以访问吗？</p>
<p>这种设计范式比我现在常用的 URL 设计规范要复杂一些。我的规范要求将资源定位使用两层 slug 组织，即 <code>$(type)/$(id)</code>。
而苹果使用了 <code>$(type)/(type-id)/$(id)</code>，同时照顾了可读性和准确性。</p>
<h2 id="题外话---为什么-graphql-不行">题外话 - 为什么 GraphQL 不行</h2>
<p><a href="https://graphql.org/">GraphQL</a> 是一种通过使用自定义查询语言来请求 API 的方式，它的优点在于可以提供更灵活的数据获取方式。
相比于 RESTful API 需要一次请求获取所有需要的数据，GraphQL 允许客户端明确指定需要的数据，从而减少不必要的数据传输和处理。</p>
<p>然而，GraphQL 的过于灵活也是它的缺点之一。由于它没有像 REST API 那样有一些业务场景建模的规范，
开发人员需要自己考虑数据的处理方式。
这可能导致一些不合理的查询请求，对后端数据库造成过度的压力。此外，GraphQL 的实现和文档相对较少，也需要更多的学习成本。</p>
<p>因此，虽然 GraphQL 可以在一些特定的场景下提供更好的效果，但它并不适合所有的 API 设计需求。
实际上，一些公司甚至选择放弃支持 GraphQL，例如 Github 的 <a href="https://github.blog/changelog/2022-08-18-deprecation-notice-graphql-for-packages/">一些项目</a>。</p>
<h2 id="最后">最后</h2>
<blockquote>
<p>Complexity is incremental （复杂度是递增的）</p>
<ul>
<li>John Ousterhout (<a href="https://web.stanford.edu/~ouster/cgi-bin/cs190-winter18/lecture.php?topic=complexity">via</a>）</li>
</ul>
</blockquote>
<p><mark>风格没有最好，只有最适合，但是拥有风格是很重要的。</mark></p>
<p>建立一个优秀的规则不仅需要对现有机制有深刻的理解，还需要对业务领域有全面的掌握，并在团队内进行有效的协作与沟通， 推广并实施规则。
不过，一旦规则建立起来，就能够有效降低系统的复杂度，避免随着时间和业务的推进而不断增加的复杂性， 并减少研发方面的沟通成本。</p>
<p>这是一项长期的投资，但能够获得持久的回报。希望有长远眼光的人能够注意到这篇文章。</p>
<p>主要参考文档：</p>
<ul>
<li><a href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md">api-guidelines/Guidelines.md at master · microsoft/api-guidelines</a></li>
<li><a href="https://docs.github.com/en/rest/overview/about-githubs-apis?apiVersion=2022-11-28">GitHub&rsquo;s APIs</a></li>
<li><a href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design">Web API design best practices - Azure Architecture Center | Microsoft Learn</a></li>
<li><a href="https://developer.aliyun.com/article/701810">API 设计最佳实践的思考 - 谷朴</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Python 的类型系统</title>
      <link>https://blog.alswl.com/2020/06/type-safe-python/</link>
      <pubDate>Tue, 23 Jun 2020 17:54:00 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2020/06/type-safe-python/</guid>
      <description>image from pixabay.com 静态类型正在逐渐成为潮流， 2010 年之后诞生的几门语言 Go、Rust、TypeScript 等都走了静态类型路线。 过往流行的一些动态语言（Python、PHP、JavaScript）也在积极引入语言新特性（Type Hint、TypeScript）对静态类型增强。 我曾使用 Python 开发规模较大的项目，感受过动态语言在工程规模变大时候带来的困难： 在重构阶段代码回归成本异常之高，很多历史代码不敢动。 后来技术栈转到</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/202006/wall.png" alt="wall"  />



<small>image from pixabay.com</small></p>
<p>静态类型正在逐渐成为潮流，
2010 年之后诞生的几门语言 Go、Rust、TypeScript 等都走了静态类型路线。
过往流行的一些动态语言（Python、PHP、JavaScript）也在积极引入语言新特性（Type Hint、TypeScript）对静态类型增强。</p>
<p>我曾使用 Python 开发规模较大的项目，感受过动态语言在工程规模变大时候带来的困难：
在重构阶段代码回归成本异常之高，很多历史代码不敢动。
后来技术栈转到 Java，被类型系统怀抱让人产生安全感。</p>
<p>最近一年在一个面向稳定性的运维系统耕耘。系统选型之初使用了 Python。
我在项目中力推了 Python 3.7，并大规模使用了 Python 的类型系统来降低潜在风险。</p>
<p>追根溯源，我花了一些时间了解 Python 在类型系统的设计和实现，
本文以 PEP 提案介绍一下 Python 在类型系统上面走过的路。</p>
<!-- more -->
<h2 id="类型系统">类型系统</h2>
<p>谈类型系统之前，要厘定两个概念，动态语言和动态类型。</p>
<p>动态语言（Dynamic Programming Language）则是指程序在运行时可以改变结构。
这个结构可以包含函数、对象、变量类型、程序结构。
动态类型是类型系统（Type System）其中一类，即程序在运行期间可以修改变量类型。
另外一种是静态类型：在编译期就决定了变量类型，运行期不允许发生变化。
类型系统还有一种分法是强类型和弱类型，强类型是指禁止类型不匹配的指令，弱类型反之。</p>
<p>动态语言和动态类型这两个概念切入点不一样，
Python 是一门动态语言，也是动态类型语言，还是强类型的动态类型。
这篇文章主要讨论 Python 语言的类型系统，不会涉及动态语言特性。</p>
<h2 id="类型安全之路">类型安全之路</h2>
<p>行业里面一直有一个争论：动态类型和静态类型哪一种更强大。
静态类型的支持者认为三个方面具备优势：性能、错误发现、高效重构。
静态类型通过编译期决定具体类型可以显著的提高运行期效率；
编译期就能够发现错误，在工程规模逐步变大时候尤其明显；
类型系统可以帮助 IDE 提示，高效重构。
动态类型的支持者则认为分析代码会更简单，减少出错机会，写起来也更为快速。</p>
<p>Python 开发者们并非没有看到这个痛点，
一系列 PEP 提案应运而生。
在保留 Python 动态类型系统优势前提，通过语法、特性增强，将类型系统引入 Python。</p>
<p>Python 在 2014 年即提出了 PEP 484，随后提出一个精粹版 PEP 483（The Theory of Type Hints），
其工程实现 <a href="https://docs.python.org/3/library/typing.html">typing</a> 模块在 3.5 发布。
经过 PEP 484，PEP 526，PEP 544，PEP 586，PEP 589，PEP 591 的多次版本迭代，Python 的类型系统已经很丰富。
甚至包含了比如 Structural Subtyping 以及 Literal Typing 这边相对罕见的特性。</p>
<h3 id="pep-483---核心概念">PEP 483 - 核心概念</h3>
<p><a href="https://www.python.org/dev/peps/pep-0483/">PEP 483</a> 在 2014 年 12 月发布，
是 Guido 起笔的核心概念版，简明扼要的写清楚 Python 的类型系统建设方向、边界、要和不要。</p>
<p>PEP 483 没有谈具体工程实现，提纲挈领地讲了一下 Python 类型系统如何对外呈现。
厘定 Type / Class 差别，前者是语法分析概念，后者是运行时概念。
在这个定义下面 Class 都是一个 Type，但 Type 未必是 Class。
举例 <code>Union[str, int]</code> 是 Type 但并不是 Class。</p>
<p>PEP 483 还介绍内建基础类型：<code>Any</code> / <code>Unison</code> / <code>Optional</code> / <code>Tuple</code> / <code>Callable</code>，这些基础类型支撑上游丰富变化。</p>
<p>静态类型系统最大的诟病是不够灵活，Go 语言现在还没有实现泛型。
PEP 483 介绍了 Python Generic types 泛型使用方法，
形式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">longest</span><span class="p">(</span><span class="n">first</span><span class="p">:</span> <span class="n">S</span><span class="p">,</span> <span class="n">second</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">first</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">second</span><span class="p">)</span> <span class="k">else</span> <span class="n">second</span>
</span></span></code></pre></div><p>最后，PEP 483 还提了一些重要的小特性：</p>
<ul>
<li>别称 Alias</li>
<li>前置引用 Farward Reference（在定义类方法注解中使用定义类），eg.：解决二叉树 Node 节点中需要引用 Node 问题</li>
<li>covariance contravariant 协变逆变</li>
<li>使用注释标记类型</li>
<li>转型 Cast</li>
</ul>
<p>PEP 483 的实现，主要依赖了 <a href="https://www.python.org/dev/peps/pep-3107/">PEP 3107 &ndash; Function Annotations</a>
这个提案。PEP 3107 介绍 function 注解使用。比如， <code>func(a: a1, b: b1) -&gt; r1</code>
这段代码，
其中冒号后面的描述符记录会到 func 的 <code>__annotations__</code> 变量中。</p>
<p>PEP 3107 效果展示如下，可以清晰看到函数变量存放：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">add</span><span class="o">.</span><span class="vm">__annotations__</span>
</span></span><span class="line"><span class="cl"><span class="c1"># {&#39;x&#39;: int, &#39;y&#39;: int, &#39;return&#39;: int}</span>
</span></span></code></pre></div><p>PS：现在 Python 有了 Decorator 装饰器 / Annotation 注解，其中 Annotation 的设计还和 Java 的 Annotation 同名，一锅粥。</p>
<h3 id="pep-484---type-hints-核心">PEP 484 - Type Hints 核心</h3>
<p><a href="https://www.python.org/dev/peps/pep-0484/">PEP 484 &ndash; Type Hints</a>
在 PEP 483 基础上完整讲述 Python 类型系统如何设计，如何使用，细节如何（typing 模块）</p>
<p>这篇提案开宗明义地点出：</p>
<blockquote>
<p>Python will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory,
even by convention.</p>
</blockquote>
<p>一句话断绝了 Python 在语言级别进化到静态系统的可能。</p>
<p>提案除了 PEP 483 已经讲解的特性，还有以下吸引我的点：</p>
<ul>
<li>允许通过 Stub Files 为已经存在的库添加类型描述。具体是使用 Python 文件对应的 <code>.pyi</code> 文件描述 Python 代码的带类型签名。
这个方案和 TS 的 <code>@types</code> 文件有异曲同工之妙。</li>
<li>允许使用 <code>@overload</code> 进行类型重载，这也是活久见，Python 居然可以（在某种意义上）支持重载了。</li>
<li>介绍了 typing 实现细节，比如使用 abs（Abstract Base Class）构建常见类型的 interface，包括 <code>Sized</code> / <code>Iterable</code> 这些基础接口。
我个人认为这个工作量是其实挺大，是给已有的类进行一次依赖梳理。</li>
<li>介绍了 Python 向后（Python 2）兼容方法，有这么几种策略：
使用 decorator（<code>@typehints(foo=str, returns=str)</code>）、comments、Stub files、Docstring</li>
</ul>
<h3 id="pep-526---变量也安排上了">PEP 526 - 变量也安排上了</h3>
<p><a href="https://www.python.org/dev/peps/pep-0526/">PEP 526 &ndash; Syntax for Variable Annotations</a>
核心提案是给变量加上 Type Hints 支持。</p>
<p>和 <code>function annotation</code> 类似，也是通过注解方式存放。
差异是并不是给实例添加一个 <code>__annotations__</code> 成员，而是将变量的 annotations 信息存放在上下文变量 <code>__annotations__</code> 之中。
这个其实也比较好理解：定义一个变量类型时候，这个变量还没有初始化。</p>
<p>我写一段 Demo 展示一下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
</span></span><span class="line"><span class="cl"><span class="n">users</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># print(__annotations__)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># {&#39;users&#39;: typing.List[int]}</span>
</span></span></code></pre></div><p>可以看到，上述 Demo 效果是在上下文变量创建了一个 <code>users</code>，但这个 <code>users</code> 其实并不存在，只是定义了类型，
如果运行 <code>print(users)</code> 会抛出 <code>NameError: name 'users' is not defined</code>。</p>
<p>观察字节码会更清晰：</p>
<pre tabindex="0"><code> L.   1         0  SETUP_ANNOTATIONS

 L.   1         2  LOAD_CONST               0
                4  LOAD_CONST               (&#39;List&#39;,)
                6  IMPORT_NAME              typing
                8  IMPORT_FROM              List
               10  STORE_NAME               List
               12  POP_TOP

 L.   3        14  LOAD_NAME                List
               16  LOAD_NAME                int
               18  BINARY_SUBSCR
               20  LOAD_NAME                __annotations__
               22  LOAD_STR                 &#39;users&#39;
               24  STORE_SUBSCR
               26  LOAD_CONST               None
               28  RETURN_VALUE
</code></pre><p>可以清晰看到，并没有创建一个名为 users 的变量，而是使用了 <code>__annotations__</code> 变量。
注：Python 存储变量使用 opcode 是 <code>STORE_NAME</code>。</p>
<p>PS：本提案中有不少被否决的提案，挺有趣的，社区提出了很多奇淫巧计。
可以看出社区决策的慎重，存量系统升级的难度。</p>
<h3 id="pep-544---nominal-subtyping-vs-structural-subtyping">PEP 544 - Nominal Subtyping vs Structural Subtyping</h3>
<p>PEP 484 里面类型系统讨论的是 Nominal Subtyping，
这个 <a href="https://www.python.org/dev/peps/pep-0544/">PEP 544 &ndash; Protocols: Structural subtyping (static duck typing)</a>
则是提出了Structural Subtyping。
如果非要翻译，我觉得可以称为具名子类型 / 同构子类型。
注意，也有人将 Structural Subtyping 称之为 Duck Typing，其实这两者不相同，具体可以见
<a href="https://en.wikipedia.org/wiki/Duck_typing#Structural_type_systems">Duck typing / Comparison with other type systems</a>。</p>
<p>Nominal Subtyping 是指按字面量匹配类型，而 Structural Subtyping 则是按照结构（行为）进行匹配，
比如 Go 的 Type 就是 Structural Subtyping 实现。</p>
<p>这里写个简单 Demo 展示一下后者：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Bucket</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">Bucket</span><span class="p">())</span>  <span class="c1"># Passes type check</span>
</span></span></code></pre></div><p>代码中定义了 Bucket 这种类型，并且提供了两个类成员。这两个类成员刚好是 Interator 的定义。
那么在实际使用中，就可以使用 Bucket 替换 Iterable。</p>
<h3 id="pep-586--pep-589--pep-591-持续增强">PEP 586 / PEP 589 / PEP 591 持续增强</h3>
<p><a href="https://www.python.org/dev/peps/pep-0586/">PEP 586 &ndash; Literal Types</a>
在 Python 3.8 实现，支持了字面量作为类型使用。
比如 <code>Literal[4]</code>，举一个更有语义的例子 <code>Literal['GREEN']</code>。</p>
<p>我第一反应这和 Scala 里面的 Symbol 非常像，Scala 中写法是 <code>Symbol(&quot;GREEN&quot;)</code>。
这个特性使用挺学院派，很容易在 DSL 里面写的天花乱坠。
Scala 官方有说过可能在未来移除 Symbol 特性，建议直接使用常量替代。</p>
<p><a href="https://www.python.org/dev/peps/pep-0589/">PEP 589 &ndash; TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys</a>
给 Dict 增加 key 的 Type，继承 <code>TypedDict</code>。</p>
<p><a href="https://www.python.org/dev/peps/pep-0591/">PEP 591 &ndash; Adding a final qualifier to typing</a>
增加 <code>final</code> / <code>Final</code> 两个概念，前者是装饰器，后者是注解，标注该类 / 函数 / 变量无法修改</p>
<p>至此，Python 3.8 已经具备我们日常需要的类型系统特性（非运行时 😂）。</p>
<h2 id="总结">总结</h2>
<p>遗憾的是，<code>typing</code> 模块在文档鲜明的标注：</p>
<blockquote>
<p>The Python runtime does not enforce function and variable type annotations. They can be used by third party tools
such as type checkers, IDEs, linters, etc.</p>
</blockquote>
<p>即：Python 运行时（Intercepter / Code Evaluator）并不支持函数和变量的类型装饰符。
这些装饰符只能由第三方工具检查，比如类型检查器、IDE、静态、Linter。</p>
<p>这个信息说明了 Python 在类型安全上尝试的局限性。所有的限制、约束都不会发生在运行时，
想要从类型系统中收获工程上面的价值，只能借助第三方工具。</p>
<p>诚然，Python 社区在竭力向类型系统靠拢，但是这种非语言级别 Runtime 的支持，到底能走多远呢？
Python 缺少金主爸爸，干爹 Red Hat 投入资源也有限。连社区从 Python 2 切换到 Python 3 都还没走完，为何？
投入产出比太低，新特性缺乏足够的吸引力，替代品太多。</p>
<p>另一方面，看看竞对们：
动态语言在往静态语言靠拢，而静态语言也在不断吸收动态语言的特性。比如 Java 14 里面的 REPL（Read-Eval-Print-Loop），
Kotlin / Scala 等语言的类型推断（Type Inference）。
也许这种演进方式更能够让用户接受吧。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://docs.python.org/3/library/typing.html">typing — Support for type hints — Python 3.8.3 documentation</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0483/#type-variables">PEP 483 &ndash; The Theory of Type Hints | Python.org</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0484/#abstract">PEP 484 &ndash; Type Hints | Python.org</a></li>
<li><a href="https://www.bernat.tech/the-state-of-type-hints-in-python/">the state of type hints in Python</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>浅谈 Code Review 之事前准备</title>
      <link>https://blog.alswl.com/2020/03/before-code-review/</link>
      <pubDate>Tue, 31 Mar 2020 12:13:00 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2020/03/before-code-review/</guid>
      <description>随着业务规模扩大、团队组成变复杂，如何降低项目实施风险，降低软件复杂度变得尤为关键。 我从 Martin Flower、Joel Spolsky（软件随想录 作者） 等巨匠智慧中寻找解决复杂工程之道，其中 Code Review 是行之有效手段。 我认同 Code Review 价值也是忠实执行者。 加入蚂蚁以后，我在所接触项目中都大力推广 Code Review。 感谢团队信任和支持，目前 CR 协作进展顺利， 项目 CR 从最早不主动，到现在形成基于模块 Owner 制度 CR 和 Peer Review。 我也曾经</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/202003/computer.jpg" alt="image from pixabay"  />


</p>
<p>随着业务规模扩大、团队组成变复杂，如何降低项目实施风险，降低软件复杂度变得尤为关键。
我从 Martin Flower、Joel Spolsky（<a href="https://book.douban.com/subject/4163938/">软件随想录</a> 作者）
等巨匠智慧中寻找解决复杂工程之道，其中 Code Review 是行之有效手段。
我认同 Code Review 价值也是忠实执行者。</p>
<p>加入蚂蚁以后，我在所接触项目中都大力推广 Code Review。
感谢团队信任和支持，目前 CR 协作进展顺利，
项目 CR 从最早不主动，到现在形成基于模块 Owner 制度 CR 和 Peer Review。
我也曾经在 3 个月内处理完成 700 多个 Pull Request，并在 PR 讨论中中都留下一些有价值讨论。
这里我将自己对 Code Review 一些理解记录下来。</p>
<p>这一篇先讲讲进入 Code Review 之前需要做准备工作。</p>
<!-- more -->
<h2 id="评估团队成熟度">评估团队成熟度</h2>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/202003/team.jpg" alt="image from pixabay"  />


</p>
<p>不管是在一个遗留系统上推广 Code Review，还是在一个新团队推广 Code Review，
起手式不是立马挽起袖子猛干，而是应当观察一下当前所处情况是否允许自己推动这个「艰巨」任务。
最需要观察的是团队成熟度。</p>
<p>我将团队成熟度粗略分为草台班子、成长型团队、成熟团队。
具体衡量指标可以有成员技术储备、团队成员信任度、团队负责人对工程管控力度。
相信集团内大部分团队处于成长型、成熟型团队。
但如果考虑到生态同学一起协作，或者临时因为紧急项目凑在一起，就比较容易成为「草台班子」。</p>
<p>如果还停留在草台班子，那就得先在团队内形成一定共识：
包括技术共识和合作模式的共识。
技术共识需要包括：技术栈共识、好代码定义、研发流程共识等。
合作模式共识需要包括：冲突解决机制、职责范围边界、决策机制等。
如果基本共识还没有形成就仓促进入 Code Review，那就容易将一件好事变成工程师战争。</p>
<p>并不是所有团队、项目都适合无差别引入 Code Review。这么几种情况建议暂缓 Code Review 推广：</p>
<ul>
<li>老板和同事都不支持甚至反对</li>
<li>业务重要性低，或者团队都是特立独行高手</li>
<li>创新业务需要快速上线，这时候适合将这类任务分发给配合度高老团队，或者给高手单兵作战</li>
</ul>
<p>当条件不满足时也不用气馁。先成为一个布道师吧，探索一下团队中有没有相似想法的人，了解一下他们担心点和诉求点。
相信只要条件允许，没有人会拒绝提高工程质量。</p>
<h2 id="构建好代码共识">构建「好代码」共识</h2>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/202003/book.jpg" alt="image from pixabay"  />


</p>
<p>Code Review 核心产出物是代码，如何界定代码是好是坏就至关重要。
根据 Bjarne（「C++ Programming Language」作者）、Grady Booch（「面向对象分析与设计」作者）等人定义，
总结下来好代码有这么基本特征（via「Clean Code」）：</p>
<ul>
<li>正确</li>
<li>可测试</li>
<li>不重复</li>
<li>少且简单</li>
<li>可读</li>
</ul>
<p>深思一下这些基本特征背后道理：代码是人类和机器沟通工具，好代码也要利于人类阅读和再次书写。
人比机器更犯错，机器算力在成倍增长，因此简单易维护重要度逐步增高。
这些朴素道理也正是语言从低级语言进化到高级语言驱动力，
也是近几年高级语言语言特性主打点（类型系统、格式系统、面向人类同步思想异步设计）。</p>
<p>但上面这几条原则太底层了，无法成为实践标准。
因此行业基于这些公理衍生了不少实践定理，我将其分为工程规约和设计范式两类。</p>
<p>工程规约包含语言风格规约和应用工程规约。
语言风格规约比较容易理解，开源世界提供了很多选择。硅谷大厂 Google / Facebook / Uber 等都有不少规约提供。
国内还有极具价值的「阿里巴巴 Java 开发手册」，我称之为 50331 ;)
（PS：「阿里巴巴 Java 开发手册」不仅有语言风格规约、也有应用工程规约和一部分设计规约）。
这里罗列了一些常见面向语言的 Style Guide。</p>
<ul>
<li><a href="https://google.github.io/styleguide/">Google Style Guides | styleguide</a>
<ul>
<li>包含 C++ / Object-C / Java / Python / R / Shell / HTML CSS / JavaScript / AngularJS / Common Lisp / Vimscript</li>
</ul>
</li>
<li><a href="https://github.com/alibaba/p3c">alibaba/p3c: Alibaba Java Coding Guidelines pmd implements and IDE plugin</a>
<ul>
<li>Java</li>
</ul>
</li>
<li><a href="https://github.com/airbnb/javascript">airbnb/javascript: JavaScript Style Guide</a>
<ul>
<li>JavaScript</li>
</ul>
</li>
<li><a href="https://github.com/uber-go/guide">uber-go/guide: The Uber Go Style Guide.</a>
<ul>
<li>Go</li>
</ul>
</li>
</ul>
<p>应用工程规约关注点则更为落地：包括依赖管理、配置管理、应用层次结构、对外服务暴露约束，数据建模，文档注释，测试管理，
甚至包含中间件使用规约。
这些规约逐步从「如何表达代码」延展到到「如何管理工程」。
这块发挥空间比较大，中大规模团队会有应用框架组这样团队。
基于应用框架对使用方式方法约束。针对具体业务使用也会给出针对性建议。
这些定理总结出来往往以轻量 Best Practice 和重量级应用框架对外输出。</p>
<p>这里举两个例子说明一下应用工程规约应该讲清楚哪些问题。
第一个例子 <a href="https://github.com/alibaba/COLA">alibaba/COLA</a>
这个项目来说，它约束了整体工程结构，并且明确的通过 Archetype 帮助（约束）用户行为。
第二个例子是 RoR / Django 这类 RoR 框架，他们使用约定大于配置方式，基于 ActiveRecord 这种模式约束了用户如何使用框架，
从 Model、Controller 到 Router，对立面则是 Spring MVC / Flask 这类框架，几乎只提供纯技术特性，不约束开发者行为。</p>
<p>除了阿里 Java 开发手册，这里提供三个应用工程规范供参考：</p>
<ul>
<li><a href="https://github.com/alibaba/COLA">alibaba/COLA: Clean Object-oriented &amp; Layered Architecture</a></li>
<li><a href="https://tech.antfin.com/docs/2/48599">SOFA 项目工程结构 - 蚂蚁金服金融科技</a> 和 <a href="https://tech.antfin.com/docs/2/56003">SOFA 微服务平台概述 - 蚂蚁金服金融科技</a></li>
<li><a href="https://github.com/realpython/python-guide">realpython/python-guide: Python best practices guidebook, written for humans.</a></li>
</ul>
<p>比工程规约更难定义的是设计范式，核心点是解决「如何做架构决策」。
设计范式决策过程在系统架构设计和系分设计阶段就应当完成了。
如果设计范式差异性导致代码在 Code Review 阶段出现意见不一。
要么是这个团队过于草台班子，要么是这个项目架构师/负责人在前期设计做的工作太少了。</p>
<p>当一个团队遵循相近设计范式，意味着他们达到了同一级别技术储
备，并形成了统一自顶向下设计打法。
在 Code Review 过程中，一些范式使用完全可以将 GoF23 / S.O.L.I.D. / DDD 这些术语概念拎出来。
相信 Commiter 和 Reviewer 可以基于业务场景快速达成一致。</p>
<p>方法论贴在墙上是无法解决开发中中遇到设计问题，在代码中真刀真枪干，Show me the fuck code。</p>
<h2 id="code-review-沟通协作机制">Code Review 沟通协作机制</h2>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/202003/teamwork.jpg" alt="image from pixabay"  />


</p>
<p>除了工程规约，还有一件事情往往会被忽略，如何解决冲突？
这个冲突不是指代码 Conflict，而是面对技术方案决策时候交流讨论。</p>
<p>文无第一武无第二，两个秀才在一起能吵到天翻地覆面红耳赤。
技术层面 Augue 容易陷入我说我有理你说你有理局面。这种情况如何解决？
没有一个好协作机制，会倒逼 Commiter 和 Reviewer 退缩，不能充分展开讨论。
这是我们不想看见。</p>
<p>很多时候技术决策就是在 40% 正确性 和 60% 正确性中间选择，看中长期收益和短期收益就可能导致结论不一样。
非黑既白反而不容易有争论。想要促进快速决策，一套冲突解决机制就不可缺少。
因此一定要在事前制定一套冲突解决机制。大部分冲突解决都可以使用这么一套逻辑：数据、逻辑、民主、独裁。
当需要进行某个技术或者产品决策时候，最优先方式是用数据来量化，证明自己观点。
当数据不充分时候，可以进行逻辑归纳推衍形成结论。
当形成逻辑不能服众众说纷纭时候，可以使用民主方式进行裁决。
当民主也无法生效，就需要 Owner / 一号位力排众议，进行独裁决策了。</p>
<p>CodeReview 有这么几种形式，同步离线、异步离线、同步在线。
处于同步形式 CodeReview 需要尽快处理掉 PR，这时候协作机制一定要干净利索，避免大家在 PR 反反复复来来回回讨论。
如果每个 PR 都要消耗数次来回沟通，我建议将 CR 形式升级到同步在线，拉个会议立刻将事情解决。</p>
<p>如果在一个实现方案上真无法决策，如果不涉及原则，那我建议使用搁置争议，使用
<code>TODO @commiter what, how, when</code> 方式先标记意见和处理时间，先行将工程开发往下推进。</p>
<p>一切准备好了，谢天谢地，终于可以进入 Code Review 阶段了。
我们下篇文章再来讲进入 Code Review 阶段的事情。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量</title>
      <link>https://blog.alswl.com/2018/06/sql-server-migration-3/</link>
      <pubDate>Wed, 20 Jun 2018 20:18:52 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2018/06/sql-server-migration-3/</guid>
      <description>该系列三篇文章已经全部完成： 从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D 从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D 我们用了两章文章 从 SQL Server 到 MySQL（一）：异构数据库迁移 / 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 介绍我们遇到问题和解决方案。 不管是离线全量迁移还是在线无缝迁移， 核心 ETL 工具就是 yugong。 Yugong 是一个成熟工具， 在阿里巴巴去</description>
      <content:encoded><![CDATA[<p>该系列三篇文章已经全部完成：</p>
<ul>
<li><a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/06/sql-server-migration-3/">从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D</a></li>
</ul>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/refactor.png" alt="201806/refactor.png"  />


</p>
<p>我们用了两章文章
<a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL（一）：异构数据库迁移</a>
/
<a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机</a>
介绍我们遇到问题和解决方案。
不管是离线全量迁移还是在线无缝迁移，
核心 ETL 工具就是 yugong。</p>
<p>Yugong 是一个成熟工具， 在阿里巴巴去 IOE 行动中起了重要作用，
它与 Otter / Canal 都是阿里中间件团队出品。
它们三者各有分工：
Yugong 设计目标是异构数据库迁移；
Canal 设计用来解决 MySQL binlog 订阅和消费问题；
Otter 则是在 Canal 之上，以准实时标准解决数据库同步问题。
Otter 配备了相对 yugong 更健壮管理工具、分布式协调工具，
从而长期稳定运行。Yugong 设计目标则是一次性迁移工作，偏 Job 类型。
当然 yugong 本身质量不错，长期运行也没问题。
我们有个产线小伙伴使用我们魔改后 yugong，
用来将数据从管理平台同步数据到用户前台，已经稳定跑了半年多了。</p>
<!-- more -->
<h2 id="yugong-系统结构">yugong 系统结构</h2>
<p>这里我不赘述如何使用 yugong，有需求同学直接去
<a href="https://github.com/alibaba/yugong">官方文档</a> 查看使用文档。</p>
<p>我直接进入关键环节：解剖 yugong 核心模块。
Yugong 数据流是标准 ETL 流程，分别有 Extractor / Translator / Applier
这三个大类来实现 ETL 过程:</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/etl.png" alt="ETL &amp;amp; Java Class"  />


</p>
<p>我们依次来看看这三大类具体设计。</p>
<h3 id="extractor">Extractor</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/extractor.png" alt="Extractor Class"  />


</p>
<ul>
<li><code>YuGongLifeCycle</code>：Yugong 组件生命周期声明</li>
<li><code>AbstractYuGongLifeCycle</code>：Yugong 组件生命周期一些实现</li>
<li><code>RecordExtractor</code>：基础 Extractor Interface</li>
<li><code>AbstractRecordExtractor</code>：基础 Extractor 虚拟类，做了一部分实现</li>
<li><code>AbstractOracleRecordExtractor</code>：Oracle Extractor 虚拟类，做了一部分 Oracle 相关实现</li>
<li><code>OracleOnceFullRecordExtractor</code>：Oracle 基于特定 SQL 一次性 Extractor</li>
<li><code>OracleFullRecordExtractor</code>：Oracle 全量 Extractor</li>
<li><code>OracleRecRecordExtractor</code>：Oracle 记录 Extractor，用来创建物化视图</li>
<li><code>OracleMaterializedIncRecordExtractor</code>：基于（已有）物化视图 Oracle 增量 Extrator</li>
<li><code>OracleAllRecordExtractor</code>：Oracle 自动化 Extractor，先 Mark 再 Full，再 Inc</li>
</ul>
<p>Exctractor 从 Source DB 读取数据写入内存，
Yugong 官方提供 Extractor 抽象出 <code>AbstractRecordExtractor</code> 类，
其余类都是围绕 Oracle 实现。
另外 Yugong 设计了 <code>YuGongLifeCycle</code> 类实现了组件生命周期管理。</p>
<h3 id="translator">Translator</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/translator.png" alt="Translator Class"  />


</p>
<ul>
<li><code>DataTranslator</code>：Translator 基类，为 Row 级别数据处理</li>
<li><code>TableTranslator</code>：Translator 基类，为 Table 级别提供处理（官方代码中没有使用）</li>
<li><code>AbstractDataTranslator</code>：Data Translator 虚拟类，做了部分实现</li>
<li><code>EncodeDataTranslator</code>：转换编码格式 Translator</li>
<li><code>OracleIncreamentDataTranslator</code>：为 Oracle 增量数据准备 Translator，会调整一些数据状态</li>
<li><code>BackTableDataTranslator</code>：Demo，允许在 Translator 中做回写数据操作</li>
<li><code>BillOutDataTranslator</code>：Demo，包含一些阿里业务逻辑 Translator</li>
<li><code>MidBillOutDetailDataTranslator</code>：Demo，包含一些阿里业务逻辑 Translator</li>
</ul>
<p>Translator 读取内存中 RowData 然后变换，
大部分 Translator 做一些无状态操作，比如编码转换。
另外还有一小部分 Translator 做了业务逻辑操作，比如做一些数据回写。</p>
<h3 id="applier">Applier</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/applier.png" alt="Applier Class"  />


</p>
<ul>
<li><code>RecordApplier</code>：基础 Applier Interface</li>
<li><code>AbstractRecordApplier</code>：基础 Applier 虚拟类，做了一部分实现</li>
<li><code>CheckRecordRecordApplier</code>：检查数据一致性 Applier，不做数据写入</li>
<li><code>FullRecordRecordApplier</code>：全量数据 Applier，使用 UPSERT 做数据更新</li>
<li><code>IncreamentRecordApplier</code>：增量 Applier，使用 Oracle 物化视图为数据源</li>
<li><code>AllRecordRecordApplier</code>：自动化 Applier，先使用全量数据 Applier，然后使用增量数据 Applier</li>
</ul>
<p>Applier 将经过 Translator 处理过的数据写入 Target DB。
Yugong 提供了一致性检查、全量、增量 Applier。
比较特殊是 <code>AllRecordRecordApplier</code> 提供了全套自动化操作。</p>
<h3 id="others">Others</h3>
<p>除了 ETL 三个要素，yugong 还有一些重要类：控制类和工具类。</p>
<ul>
<li><code>SqlTemplate</code>：提供 CRUD / UPSERT 等操作的基类 SQL 模板</li>
<li><code>OracleSqlTemplate</code>：基于 SqlTemplate 实现的 Oracle SQL 模板</li>
<li><code>RecordDiffer</code>：一致性检查 differ</li>
<li><code>YugongController</code>：应用控制器，控制整个应用数据流向</li>
<li><code>YugongInstance</code>：控制单个迁移任务实例，一张表对应一个 YugongInstance</li>
</ul>
<h2 id="老战士的问题">老战士的问题</h2>
<p>说 yugong 有问题会有些标题党，毕竟它是久经考验老战士了。
但对我们来说，开源版本 yugong 还有一些不足：</p>
<ul>
<li>不支持 SQL Server 读取</li>
<li>不支持 SQL Server 写入（Rollback 需要写入 SQL Server）</li>
<li>不支持 MySQL 读取</li>
</ul>
<p>除了数据库支持，Yugong 在工程上面倒是也有一些改善空间。
我们最后花费了不少时间，做了工程上改进。</p>
<ul>
<li>抛弃默认打包方式（基于 maven-assembly-plugin 生成类似 LFS 结构 tar.gz 文件），
改为使用 fat jar 模式打包，仅生成单文件可执行 jar 包</li>
<li>抛弃 ini 配置文件，使用 YAML 配置文件格式（已有老配置仍然使用 ini 文件，YAML 主要管理表结构变更）</li>
<li>改造 Plugin 模式，将 Java 运行时编译改为反射获取 Java 类</li>
<li>拆分 Unit Test / Integration Test，降低重构成本</li>
<li>重构 Oracle 继承结构，使其开放 SQL Server / MySQL 接口</li>
<li>支持 Canal Redis 格式数据作为 MySQL 在线增量数据源</li>
</ul>
<h2 id="改造之后结构">改造之后结构</h2>
<h3 id="extractor-1">Extractor</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/extractor-new.png" alt="Extractor New Class"  />


</p>
<ul>
<li><code>AbstractSqlServerExtractor</code>：新增抽象 SqlServer Extractor</li>
<li><code>AbstractMysqlExtractor</code>：新增抽象 MySQL Extractor</li>
<li><code>AbstractFullRecordExtractor</code>：新增抽象 Full 模式 Extractor</li>
<li><code>SqlServerCdcExtractor</code>：新增 SQL Server CDC 增量模式 Extractor</li>
<li><code>MysqlCanalExtractor</code>：新增 MySQL Canal 格式增量消费 Extractor</li>
<li><code>MysqlCanalRedisExtractor</code>：新增 MySQL Canal 格式增量消费 Extractor，使用 Redis 做回溯</li>
<li><code>MysqlFullExtractor</code>：新增 MySQL 全量 Extractor</li>
<li><code>SqlServerFullExtractor</code>：新增 SQL Server 全量 Extractor</li>
</ul>
<p>在抽象出三个抽象类之后，整体逻辑更为清晰，如果未来要增加新数据库格式支持，也更为简单。</p>
<h3 id="translator-1">Translator</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/translator-new.png" alt="Translator New Class"  />


</p>
<ul>
<li><code>Sha1ShardingTranslator</code>：根据 Sha1 Sharding Translator</li>
<li><code>ModShardingTranslator</code>：根据 Value Mode Sharding Translator</li>
<li><code>RangeShardingTranslator</code>：根据范围 Sharding Translator</li>
<li><code>UserRouterMapShardingTranslator</code>：特定业务使用， 用户分表 Sharding Translator</li>
<li><code>UserRouterMapMobileShardingTranslator</code>：特定业务使用， 用户分表 Sharding Translator</li>
<li><code>ClassLearningNoteInfoShardingTranslator</code>：特定业务使用自定义 Translator</li>
<li><code>ClassLearningIsActiveReverseShardingTranslator</code>：特定业务使用自定义 Translator</li>
<li><code>ColumnFixDataTranslator</code>：调整表结构 Translator</li>
<li><code>NameStyleDataTranslator</code>：调整表字段名 Translator，支持按风格对整个表自动转换</li>
<li><code>CompositeIndexesDataTranslator</code>：解决复合主键下唯一 PK 确定问题的 Translator</li>
</ul>
<p>新增了一系列 Translator。</p>
<h3 id="applier-1">Applier</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/applier-new.png" alt="Applier New Class"  />


</p>
<ul>
<li><code>SqlServerIncreamentRecordApplier</code>：新增 SQL Server 增量消费 Applier</li>
</ul>
<p>Applier 结构调整挺小，主要是增加了 SQL Server 的支持。</p>
<h2 id="二次开发心得">二次开发心得</h2>
<p>如何快速了解一个开源项目？很多同学第一反应就是阅读源码。
看源码固然是有效果，但是性价比太低。
如果项目设计不合理，很快会迷失在代码细节之中。
我的经验是先阅读官方出品的一些 Slide 分享，然后阅读官方核心文档。
Slide 含金量高，在讲述核心中核心。</p>
<p>如果真要去了解细节去阅读源码，那我建议要善用工具，
比如使用 IntelliJ 的 Diagram 功能，抽象出核心类。
还有一些插件比如 SequencePluginReload 方便地生成函数之间调用，实为查看数据流利器。
我在这次开发过程中，也根据生成类图发现了一些问题，
从而在进入 Coding 之前，先对框架继承结构重构。提高了整体开发效率</p>
<p>根据代码风格判断，Yugong 并非是出自一个人之手。这多少会导致代码风格和设计上面不一致。
我自己也常年在业务线里面摸爬滚打，能想象到在快速推进项目中需要糙快猛。
但后人接受开发，多少会有些头疼。
于是我在进入开发之前，引入标准化 CheckStyle，用 Google Style 全局格式化，
使用 Sonar 扫描保证一个代码质量基线。
同时这也是一把双刃剑，格式化项目会导致大量 diff，
这也给我自己埋下了一个苦果，在后期给上游提交 PR 引入无尽问题。</p>
<p>开发过程中我也犯了一些错误。最为头疼是没有在早期考虑到向开源社区贡献，
导致未来向上游合并困难重重，现在还在头疼合并代码中。
另外，由于整体项目时间紧，我贪图实现速度，没有做更详尽单元测试覆盖。
这里没有遵循开源软件的最佳实践。</p>
<p>经过我改造的 Yugong 版本开源地址是：https://github.com/alswl/yugong 。
我也提交了 Pull Request <a href="https://github.com/alibaba/yugong/pull/66">https://github.com/alibaba/yugong/pull/66</a> ，
正在与官方沟通如何将这部分提交并入上游。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机</title>
      <link>https://blog.alswl.com/2018/05/sql-server-migration-2/</link>
      <pubDate>Mon, 21 May 2018 11:24:36 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2018/05/sql-server-migration-2/</guid>
      <description>该系列三篇文章已经全部完成： 从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D 从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D （image via https://pixabay.com/en/military-stealth-bomber-refueling-602729/ ） 在上篇文章 从 SQL Server 到 MySQL （一）：异构数据库迁移 - Log4D 中，我们给大家介绍了从 SQL Server 到 MySQL 异构数据库迁移的基本问题和全量解决方案。 全量方案可以满足一部分场景的需求，但是这个方案仍然是有缺陷的： 迁移过程中需要停机，停机的时长和</description>
      <content:encoded><![CDATA[<p>该系列三篇文章已经全部完成：</p>
<ul>
<li><a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/06/sql-server-migration-3/">从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D</a></li>
</ul>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/flying-tanker.png" alt="flying-tanker"  />


</p>
<p><smaill>（image via <a href="https://pixabay.com/en/military-stealth-bomber-refueling-602729/">https://pixabay.com/en/military-stealth-bomber-refueling-602729/</a> ）</small></p>
<p>在上篇文章
<a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL （一）：异构数据库迁移 - Log4D</a>
中，我们给大家介绍了从 SQL Server 到 MySQL 异构数据库迁移的基本问题和全量解决方案。
全量方案可以满足一部分场景的需求，但是这个方案仍然是有缺陷的：
迁移过程中需要停机，停机的时长和数据量相关。
对于核心业务来说，停机就意味着损失。
比如用户中心的服务，以它的数据量来使用全量方案，会导致迁移过程中停机若干个小时。
而一旦用户中心停止服务，几乎所有依赖于这个中央服务的系统都会停摆。</p>
<p>能不能做到无缝的在线迁移呢？系统不需要或者只需要极短暂的停机？
作为有追求的技术人，我们一定要想办法解决上面的问题。</p>
<!-- more -->
<h2 id="在线迁移的原理和流程">在线迁移的原理和流程</h2>
<p>针对 Oracle 到 MySQL，市面上已经有比较成熟的解决方案 - alibaba 的
<a href="https://github.com/alibaba/yugong">yugong</a>
项目。
在解决 SQL Server 到 MySQL 在线迁移之前，我们先研究一下 yugong 是如何做到 Oracle
的在线迁移。</p>
<p>下图是 yugong 针对 Oracle 到 MySQL 的增量迁移流程：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/yugong-oracle.png" alt="yugong-oracle.png"  />


</p>
<p>这其中有四个步骤：</p>
<ol>
<li>增量数据收集 (创建 Oracle 表的增量物化视图)</li>
<li>进行全量复制</li>
<li>进行增量复制 (可并行进行数据校验)</li>
<li>原库停写，切到新库</li>
</ol>
<p>Oracle 物化视图（Materialized View）是 Oracle 提供的一个机制。
一个物化视图就是主库在某一个时间点上的复制，可以理解为是这个时间点上的 Snapshot。
当主库的数据持续更新时，物化视图的更新可以通过独立的批量更新完成，称之为 <code>refreshes</code>。
一批 <code>refreshes</code> 之间的变化，就对应到数据库的内容变化情况。
物化视图经常用来将主库的数据复制到从库，也常常在数据仓库用来缓存复杂查询。</p>
<p>物化视图有多种配置方式，这里比较关心刷新方式和刷新时间。
刷新方式有三种：</p>
<ul>
<li>Complete Refresh：删除所有数据记录重新生成物化视图</li>
<li>Fast Refresh：增量刷新</li>
<li>Force Refresh：根据条件判断使用 Complete Refresh 和 Fast Refres</li>
</ul>
<p>刷新机制有两种模式： Refresh-on-commit 和 Refresh-On-Demand。</p>
<p>Oracle 基于物化视图，就可以完成增量数据的获取，从而满足阿里的数据在线迁移。
将这个技术问题泛化一下，想做到在线增量迁移需要有哪些特性？
我们得到如下结论（针对源数据库）：</p>
<ul>
<li>增量变化：支持增量获得增量数据库变化</li>
<li>延迟：获取变化数据这个动作耗时需要尽可能低</li>
<li>幂等一致性：变化数据的消费应当做到幂等，即不管目标数据库已有数据什么状态，都可以无差别消费</li>
</ul>
<p>回到我们面临的问题上来，SQL Server 是否有这个机制满足这三个特性呢？
答案是肯定的，SQL Server 官方提供了 CDC 功能。</p>
<h2 id="cdc-的工作原理">CDC 的工作原理</h2>
<p>什么是 CDC？
CDC 全称 Change Data Capture，设计目的就是用来解决增量数据的。
它是 SQL Server 2008 新增的特性，
在这之前只能使用 SQl Server 2005 中的 <code>after insert</code> / <code>after delete</code>
/ <code>after update</code> Trigger 功能来获得数据变化。</p>
<p>CDC 的工作原理如下：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/cdc-data-flow.png" alt="cdc-data-flow.png"  />


</p>
<p>当数据库表发生变化时候，Capture process 会从 transaction log 里面获取数据变化，
然后将这些数据记录到 Change Table 里面。
有了这些数据，用户可以通过特定的 CDC 查询函数将这些变化数据查出来。</p>
<h2 id="cdc-的数据结构和基本使用">CDC 的数据结构和基本使用</h2>
<p>CDC 的核心数据就是那些 Change Table 了，这里我们给大家看一下
Change Table 长什么样，可以有个直观的认识。</p>
<p>通过以下的函数打开一张表（fruits）的 CDC 功能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- enable cdc for db
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sys</span><span class="p">.</span><span class="n">sp_cdc_enable_db</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- enable by table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">EXEC</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">sp_cdc_enable_table</span><span class="w"> </span><span class="o">@</span><span class="n">source_schema</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="s1">&#39;dbo&#39;</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">source_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="s1">&#39;fruits&#39;</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">role_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">NULL</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- list cdc enabled table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">is_cdc_enabled</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">databases</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">is_cdc_enabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>至此 CDC 功能已经开启，如果需要查看哪些表开启了 CDC 功能，可以使用一下 SQL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- list cdc enabled table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">is_cdc_enabled</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">databases</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">is_cdc_enabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>开启 CDC 会导致产生一张 Change Table 表 <code>cdc.dbo_fruits_CT</code>，这张表的表结构如何呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="p">.</span><span class="k">schema</span><span class="w"> </span><span class="n">cdc</span><span class="p">.</span><span class="n">dbo_fruits_CT</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">name</span><span class="w">            </span><span class="k">default</span><span class="w">  </span><span class="k">nullable</span><span class="w">  </span><span class="k">type</span><span class="w">          </span><span class="k">length</span><span class="w">  </span><span class="n">indexed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">--------------  -------  --------  ------------  ------  -------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__$end_lsn</span><span class="w">      </span><span class="k">null</span><span class="w">     </span><span class="n">YES</span><span class="w">       </span><span class="nb">binary</span><span class="w">        </span><span class="mi">10</span><span class="w">      </span><span class="k">NO</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">__$operation</span><span class="w">    </span><span class="k">null</span><span class="w">     </span><span class="k">NO</span><span class="w">        </span><span class="nb">int</span><span class="w">           </span><span class="mi">4</span><span class="w">       </span><span class="k">NO</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">__$seqval</span><span class="w">       </span><span class="k">null</span><span class="w">     </span><span class="k">NO</span><span class="w">        </span><span class="nb">binary</span><span class="w">        </span><span class="mi">10</span><span class="w">      </span><span class="k">NO</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">__$start_lsn</span><span class="w">    </span><span class="k">null</span><span class="w">     </span><span class="k">NO</span><span class="w">        </span><span class="nb">binary</span><span class="w">        </span><span class="mi">10</span><span class="w">      </span><span class="n">YES</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">__$update_mask</span><span class="w">  </span><span class="k">null</span><span class="w">     </span><span class="n">YES</span><span class="w">       </span><span class="n">varbinary</span><span class="w">     </span><span class="mi">128</span><span class="w">     </span><span class="k">NO</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">id</span><span class="w">              </span><span class="k">null</span><span class="w">     </span><span class="n">YES</span><span class="w">       </span><span class="nb">int</span><span class="w">           </span><span class="mi">4</span><span class="w">       </span><span class="k">NO</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">name</span><span class="w">            </span><span class="k">null</span><span class="w">     </span><span class="n">YES</span><span class="w">       </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span><span class="w">  </span><span class="mi">255</span><span class="w">     </span><span class="k">NO</span><span class="w">
</span></span></span></code></pre></div><p>这张表中以 <code>__</code> 开头的字段是 CDC 所记录的元数据，<code>id</code> 和 <code>name</code> 是 fruits 表的原始字段。
这意味着 CDC 的表结构和原始表结构是一一对应的。</p>
<p>接下来我们做一些业务操作，让数据库的数据发生一些变化，然后查看 CDC 的 Change Table：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 1 step
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DECLARE</span><span class="w"> </span><span class="o">@</span><span class="n">begin_time</span><span class="w"> </span><span class="n">datetime</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">end_time</span><span class="w"> </span><span class="n">datetime</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">begin_lsn</span><span class="w"> </span><span class="nb">binary</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="o">@</span><span class="n">end_lsn</span><span class="w"> </span><span class="nb">binary</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 2 step
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SET</span><span class="w"> </span><span class="o">@</span><span class="n">begin_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2017-09-11 14:03:00.000&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="o">@</span><span class="n">end_time</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2017-09-11 14:10:00.000&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 3 step
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">@</span><span class="n">begin_lsn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">fn_cdc_map_time_to_lsn</span><span class="p">(</span><span class="s1">&#39;smallest greater than&#39;</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">begin_time</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">@</span><span class="n">end_lsn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">fn_cdc_map_time_to_lsn</span><span class="p">(</span><span class="s1">&#39;largest less than or equal&#39;</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">end_time</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 4 step
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cdc</span><span class="p">.</span><span class="n">fn_cdc_get_all_changes_dbo_fruits</span><span class="p">(</span><span class="o">@</span><span class="n">begin_lsn</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">end_lsn</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;all&#39;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>这里的操作含义是：</p>
<ol>
<li>定义存储过程中需要使用的 4 个变量</li>
<li>begin_time / end_time 是 Human Readable 的字符串格式时间</li>
<li>begin_lsn / end_lsn 是通过 CDC 函数转化过的 Log Sequence Number，代表数据库变更的唯一操作 ID</li>
<li>根据 begin_lsn / end_lsn 查询到 CDC 变化数据</li>
</ol>
<p>查询出来的数据如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="n">__$start_lsn</span><span class="w">          </span><span class="n">__$end_lsn</span><span class="w">  </span><span class="n">__$seqval</span><span class="w">             </span><span class="n">__$operation</span><span class="w">  </span><span class="n">__$update_mask</span><span class="w">  </span><span class="n">id</span><span class="w">  </span><span class="n">name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">--------------------  ----------  --------------------  ------------  --------------  --  ------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">0000</span><span class="n">dede0000019f001a</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede0000019f0018</span><span class="w">  </span><span class="mi">2</span><span class="w">             </span><span class="mi">03</span><span class="w">              </span><span class="mi">1</span><span class="w">   </span><span class="n">apple</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">0000</span><span class="n">dede000001ad0004</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede000001ad0003</span><span class="w">  </span><span class="mi">2</span><span class="w">             </span><span class="mi">03</span><span class="w">              </span><span class="mi">2</span><span class="w">   </span><span class="n">apple2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">0000</span><span class="n">dede000001ba0003</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede000001ba0002</span><span class="w">  </span><span class="mi">3</span><span class="w">             </span><span class="mi">02</span><span class="w">              </span><span class="mi">2</span><span class="w">   </span><span class="n">apple2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">0000</span><span class="n">dede000001ba0003</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede000001ba0002</span><span class="w">  </span><span class="mi">4</span><span class="w">             </span><span class="mi">02</span><span class="w">              </span><span class="mi">2</span><span class="w">   </span><span class="n">apple3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">0000</span><span class="n">dede000001c10003</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede000001c10002</span><span class="w">  </span><span class="mi">2</span><span class="w">             </span><span class="mi">03</span><span class="w">              </span><span class="mi">3</span><span class="w">   </span><span class="n">apple4</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">0000</span><span class="n">dede000001cc0005</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede000001cc0002</span><span class="w">  </span><span class="mi">1</span><span class="w">             </span><span class="mi">03</span><span class="w">              </span><span class="mi">3</span><span class="w">   </span><span class="n">apple4</span><span class="w">
</span></span></span></code></pre></div><p>可以看到 Change Table 已经如实的记录了我们操作内容，注意 <code>__$operation</code>
代表了数据库操作：</p>
<ul>
<li>1  =&gt; 删除</li>
<li>2  =&gt; 插入</li>
<li>3  =&gt; 更新前数据</li>
<li>4  =&gt; 更新后数据</li>
</ul>
<p>根据查出来的数据，我们可以重现这段时间数据库的操作：</p>
<ul>
<li>新增了 <code>id</code> 为 1 / 2 的两条数据</li>
<li>更新了 <code>id</code> 为 2 的数据</li>
<li>插入了 <code>id</code> 为 3 的数据</li>
<li>删除了 <code>id</code> 为 3 的数据</li>
</ul>
<h2 id="cdc-调优">CDC 调优</h2>
<p>有了 CDC 这个利器，终于意味着我们的方向是没有问题的，我们终于稍稍吁了一口气。
但除了了解原理和使用方式，我们还需要深入了解 CDC 的工作机制，对其进行压测、调优，
了解其极限和边界，否则一旦线上出现不可控的情况，就会对业务带来巨大损失。</p>
<p>我们先看看 CDC 的工作流程，就可以知道有哪些核心参数可以调整：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/cdc-influence.png" alt="Influence of capture job parameters"  />


</p>
<p>上图是 CDC Job 的工作流程：</p>
<ul>
<li>蓝色区域是一次 Log 扫描执行的最大扫描次数：maxscans number（<code>maxscans</code>）</li>
<li>蓝色区域同时被最大扫描 transcation 数量控制：<code>maxtrans</code></li>
<li>浅蓝色区域是扫描间隔时间，单位是秒：<code>pollinginterval</code></li>
</ul>
<p>这三个参数平衡着 CDC 的服务器资源消耗、吞吐量和延迟，
根据具体场景，比如大字段，宽表，BLOB 表，可以调整从而达到满足业务需要。
他们的默认值如下：</p>
<ul>
<li><code>maxscan</code> 默认值 10</li>
<li><code>maxtrans</code> 默认值 500</li>
<li><code>pollinginterval</code> 默认值 5 秒</li>
</ul>
<h2 id="cdc-压测">CDC 压测</h2>
<p>掌握了能够调整的核心参数，我们即将对 CDC 进行了多种形式的测试。
在压测之前，我们还需要确定关键的健康指标，这些指标有：</p>
<ul>
<li>内存：buffer-cache-hit / page-life-expectancy / page-split 等</li>
<li>吞吐：batch-requets / sql-compilations / sql-re-compilations / transactions count</li>
<li>资源消耗：user-connections / processes-blocked / lock-waits / checkpoint-pages</li>
<li>操作系统层面：CPU 利用率、磁盘 IO</li>
</ul>
<p>出于篇幅考虑，我们无法将所有测试结果贴出来，
这里放一个在并发 30 下面插入一百万数据（随机数据）进行展示：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/cdc-metrics.png" alt="cdc-metrics.png"  />


</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/cdc-system-load.png" alt="cdc-system-load.png"  />


</p>
<p>测试结论是，在默认的 CDC 参数下面：</p>
<p>CDC 的开启/关闭过程中会导致若干个 Process Block，
大流量请求下面（15k TPS）过程会导致约 20 个左右 Process Block。
这个过程中对服务器的 IO / CPU 无明显波动，
开启/关闭瞬间会带来 mssql.sql-statistics.sql-compilations 剧烈波动。
CDC 开启后，在大流量请求下面对 QPS / Page IO 无明显波动，
对服务器的 IO / CPU 也无明显波动， CDC 开启后可以在 16k TPS 下正常工作。</p>
<p>如果对性能不达标，官方有一些简单的优化指南：</p>
<ul>
<li>调整 maxscan maxtrans pollinginterval</li>
<li>减少在插入后立刻插入</li>
<li>避免大批量写操作</li>
<li>限制需要记录的字段</li>
<li>尽可能关闭 net changes</li>
<li>没任务压力时跑 cleanup</li>
<li>监控 log file 大小和 IO 压力，确保不会写爆磁盘</li>
<li>要设置 filegroup_name</li>
<li>开启 sp_cdc_enable_table 之前设置 filegroup</li>
</ul>
<h2 id="yugong-的在线迁移机制">yugong 的在线迁移机制</h2>
<p>OK，截目前位置，我们已经具备了 CDC 这个工具，但是这仅仅提供了一种可能性，
我们还需要一个工具将 CDC 的数据消费出来，并喂到 MySQL 里面去。</p>
<p>好在有 yugong。
Yugong 官方提供了 Oracle 到 MySQL 的封装，并且抽象了 Source / Target /
SQL Tempalte 等接口，
我们只要实现相关接口，就可以完成从 SQL Server 消费数据到 MySQL 了。</p>
<p>这里我们不展开，我还会花专门的一篇文章讲如何在 yugong 上面进行开发。
可以提前剧透一下，我们已经将支持 SQL Server 的 yugong 版本开源了。</p>
<h2 id="如何回滚">如何回滚</h2>
<p>数据库迁移这样的项目，我们不仅仅要保证单向从 SQL Server 到 MySQL 的写入，
同时要从 MySQL 写入 SQL Server。</p>
<p>这个流程同样考虑增量写入的要素：增量消费，延迟，幂等一致性。</p>
<p>MySQL 的 binlog 可以满足这三个要素，需要注意的是，MySQL binlog 有三种模式，
Statement based，Row based 和 Mixed。只有 Row based 才能满足幂等一致性的要求。</p>
<p>确认理论上可行之后，我们一样需要一个工具将 binlog 读取出来，并且将其转化为
SQL Server 可以消费的数据格式，然后写入 SQL Server。</p>
<p>我们目光转到 alibaba 的另外一个项目 Canal。
Canal 是阿里中间件团队提供的 binlog 增量订阅 &amp; 消费组件。
之所以叫组件，是由于 Canal 提供了 Canal-Server 应用和 Canal Client Library，
Canal 会模拟成一个 MySQL 实例，作为 Slave 连接到 Master 上面，
然后实时将 binlog 读取出来。
至于 binlog 读出之后想怎么使用，权看用户如何使用。</p>
<p>我们基于 Canal 设计了一个简单的数据流，在 yugong 中增加了这么几个功能：</p>
<ul>
<li>SQL Server 的写入功能</li>
<li>消费 Canal 数据源的功能</li>
</ul>
<p>Canal Server 中的 binlog 只能做一次性消费，
内部实现是一个 Queue，
为了满足我们可以重复消费数据的能力，我们还额外设计了一个环节，将 Canal
的数据放到 Queue 中，在未来任意时间可以重复消费数据。
我们选择了 Redis 作为这个 Queue，数据流如下。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/canal.png" alt="canal.png"  />


</p>
<h2 id="最佳实践">最佳实践</h2>
<p>数据库的迁移在去 Windows 中，是最不容得出错的环节。
应用是无状态的，出现问题可以通过回切较快地回滚。
但数据库的迁移就需要考虑周到，做好资源准备，发布流程，
故障预案处理。</p>
<p>考虑到多个事业部都需要经历这个一个过程，我们项目组将每一个步骤都固化下来，
形成了一个最佳实践。我们的迁移步骤如下，供大家参考：</p>
<table>
<thead>
<tr>
<th>大阶段</th>
<th>阶段</th>
<th>事项</th>
<th>是否完成</th>
<th>负责人</th>
<th>耗时</th>
<th>开始时间</th>
<th>完成时间</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>白天</td>
<td>存量数据阶段</td>
<td>创建 MySQL 数据库，准备相关账号资源</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>开启 CDC</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>从 Slave SQLServer dump 一份 snapshot 到 Backup SQL Server</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>Backup SQL Server 消费数据， ETL 到 MySQL</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td>增量数据阶段</td>
<td>确认 ETL 数据已经消费完成，检查数据总条数</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>从 Slave SQLServer 开始消费 CDC 数据，持续写入 MySQL</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>使用 yugong 检查一天内数据的一致性</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>检查不一致的数据，10 分钟之后人工进行检查，确认是 CDC 延迟带来的问题</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>检查数据总量条目</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>使用 yugong 对抽样表进行全量检查</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>凌晨</td>
<td>应用发布阶段</td>
<td>停止 SQL Server 的应用</td>
<td> </td>
<td>技术经理</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>检查没有连接进入 SQL Server</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>使用 yugong 检查一天内数据的一致性</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>检查数据总量条目</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>启用基于 MySQL 的应用</td>
<td> </td>
<td>运维</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td>测试阶段</td>
<td>测试应用是否正常，回归所有功能</td>
<td> </td>
<td>QA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>（临时新增）测试 ReadOnly DB 的应用访问情况</td>
<td> </td>
<td>QA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td>完成阶段</td>
<td>接入流量</td>
<td> </td>
<td>运维</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td>（可选）回滚阶段</td>
<td>发现问题，直接将应用切回 SQL Server</td>
<td> </td>
<td>运维</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>事后进行数据审计，进行新增数据补偿</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td> </td>
<td> </td>
<td>（可选）回滚过程中，使用 Canal 读取 binlog，并使用 Canal Client 重放到 SQL Server</td>
<td> </td>
<td>DBA</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://docs.oracle.com/cd/B10500_01/server.920/a96567/repmview.htm">Materialized View Concepts and Architecture</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008/dd266396(v=sql.100)">Tuning the Performance of Change Data Capture in SQL Server 2008 | Microsoft Docs</a></li>
<li><a href="https://github.com/alibaba/yugong">alibaba/yugong: 阿里巴巴去Oracle数据迁移同步工具(全量+增量,目标支持MySQL/DRDS)</a></li>
<li><a href="https://github.com/alibaba/canal">alibaba/canal: 阿里巴巴mysql数据库binlog的增量订阅&amp;消费组件 。阿里云DRDS( https://www.aliyun.com/product/drds )、阿里巴巴TDDL 二级索引、小表复制powerd by canal.</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>从 SQL Server 到 MySQL（一）：异构数据库迁移</title>
      <link>https://blog.alswl.com/2018/03/sql-server-migration-1/</link>
      <pubDate>Mon, 12 Mar 2018 21:08:56 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2018/03/sql-server-migration-1/</guid>
      <description>该系列三篇文章已经全部完成： 从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D 从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D 背景 沪江成立于 2001 年，作为较早期的教育学习网站， 当时技术选型范围并不大： Java 的版本是 1.2，C# 尚未诞生，MySQL 还没有被 Sun 收购， 版本号是 3.23。 工程师们选择了当时最合适的微软体系，并在日后的岁月里， 逐步从 ASP 过度到 .net，数据</description>
      <content:encoded><![CDATA[<p>该系列三篇文章已经全部完成：</p>
<ul>
<li><a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/06/sql-server-migration-3/">从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D</a></li>
</ul>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201803/migration-bird.png" alt="201803/migration-bird.png"  />


</p>
<h2 id="背景">背景</h2>
<p>沪江成立于 2001 年，作为较早期的教育学习网站，
当时技术选型范围并不大：
Java 的版本是 1.2，C# 尚未诞生，MySQL 还没有被 Sun 收购，
版本号是 3.23。
工程师们选择了当时最合适的微软体系，并在日后的岁月里，
逐步从 ASP 过度到 .net，数据库也跟随 SQL Server 进行版本升级。</p>
<p>十几年过去了，技术社区已经发生了天翻地覆的变化。
沪江的技术栈还基本在 .net 体系上，这给业务持续发展带来了一些限制。
人才招聘、社区生态、架构优化、成本风险方面都面临挑战。
集团经过慎重考虑，发起了大规模的去 Windows 化项目。
这其中包含两个重点子项目：开发语言从 C# 迁移到 Java，
数据库从 SQL Server 迁移到 MySQL。</p>
<p>本系列文章就是向大家介绍，
从 SQL Server 迁移到 MySQL 所面临的问题和我们的解决方案。</p>
<!-- more -->
<h2 id="迁移方案的基本流程">迁移方案的基本流程</h2>
<p>设计迁移方案需要考量以下几个指标：</p>
<ul>
<li>迁移前后的数据一致性</li>
<li>业务停机时间</li>
<li>迁移项目是否对业务代码有侵入</li>
<li>需要提供额外的功能：表结构重构、字段调整</li>
</ul>
<p>经过仔细调研，在平衡复杂性和业务方需求后，
迁移方案设计为两种：停机数据迁移和在线数据迁移。
如果业务场景允许数小时的停机，那么使用停机迁移方案，
复杂度低，数据损失风险低。
如果业务场景不允许长时间停机，或者迁移数据量过大，
无法在几个小时内迁移完成，那么就需要使用在线迁移方案了。</p>
<p>数据库停机迁移的流程：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201803/migration-db-offline-readonly.png" alt="201803/migration-db-offline-readonly.png"  />


</p>
<p>停机迁移逻辑比较简单，使用 ETL（Extract Translate Load）
工具从 Source 写入 Target，然后进行一致性校验，最后确认应用运行 OK，
将 Source 表名改掉进行备份。</p>
<p>在线迁移的流程：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201803/migration-db-online.png" alt="201803/migration-db-online.png"  />


</p>
<p>在线迁移的方案稍微复杂一些，流程上有准备全量数据，然后实时同步增量数据，
在数据同步跟上（延迟秒级别）之后，进行短暂停机（Hang 住，确保没有流量），
就可以使用新的应用配置，并使用新的数据库。</p>
<h2 id="需要解决的问题">需要解决的问题</h2>
<p>从 SQL Server 迁移到 MySQL，核心是完成异构数据库的迁移。</p>
<p>基于两种数据迁移方案，我们需要解决以下问题：</p>
<ul>
<li>两个数据库的数据结构是否可以一一对应？出现不一致如何处理？</li>
<li>MySQL 的使用方式和 SQL Server 使用方式是否一致？有哪些地方需要注意？</li>
<li>如何确保迁移前后的数据一致性？</li>
<li>在迁移中，如何支持数据结构调整？</li>
<li>如何保证业务不停情况下面，实现在线迁移？</li>
<li>数据迁移后如果发现业务异常需要回滚，如何处理新产生的数据？</li>
</ul>
<p>为了解决以上的问题，我们需要引入一整套解决方案，包含以下部分：</p>
<ul>
<li>指导文档 A：SQL Server 转换 MySQL 的数据类型对应表</li>
<li>指导文档 B：MySQL 的使用方式以及注意点</li>
<li>支持表结构变更，从 SQL Server 到 MySQL 的 ETL 工具</li>
<li>支持 SQL Server 到 MySQL 的在线 ETL 工具</li>
<li>一致性校验工具</li>
<li>一个回滚工具</li>
</ul>
<p>让我们一一来解决这些问题。</p>
<h2 id="sql-server-到-mysql-指导文档">SQL Server 到 MySQL 指导文档</h2>
<p>非常幸运的是，MySQL 官方早就准备了一份如何其他数据库迁移到
MySQL 的白皮书。
<a href="https://www.mysql.com/it/why-mysql/white-papers/guide-to-migrating-from-sql-server-to-mysql/">MySQL :: Guide to Migrating from Microsoft SQL Server to MySQL</a>
里提供了详尽的 SQL Server 到 MySQL 的对应方案。
包含了：</p>
<ul>
<li>SQL Server to MySQL - Datatypes 数据类型对应表</li>
<li>SQL Server to MySQL - Predicates 逻辑算子对应表</li>
<li>SQL Server to MySQL – Operators and Date Functions 函数对应表</li>
<li>T-SQL Conversion Suggestions 存储过程转换建议</li>
</ul>
<p>需要额外处理的数据类型：</p>
<table>
<thead>
<tr>
<th>SQL Server</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDENTITY</td>
<td>AUTO_INCREMENT</td>
</tr>
<tr>
<td>NTEXT, NATIONAL TEXT</td>
<td>TEXT CHARACTER SET UTF8</td>
</tr>
<tr>
<td>SMALLDATETIME</td>
<td>DATETIME</td>
</tr>
<tr>
<td>MONEY</td>
<td>DECIMAL(19,4)</td>
</tr>
<tr>
<td>SMALL MONEY</td>
<td>DECIMAL(10,4)</td>
</tr>
<tr>
<td>UNIQUEIDENTIFIER</td>
<td>BINARY(16)</td>
</tr>
<tr>
<td>SYSNAME</td>
<td>CHAR(256)</td>
</tr>
</tbody>
</table>
<p>在实际进行中，还额外遇到了一个用来解决树形结构存储的字段类型
Hierarchyid。这个场景需要额外进行业务调整。</p>
<p>我们在内部做了针对 MySQL 知识的摸底排查工作，
并进行了若干次的 MySQL 使用技巧培训，
将工程师对 MySQL 的认知拉到一根统一的线。</p>
<p>关于存储过程使用，我们和业务方也达成了一致：所有 SQL Server
存储过程使用业务代码进行重构，不能在 MySQL 中使用存储过程。
原因是存储过程增加了业务和 DB 的耦合，会让维护成本变得极高。
另外 MySQL 的存储过程功能和性能都较弱，无法大规模使用。</p>
<p>最后我们提供了一个 MySQL 开发规范文档，借数据库迁移的机会，
将之前相对混乱的表结构设计做了统一了约束（部分有业务绑定的设计，
在考虑成本之后没有做调整）。</p>
<h2 id="etl-工具">ETL 工具</h2>
<p>ETL 的全称是 Extract Translate Load（读取、转换、载入），
数据库迁移最核心过程就是 ETL 过程。
如果将 ETL 过程简化，去掉 Translate 过程，
就退化为一个简单的数据导入导出工具。
我们可以先看一下市面上常见的导入导出工具，
了解他们的原理和特性，方便我们选型。</p>
<p>MySQL 同构数据库数据迁移工具：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html">mysqldump</a>
和 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlimport.html">mysqlimport</a>
MySQL 官方提供的 SQL 导出导出工具</li>
<li><a href="https://www.percona.com/doc/percona-toolkit/LATEST/pt-table-sync.html">pt-table-sync</a>
Percona 提供的主从同步工具</li>
<li><a href="https://www.percona.com/software/mysql-database/percona-xtrabackup">XtraBackup</a>
Percona 提供的备份工具</li>
</ul>
<p>异构数据库迁移工具：</p>
<ul>
<li><a href="https://www.convert-in.com/">Database migration and synchronization tools</a>
：国外一家提供数据库迁移解决方案的公司</li>
<li><a href="https://github.com/alibaba/DataX">DataX</a>
：阿里巴巴开发的数据库同步工具</li>
<li><a href="https://github.com/alibaba/yugong">yugong</a>
：阿里巴巴开发的数据库迁移工具</li>
<li><a href="https://www.mysql.com/cn/products/workbench/">MySQL Workbench</a>
：MySQL 提供的 GUI 管理工具，包含数据库迁移功能</li>
<li><a href="https://community.hds.com/docs/DOC-1009855">Data Integration - Kettle</a>
：国外的一款 GUI ETL 工具</li>
<li><a href="https://www.ispirer.cn/products/sql-server-to-mysql-migration">Ispirer</a>
：提供应用程序、数据库异构迁移方案的公司</li>
<li><a href="http://www.szmesoft.com/DB2DB">DB2DB 数据库转换工具</a>
：一个国产的商业数据库迁移软件</li>
<li><a href="https://www.navicat.com/en/products/navicat-premium">Navicat Premium</a>
：经典的数据库管理工具，带数据迁移功能</li>
<li><a href="http://www.cnblogs.com/cyq1162/p/5637978.html">DBImport</a>
：个人维护的迁移工具，非常简陋，需要付费</li>
</ul>
<p>看上去异构数据库迁移工具和方案很多，但是经过我们调研，其中不少是为老派的传统行业服务的。
比如 Kettle / Ispirerer，他们关注的特性，不能满足互联网公司对性能、迁移耗时的要求。
简单筛选后，以下几个工具进入我们候选列表（为了做特性对比，加入几个同构数据库迁移工具）：</p>
<table>
<thead>
<tr>
<th>工具名称</th>
<th>热数据备份保证一致性</th>
<th>batch 操作</th>
<th>支持异构数据库</th>
<th>断点续接</th>
<th>开源</th>
<th>开发语言</th>
<th>GUI</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysqldump</td>
<td>V 使用 <code>single-transaction</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>V</td>
<td>C</td>
<td>X</td>
</tr>
<tr>
<td>pt-table-sync</td>
<td>V 使用 transaction 或 <code>lock table</code> 的 FTWRL</td>
<td>V</td>
<td>X</td>
<td>V</td>
<td>V</td>
<td>Pell</td>
<td>X</td>
</tr>
<tr>
<td>DataX</td>
<td>X</td>
<td>V</td>
<td>V</td>
<td>X</td>
<td>V</td>
<td>Java</td>
<td>X</td>
</tr>
<tr>
<td>yugong</td>
<td>X</td>
<td>V</td>
<td>V</td>
<td>V</td>
<td>V</td>
<td>Java</td>
<td>X</td>
</tr>
<tr>
<td>DB2DB</td>
<td>X</td>
<td>V</td>
<td>V</td>
<td>X</td>
<td>X</td>
<td>.net</td>
<td>V</td>
</tr>
<tr>
<td>MySQL Workbench</td>
<td>X</td>
<td>?</td>
<td>V</td>
<td>X</td>
<td>V</td>
<td>C++</td>
<td>V</td>
</tr>
</tbody>
</table>
<p>由于异构数据库迁移，真正能够进入我们选型的只有
DataX / yugong / DB2DB / MySQL Workbench。
经过综合考虑，我们最终选用了三种方案，
DB2DB 提供小数据量、简单模式的停机模式支持，
足以应付小数据量的停机迁移，开发工程师可以自助完成。
DataX 为大数据量的停机模式提供服务，
使用 JSON 进行配置，通过修改查询 SQL，可以完成一部分结构调整工程。
yugong 的强大可定制性也为在线迁移提供了基础，
我们在官方开源版本的基础之上，增加了以下额外功能：</p>
<ul>
<li>支持 SQL Server 作为 Source 和 Target</li>
<li>支持 MySQL 作为 Source</li>
<li>支持 SQL Server 增量更新</li>
<li>支持使用 YAML 作为配置格式</li>
<li>调整 yugong 为 fat jar 模式运行</li>
<li>支持表名、字段名大小写格式变化，驼峰和下划线自由转换</li>
<li>支持表名、字段名细粒度自定义</li>
<li>支持复合主键迁移</li>
<li>支持迁移过程中完成 Range / Time / Mod / Hash 分表</li>
<li>支持新增、删除字段</li>
</ul>
<p>关于 yugong 的二次开发，我们也积累了一些经验，这个我们下篇文章会来分享。</p>
<h2 id="一致性校验工具">一致性校验工具</h2>
<p>在 ETL 之后，需要有一个流程来确认数据迁移前后是否一致。
虽然理论上不会有差异，但是如果中间有程序异常，
或者数据库在迁移过程中发生操作，数据就会不一致。</p>
<p>业界有没有类似的工具呢？
有，Percona 提供了 pt-table-checksum 这样的工具，
这个工具设计从 master 使用 <code>checksum</code> 来和 slave 进行数据对比。
这个设计场景是为 MySQL 主从同步设计，
显然无法完成从 SQL Server 到 MySQL 的一致性校验。
尽管如此，它的一些技术设计特性也值得参考：</p>
<ul>
<li>一次检查一张表</li>
<li>每次检查表，将表数据拆分为多个 trunk 进行检查</li>
<li>使用 <code>REPLACE...SELECT</code> 查询，避免大表查询的长时间带来的不一致性</li>
<li>每个 trunk 的查询预期时间是 0.5s</li>
<li>动态调整 trunk 大小，使用指数级增长控制大小</li>
<li>查询超时时间 1s / 并发量 25</li>
<li>支持故障后断点恢复</li>
<li>在数据库内部维护 src / diff，meta 信息</li>
<li>通过 Master 提供的信息自动连接上 slave</li>
<li>必须 Schema 结构一致</li>
</ul>
<p>我们选择 yugong 作为 ETL 工具的一大原因也是因为它提供了多种模式。
支持 CHECK / FULL / INC / AUTO 四种模式。
其中 CHECK 模式就是将 yugong 作为数据一致性检查工具使用。
yugong 工作原理是通过 JDBC 根据主键范围变化，将数据取出进行批量对比。</p>
<p>这个模式会遇到一点点小问题，如果数据库表没有主键，将无法进行顺序对比。
其实不同数据库有自己的逻辑主键，Oracle 有 <code>rowid</code>，
SQL Server 有 <code>physloc</code>。这种方案可以解决无主键进行比对的问题。</p>
<h2 id="如何回滚">如何回滚</h2>
<p>我们需要考虑一个场景，在数据库迁移成功之后业务已经运行了几个小时，
但是遇到了一些 Critical 级别的问题，必须回滚到迁移之前状态。
这时候如何保证这段时间内的数据更新到老的数据库里面去？</p>
<p>最朴素的做法是，在业务层面植入 DAO 层的打点，
将 SQL 操作记录下来到老数据库进行重放。
这种方式虽然直观，但是要侵入业务系统，直接被我们否决了。
其实这种方式是 binlog statement based 模式，
理论上我们可以直接从 MySQL 的 binlog 里面获取数据变更记录。
以 row based 方式重放到 SQL Server。</p>
<p>这时候又涉及到逆向 ETL 过程，
因为很可能 Translate 过程中，做了表结构重构。
我们的解决方法是，使用 Canal 对 MySQL binlog 进行解析，
然后将解析之后的数据作为数据源，
将其中的变更重放到 SQL Server。</p>
<p>由于回滚的过程也是 ETL，基于 yugong，
我们继续定制了 SQL Server 的写入功能，
这个模式类似于在线迁移，只不过方向是从 MySQL 到 SQL Server。</p>
<h2 id="其他实践">其他实践</h2>
<p>我们在迁移之前做了大量压测工作，
并针对每个迁移的 DB 进行线上环境一致的全真演练。
我们构建了和生产环境机器配置一样，
数据量一样的测试环境，并要求每个系统在上线之前都进行若干次演练。
演练之前准备详尽的操作手册和事故处理方案。
演练准出的标准是：能够在单次演练中不出任何意外，时间在估计范围内。
通过演练我们保证了整个操作时间可控，减少操作时候的风险。</p>
<p>为了让数据库的状态更为直观的展现出来，
我们对 MySQL / SQL Server 添加了细致的 Metrics 监控。
在测试和迁移过程中，可以便利地看到数据库的响应情况。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201803/sql-server-metrics.png" alt="201803/sql-server-metrics.png"  />


</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201803/mysql-metrics.png" alt="201803/mysql-metrics.png"  />


</p>
<p>为了方便 DBA 快速 Review SQL。
我们提供了一些工具，直接将代码库中的 SQL 拎出来，
可以方便地进行 SQL Review。
再配合其他 SQL Review 工具，
比如 <a href="https://github.com/Meituan-Dianping/SQLAdvisor">Meituan-Dianping/SQLAdvisor</a>，
可以实现一部分自动化，提高 DBA 效率，避免线上出现明显的 Slow SQL。</p>
<h2 id="最后">最后</h2>
<p>基于这几种方案我们打了一套组合拳。经过将近一年的使用，
进行了 28 个通宵，迁移了 42 个系统，
完成了包括用户、订单、支付、电商、学习、社群、内容和工具的迁移。
迁移的数据总规模接近百亿，所有迁移项目均一次成功。
迁移过程中积累了丰富的实战经验，保障了业务快速向前发展。</p>
<p>下一篇：<a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>服务性能监控：USE 方法（The USE Method）</title>
      <link>https://blog.alswl.com/2017/11/use-method/</link>
      <pubDate>Sun, 12 Nov 2017 15:30:12 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2017/11/use-method/</guid>
      <description>本文首发在沪江技术学院公众号，小莞翻译，我做了校对。 由于微信公众号的封闭性，我担心未来文章不容易被发现。 为了避免沧海遗珠，特意转到这里。 英文原文：The USE Method。 USE 方法是一种能分析任何系统性能的方法论。 我们可以根据能帮助系统分析的结构化清单，来迅速的定位资源的瓶颈和错误所在。 它通常会先以列出问题为开始，然后再寻找适合的指标，而不是给你制定一些固定的指标， 然后让你按部就班的执行下去。 本页左侧下</description>
      <content:encoded><![CDATA[<p>本文首发在沪江技术学院公众号，小莞翻译，我做了校对。
由于微信公众号的封闭性，我担心未来文章不容易被发现。
为了避免沧海遗珠，特意转到这里。</p>
<p>英文原文：<a href="http://www.brendangregg.com/usemethod.html">The USE Method</a>。</p>
<hr />
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201711/performance_900.jpg" alt="201711/performance.jpg"  />


</p>
<p>USE 方法是一种能分析任何系统性能的方法论。
我们可以根据能帮助系统分析的结构化清单，来迅速的定位资源的瓶颈和错误所在。
它通常会先以列出问题为开始，然后再寻找适合的指标，而不是给你制定一些固定的指标，
然后让你按部就班的执行下去。</p>
<!-- more -->
<p>本页左侧下方，是我列出的，根据不同的操作系统（Linux、 Solaris 等）
衍生的 USE 方法列表。（译者注：可以参考原文链接）</p>
<p>我列出了为不同的操作系统而衍生的 USE 方法列表供大家参考，
你们可以根据你的环境来为你的站点服务，选择适合的附加监控指标。</p>
<p>通过这个工具，可以很方便的筛选出适合不同的系统的建议 metrics：<a href="http://www.brendangregg.com/USEmethod/use-rosetta.html">USE Method: Rosetta Stone of Performance Checklists</a></p>
<h2 id="introintroduction">Intro（Introduction）</h2>
<p>如果你遇到一个很严重的性能问题升级的时候，并且你不能确定它是否由服务导致的，
这时候你该怎么办？</p>
<p>我们都说万事开头难。所以我开发出了 USE 方法，来帮助大家，如何去快速的解决常见的性能问题，而同时又不容易忽略重要的地方。</p>
<p>USE 方法在设计之初就定位了简洁、明了、完整、快速的特性，
就好像一本航天手册的紧急事项列表那样。
（译者注：航天手册，介绍包括不限于飞机的各种特性、指标、性能等，
用于帮助飞行学员学习驾驶飞机，或者是帮助那些希望提高他们的飞行潜能和航空知识的人了解的更全面）。</p>
<p>USE 方法已经在不同的企业、课堂（作为学习工具）以及最近的云计算等场景中，被成功应用了无数次。</p>
<p>USE 方法基于 3+1 模型（三种指标类型+一种策略），来切入一个复杂的系统。我发现它仅仅发挥了
5% 的力量，就解决了大概 80% 的服务器问题，并且正如我将证明的，它除了服务器以外，也同样适应于各种系统。</p>
<p>它应当被理解为一种工具，一种很大的方法工具箱里面的工具。不过，它目前仍然还有很多问题类型以待解决，还需要点其他方法和更多的时间。</p>
<h2 id="summary">Summary</h2>
<p>USE 方法可以概括为：检查所有的资源的利用率，饱和度，和错误信息。</p>
<p>我们期望大家能尽早使用 USE 方法去做性能检查，或者是用它确定系统的瓶颈。</p>
<p>名词定义：</p>
<ul>
<li>资源： 服务器功能性的物理组成硬件（CPU， 硬盘,  总线）</li>
<li>利用率： 资源执行某工作的平均时间</li>
<li>饱和：衡量资源超载工作的程度，往往会被塞入队列</li>
<li>错误： 错误事件的数量</li>
</ul>
<p>分析软件资源，或者是软件的强制性限制（资源控制）也是很有用的，同时要关注哪些指标是处于正常的可接受范围之内的。这些指标通常用以下术语表示：</p>
<ul>
<li>利用率：
以一个时间段内的百分比来表示，例如：一个硬盘以 90% 的利用率运行</li>
<li>饱和度： 一个队列的长度，例如：CPUs 平均的运行时队列长度是4</li>
<li>错误（数）： 可度量的数量，例如：这个网络接口有 50 次（超时？）</li>
</ul>
<p>我们应该要调查那些错误，因为它们会降低系统的性能，并且当故障模型处于可回复模式的时候，它可能不会立刻被发现。</p>
<p>这包括了那些失败和重试等操作，以及那些来自无效设备池的失效设备。</p>
<h2 id="低利用率是否意味着未饱和">低利用率是否意味着未饱和？</h2>
<p>即使在很长一段时间内利用率很低，一个爆发增长的高利用率，也会导致饱和 and
性能问题，这点要理解起来可能有违三观！</p>
<p>我举个例子，有一位客户遇到的问题，即使他们的监控工具显示
CPU 使用率从来没有超出过 80% ，但是
CPU 饱和度依然有问题（延迟）监控工具报告了
5 分钟的平均值，而其中，CPU利用率曾在数秒内高达 100% 。</p>
<h2 id="资源列表">资源列表</h2>
<p>下面来看如何开始使用。</p>
<p>准备工作时， 你需要一个资源列表来按步就班的去做。
下面是一个服务器的通用列表：</p>
<ul>
<li>CPUs： sockets, cores, hardware threads (virtual CPUs)</li>
<li>内存： 容量</li>
<li>网络接口</li>
<li>存储设备： I/O, 容量</li>
<li>控制器： 存储, 网卡</li>
<li>通道： CPUs, memory, I/O</li>
</ul>
<p>有些组件分两种类型的资源：存储设备是服务请求资源（I / O）
以及容量资源（population）， 两种类型都可能成为系统瓶颈。
请求资源可以定义为队列系统，可以将请求先存入排队然后再消化请求。</p>
<p>有些物理组件已被省略，例如硬件缓存（例如，MMU TLB / TSB，CPU）。</p>
<p>USE 方法对于在高利用率或高饱和度下，遭受性能退化、导致瓶颈的资源最有效，在高利用率下缓存可以提高性能。</p>
<p>在使用 USE 方法排除系统的瓶颈问题之后
，你可以检查缓存利用率和其他的性能属性。</p>
<p>如果你不确认要不要监控某一个资源时，不要犹豫，监控它，然后你就能看到那些指标工作的有多么的棒。</p>
<h2 id="功能模块示意图">功能模块示意图</h2>
<p>另外一种迭代资源的方法，是找到或者绘制一张系统的功能模块示意图。</p>
<p>这些显示了模块关系的图，在你查找数据流的瓶颈的时候是非常有用的，这里有一张Sun
Fire V480 Guide(page 82)的例图：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201711/v480.png" alt="201711/v480.png"  />


</p>
<p>我喜欢这些图表，尽管制作出它很难。
不过，由硬件工程师来画这张图是最适合的-他们最善于做这类事。如果不信的话你可以自己试试。</p>
<p>在确定各种总线的利用率的同时，为每个总线的功能图表，注释好它的最大带宽。这样我们就能在进行单次测量之前，得到能将系统瓶颈识别出来的图表。</p>
<h2 id="interconnects">Interconnects</h2>
<p>CPU，内存和I / O interconnects 往往被忽略。
幸运的是，它们并不会频繁地成为系统的瓶颈。
不幸的是，如果它们真的频繁的成为瓶颈，我们能做的很少（也许你可以升级主板，或减少 load：例如，&ldquo;zero copy&quot;项目减轻内存总线 load）。</p>
<p>使用 USE 方法，至少你会意识到你没有考虑过的内容：interconnect 性能。
有关使用 USE 方法确定的互连问题的示例，请参阅分析 Analyzing the HyperTransport。</p>
<h2 id="metrics">Metrics</h2>
<p>给定资源列表，识别指标类型：利用率，饱和度和错误指标。这里有几个示例。看下面的 table，思考下每个资源和指标类型，metric 列是一些通用的 Unix/Linux 的术语提示（你可以描述的更具体些）：</p>
<hr />
<p>resource             type          metric
CPU                  utilization   CPU utilization (either per-CPU or a system-wide average)
CPU                  saturation    run-queue length or scheduler latency(aka
Memory capacity      utilization   available free memory (system-wide)
Memory capacity      saturation    anonymous paging or thread swapping (maybe &ldquo;page scanning&rdquo; too)
Network interface    utilization   RX/TX throughput / max bandwidth
Storage device I/O   utilization   device busy percent
Storage device I/O   saturation    wait queue length
Storage device I/O   errors        device errors (&ldquo;soft&rdquo;, &ldquo;hard&rdquo;, &hellip;)</p>
<hr />
<p>这些指标是每段间隔或者计数的平均值，作为你的自定义清单，要包括使用的监控软件，以及要查看的统计信息。如果是不可用的指标，可以打个问号。最后，你会完成一个完事的、简单、易读的
metrics 清单.</p>
<h2 id="harder-metrics">Harder Metrics</h2>
<p>再来看几个硬件指标的组合</p>
<hr />
<p>resource              type          metric
CPU                   errors        eg, correctable CPU cache ECC events or faulted CPUs (if the OS+HW supports that)
Memory capacity       errors
Network               saturation
Storage controller    utilization
CPU interconnect      utilization
Memory interconnect   saturation
I/O interconnect      utilization</p>
<hr />
<p>这些依赖于操作系统的指标一般会更难测量些，
而我通常要用自己写的软件去收集这些指标。</p>
<p>重复所有的组合，并附上获取每个指标的说明，你会完成一个大概有30项指标的列表，其中有些是不能被测量的，还有些是难以测量的。</p>
<p>幸运的是，最常见的问题往往是简单的（例如，CPU 饱和度，内存容量饱和度，网络接口利用率，磁盘利用率），这类问题往往第一时间就能被检查出来。</p>
<p>本文的顶部，pic-1中的 example checklists 可作为参考。</p>
<h2 id="in-practice">In Practice</h2>
<p>读取系统的所有组合指标，是非常耗时的，特别是当你开始使用总线和 interconnect
指标的情况下。</p>
<p>现在我们可以稍微解放下了，USE 方法可以让你了解你没有检查的部分,你可以只有关注其中几项的时间例如：CPUs,
内存容量, 存储容易, 存储设备 I/O,
网络接口等。通过 USE 方法，那些以前未知的未知指标现在变成了已知的未知指标（我理解为，以前我们不知道有哪些指标会有什么样的数据，现在起码能知道我们应该要关注哪些指标）。</p>
<p>如果将来定位一个性能问题的根本原因，对你的公司至关重要的时候，你至少已经有一个明确的、经过验证的列表，来辅助你进行更彻底的分析，请完成适合你自己的 USE 方法，有备无患。</p>
<p>希望随着时间的推移，易于检查的指标能得以增长，因为被添加到系统的 metrics
越多，会使 USE 方法将更容易（发挥它的力量）。
性能监视软件也可以帮上忙，添加 USE 方法向导to do the work for you（do what
work? ）。</p>
<h2 id="software-resources">Software Resources</h2>
<p>有些软件资源可以用类似的方式去分析。
这通常适用于软件的较小组件，而不是整个应用程序。 例如：</p>
<ul>
<li>互斥锁(mutex locks)：利用率可以定义为锁等待耗时；饱和率定义为等待这把锁的线程个数。</li>
<li>线程池：利用率可以定义为线程工作的时长；饱和率是等待线程池分配的请求数量。</li>
<li>进程/线程
容量：系统是有进程或线程的上限的，它的实际使用情况被定义为利用率；等待数量定义为饱和度；错误即是（资源）分配失败的情况（比如无法 fork）。
（译注：fork 是一个现有进程，通过调用 fork 函数创建一个新进程的过程)</li>
<li>文件描述符容量(file descriptor capacity)：和上述类似，但是把资源替换成文件描述符。</li>
</ul>
<p>如果这几个指标很管用就一直用，要不然软件问题会被遗留给其他方法了（例如，延迟，后文会提到其他方法：other methodologies ）。</p>
<h2 id="suggested-interpretations">Suggested Interpretations</h2>
<p>USE 方法帮助你定位要使用哪些指标。
在学习了如何从操作系统中读取到这些指标后，你的下一步工作就是诠释它们的值。对于有的人来说，
这些诠释可能是很清晰的（因为他们可能很早就学习过，或者是做过笔记）。而其他并不那么明了的人，可能取决于系统负载的要求或期望
。</p>
<p>下面是一些解释指标类型的通用建议：</p>
<ul>
<li>Utilization：
利用率通常象征瓶颈（检查饱和度可以进一步确认）。高利用率可能开始导致若干问题：</li>
<li>对利用率进行长期观察时（几秒或几分钟），通常来说 70%
的利用率会掩盖掉瞬时的 100% 利用率。</li>
<li>某些系统资源，比如硬盘，就算是高优先级请求来了，也不会在操作进行中被中断。当他们的利用率到
70% 时候，队列系统中的等待已经非常频繁和明显。而 CPU 则不一样，它能在大部分情况下被中断。</li>
<li>Saturation：任何非 0 的饱和度都可能是问题。它们通常是队列中排队的时间或排队的长度。</li>
<li>Errors：只要有一条错误，就值得去检查，特别是当错误持续发生从而导致性能降低时候。</li>
</ul>
<p>要说明负面情况很容易：利用率低，不饱和，没有错误。 这比听起来更有用 -
缩小调查范围可以快速定位问题区域。</p>
<h2 id="cloud-computing">Cloud Computing</h2>
<p>在云计算环境中，软件资源控制可能是为了限制
使用共享计算服务的 tenants 的流量。在 Joyent 公司，我们主要使用操作系统虚拟化（SmartOS），它强加了内存限制，
CPU 限制和存储I / O限制。 所有这些资源限制，都可以使用USE Method进行检查，类似于检查物理资源。</p>
<p>例如，在我们的环境中，&ldquo;内存容量利用率&quot;可以是 tenants 的内存使用率 vs 它的内存上限
。即使传统的 Unix 页面扫描程序可能处于空闲状态，也可以通过匿名页面活动看到&quot;内存容量饱和度&rdquo;。</p>
<h2 id="strategy">Strategy</h2>
<p>下面是用流程图 的方式画了 USE 方法的示意图。
请注意，错误检查优先于利用率和饱和度检查（因为通常错误更快的表现出来，并更容易解释）。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201711/usemethod_flow.png" alt="201711/usemethod_flow.png"  />


</p>
<p>USE 方法定位到的问题，可能是系统瓶颈。
不幸的是，系统可能会遇到多个性能问题，因此您发现的第一个可能的问题最终却不是个问题。
发现的每个问题都可以用方法持续的挖掘，然后继续使用 USE
方法对更多资源进行反复排查。</p>
<p>进一步分析的策略包括工作量特征和 drill-down 分析。
完成这些后，你应该有依据据能判断，纠正措施是要调整应用的负载或调整资源本身。</p>
<h2 id="apollo">Apollo</h2>
<p>（译者注：Apollo 这一段我们可以不太关注，它主要是讲 USE 方法，与阿波罗登月计划相关的系统设计的一些渊源）</p>
<p>我之前有提到过，USE 方法可以被应用到除服务器之外。为了找到一个有趣的例子，
我想到了一个我没有完全不了解的系统，并且不知道从哪里开始：阿波罗月球模块指导系统。
USE 方法提供了一个简单的流程来尝试第一步是寻找一个资源列表，或者更理想的话，找到一个功能模块图表。我在
【Lunar Module - LM10 Through LM14 Familiarization Manual】中发现了以下内容：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201711/apollo_LM_guidance.png" alt="201711/apollo_LM_guidance.png"  />


</p>
<p>这些组件中的一部分可能未表现出利用率或饱和度特性。在迭代后，
就可以重新绘制只包含相关组件的图表（还可以包括：&ldquo;可擦除存储&quot;部分的内存，&ldquo;核心区域&quot;和 &ldquo;vac区域 &ldquo;寄存器）。</p>
<p>我将从阿波罗主脑（AGC）本身开始。
对于每个指标，我浏览了各种 LM 文档，看看哪些是合理的（有意义的）：</p>
<ul>
<li>AGC utilization： This could be defined as the number of CPU cycles
doing jobs (not the &ldquo;DUMMY JOB&rdquo;) divided by the clock rate (2.048
MHz). This metric appears to have been well understood at the time.</li>
<li>AGC saturation： This could be defined as the number of jobs in the
&ldquo;core set area&rdquo;, which are seven sets of registers to store
program state. These allow a job to be suspended (by the
&ldquo;EXECUTIVE&rdquo; program - what we'd call a &ldquo;kernel&rdquo; these days) if
an interrupt for a higher priority job arrives. Once exhausted, this
moves from a saturation state to an error state, and the AGC reports
a 1202 &ldquo;EXECUTIVE OVERFLOW-NO CORE SETS&rdquo; alarm.</li>
<li>AGC errors： Many alarms are defined. Apart from 1202, there is also
a 1203 alarm &ldquo;WAITLIST OVERFLOW-TOO MANY TASKS&rdquo;, which is a
performance issue of a different type： too many timed tasks are
being processed before returning to normal job scheduling. As with
1202, it could be useful to define a saturation metric that was the
length of the WAITLIST, so that saturation can be measured before
the overflow and error occurs.</li>
</ul>
<p>其中的一些细节，可能对于太空爱好者来说是非常熟悉的：在阿波罗 11 号降落的时候发生的著名的
1201（&ldquo;NO VAC AREAS&rdquo;）和 1202 警报。（&ldquo;VAC&quot;是向量加速器的缩写，
用于处理 vector quantities 作业的额外存储； 我觉得 wikipadia 上将 &ldquo;向量&quot;描述为&quot;空&quot;可能是错误的）。</p>
<p>鉴于阿波罗 11 号的 1201 警报，可以继续使用其他方法分析，如工作负载表征。
工作负载很多可以在功能图中看到，大多数工作负载是通过中断来生效的。
包括用于跟踪命令模块的会合雷达，即使 LM 正在下降，该模块也仍然在执行中断 AGC（阿波罗主脑）的任务。
这是发现非必要工作的一个例子（或低优先级的工作;
雷达的一些更新可能是可取的，因此 LM AGC可以立即计算出中止路径）。</p>
<p>作为一个更深的例子，我将把会合雷达当作资源去检查. 错误最容易识别。
有三种信号类型： &ldquo;DATA NO GOOD&rdquo;, &ldquo;NO TRACK&rdquo;, and &ldquo;SHAFT- AND TRUNNION-AXIS ERROR&rdquo;。</p>
<p>在有某一小段时间里，我不知道能从哪里开始使用这个方法,
去寻找和研究具体的指标。</p>
<h2 id="other-methodologies">Other Methodologies</h2>
<p>虽然 USE 方法可能会发现 80％ 的服务器问题，但基于延迟的方法（例如Method R）可以找到所有的问题。
不过，如果你不熟悉软件内部结构，Method R 就有可能需要花费更多时间。
它们可能更适合已经熟悉它的数据库管理员或应用程序开发人员。</p>
<p>而 USE 方法的职责和专长包括操作系统（OS）和硬件，它更适合初级或高级系统管理员，当需要快速检查系统健康时，也可以由其他人员使用。</p>
<h2 id="tools-method">Tools Method</h2>
<p>以下介绍一个基于工具的方法流程（我称它作&quot;工具方法&rdquo;），与 USE 方法作比较：</p>
<ol>
<li>列出可用的性能工具（可以选择性安装或购买其他的）。</li>
<li>列出每个工具提供的有用的指标</li>
<li>列出每个工具可能的解释规则</li>
</ol>
<p>按照这个方法做完后，将得到一个符合标准的清单，它告诉我们要运行的工具，要关注的指标以及如何解释它们。
虽然这相当有效，但有一个问题，它完全依赖于可用（或已知的）的，可以提供系统的不完整视图的工具。
用户也不知道他们得到的是一张不完整的视图 - 所以问题将仍然存在。</p>
<p>而如果使用 USE 方法，不同的是， USE 方法将通过迭代系统资源的方式，来创建一个完整的待确认问题列表，然后搜索工具来回答这些问题。这样构建了一张更完整的视图，未知的部分被记录下来，它们的存在被感知（这一句我理解成前文中提到的：未知
的未知变为已知的未知）。
基于 USE ，同样可以开发一个清单类似于工具方法(Tool-Method)，显示要运行的工具（可用的位置），要关注的指标以及如何解释它。</p>
<p>另一个问题是，工具方法在遍历大量的工具时，将会使寻找瓶颈的任务性能得到分散。而 USE 方法提供了一种策略，即使是超多的可用工具和指标，也能有效地查找瓶颈和错误。</p>
<h2 id="conclusion">Conclusion</h2>
<p>USE 方法是一个简单的，能执行完整的系统健康检查的策略，它可以识别常见的系统瓶颈和错误。它可以在调查的早期部署并快速定位问题范围，如果需要的话，还可以进一步通过其他方法进行更详细的研究。</p>
<p>我在这个篇幅上，解释了 USE 方法并且提供了通用的指标案例，请参阅左侧导航面板中对应操作系统的示例清单，
其建议了应用 USE 方法的工具和指标。另请参阅基于线程的补充方法，TSA Method。</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<ul>
<li>感谢 Cary Millsap and Jeff Holt (2003)
在&quot;优化 Oracle 性能&quot;一文中提到的 Method R 方法 (以及其他方法),
使我有了灵感，我应该要把这个方法论写出来。</li>
<li>感谢 Sun Microsystems 的组织，包括 PAE 和 ISV，
他们将 USE 方法（那时还没命名）应用于他们的存储设备系列，绘制了标注指标和总线速度的 ASCII 功能块图表 -
这些都比您想象的要困难（我们应该早些时候询问硬件团队的帮助）。</li>
<li>感谢我的学生们，多年前我授予他们这个方法论，谢谢他们提供给我的使用反馈。</li>
<li>感谢 Virtual AGC 项目组（The Virtual
AGC project），读他们的站点 ibiblio.org 上的文档库，就象是一种娱乐.
尤其是 LMA790-2 &ldquo;Lunar Module LM-10 Through LM-14 Vehicle
Familiarization Manual&rdquo; ( 48 页有功能模块图表), 以及
&ldquo;阿波罗指导和月球导航模块入门学习指南&rdquo;,
都很好的解释了执行程序和它的流程图 (These docs are 109 and 9 Mbytes in size.)</li>
<li>感谢 Deirdré Straughan 编辑和提供反馈，这提高了我的认知。</li>
<li>文章顶部的图片，是来自于波音 707 手册，1969 出版。它不是完整的，点击查看完整的版本（译注：为方便阅读，就是下面这张：）</li>
</ul>
<h2 id="updates">Updates</h2>
<p>USE Method updates：（略）</p>
<ul>
<li>It was published in ACMQ as Thinking Methodically about
Performance (2012).</li>
<li>It was also published in Communications of the ACM as Thinking
Methodically about Performance (2013).</li>
<li>I presented it in the FISL13 talk The USE Method (2012).</li>
<li>I spoke about it at Oaktable World 2012： video, PDF.</li>
<li>I included it in the USENIX LISA `12 talk Performance Analysis
Methodology.</li>
<li>It is covered in my book on Systems Performance, published by
Prentice Hall (2013).</li>
</ul>
<p>More updates (Apr 2014)：</p>
<ul>
<li>LuceraHQ are implementing USE Method metrics on SmartOS
for performance monitoring of their high performance financial
cloud.</li>
<li>LuceraHQ 正在 SmartOS 上，为他们高性能金融云的性能监测，实施 USE 方法指标</li>
<li>I spoke about the USE Method for OS X at MacIT 2014 (slides)。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Stack Overflow 的 HTTPS 化：漫漫长路的终点</title>
      <link>https://blog.alswl.com/2017/09/https-on-stack-overflow/</link>
      <pubDate>Wed, 27 Sep 2017 12:07:44 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2017/09/https-on-stack-overflow/</guid>
      <description>原文作者：Nick Craver 翻译作者：罗晟 @luosheng &amp;amp; @alswl 原文地址：Nick Craver - HTTPS on Stack Overflow: The End of a Long Road 本文为原创翻译文章，已经获得原作者授权，转载请注明作者及出处。 本文首发在「沪江技术学院」公众号 今天，我们默认在 Stack Overflow 上部署了 HTTPS。目前所有的流量都将跳转到 https:// 上。与此同时，Google 链接也会在接下去的几周内更改。启用的过程本身只是举手之劳，但在此之前我们却花了好几年的时间。到目前为止，HTTPS 在我们所有的 Q&amp;amp;A 网站</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/stack-overflow.jpg" alt="Stack Overflow"  />


</p>
<ul>
<li>原文作者：Nick Craver</li>
<li>翻译作者：<a href="https://twitter.com/luosheng">罗晟 @luosheng</a> &amp; <a href="https://twitter.com/alswl">@alswl</a></li>
<li>原文地址：<a href="https://nickcraver.com/blog/2017/05/22/https-on-stack-overflow/">Nick Craver - HTTPS on Stack Overflow: The End of a Long Road</a></li>
<li>本文为原创翻译文章，已经获得原作者授权，转载请注明作者及出处。</li>
<li>本文首发在「沪江技术学院」公众号</li>
</ul>
<hr />
<p>今天，我们默认在 <a href="https://stackoverflow.com/">Stack Overflow</a> 上部署了 HTTPS。目前所有的流量都将跳转到 <code>https://</code> 上。与此同时，Google 链接也会在接下去的几周内更改。启用的过程本身只是举手之劳，但在此之前我们却花了好几年的时间。到目前为止，HTTPS 在我们所有的 Q&amp;A 网站上都默认启用了。</p>
<p><a href="https://meta.stackoverflow.com/q/345012/13249">在过去的两个月里</a>，我们在 Stack Exchange 全网维持发布 HTTPS。Stack Overflow 是最后，也是迄今最大的的一个站点。这对我们来说是一个巨大里程碑，但决不意味着是终点。<a href="#next-steps">后文会提到</a>，我们仍有很多需要做的事情。但现在我们总算能看得见终点了，耶！</p>
<p>友情提示：这篇文章讲述的是一个漫长的旅程。非常漫长。你可能已经注意到你的滚动条现在非常小。我们遇到的问题并不是只在 Stack Exchange/Overflow 才有，但这些问题的组合还挺罕见。我在文章中会讲到我们的一些尝试、折腾、错误、成功，也会包括一些开源项目——希望这些细节对你们有所帮助。由于它们的关系错综复杂，我难以用时间顺序来组织这篇文章，所以我会将文章拆解成架构、应用层、错误等几个主题。</p>
<!-- more -->
<p>首先，我们要提一下为什么我们的处境相对独特：</p>
<ul>
<li>我们有几百个域名（<a href="https://stackexchange.com/sites">大量站点</a>及服务）
<ul>
<li>大量二级域名（<a href="https://stackoverflow.com/">stackoverflow.com</a>、<a href="https://stackexchange.com/">stackexchange.com</a>、<a href="https://askubuntu.com/">askubuntu.com</a>等）</li>
<li>大量四级域名（如 <a href="http://meta.gaming.stackexchange.com/">meta.gaming.stackexchange.com</a>）</li>
</ul>
</li>
<li>我们允许用户提交、嵌入内容（比如帖子中的图片和 YouTube 视频）</li>
<li>我们仅有一个数据中心（造成单源的延时）</li>
<li>我们有广告（及广告网络）</li>
<li>我们用 websockets，任何时刻的活跃数都不少于 50 万个（连接数问题）</li>
<li>我们会被 DDoSed 攻击（代理问题）</li>
<li>我们有不少站点及应用还是通过 HTTP API 通信的（代理问题）</li>
<li>我们热衷于性能（<em>好像</em>有点太过了）</li>
</ul>
<p>由于这篇文章实在太长，我在这里先列出链接：</p>
<ul>
<li><a href="#the-beginning">开篇</a></li>
<li><a href="#quick-specs">懒人包</a></li>
<li>基础设施
<ul>
<li><a href="#certificates">证书</a>
<ul>
<li><a href="#certificates-child-metas-metastackexchangecom">Meta 子域（meta.*.stackexcange.com）</a></li>
</ul>
</li>
<li><a href="#performance-http2">性能：HTTP/2</a></li>
<li><a href="#haproxy-serving-up-https">HAProxy：支持 HTTPS</a></li>
<li><a href="#cdnproxy-countering-latency-with-cloudflare--fastly">CDN/代理层：通过 Cloudflar 和 Fastly 优化延迟</a>
<ul>
<li><a href="#preparing-for-a-proxy-client-timings">优化代理层的准备：客户端性能测试</a></li>
<li><a href="#cloudflare">CloudFlare</a>
<ul>
<li><a href="#cloudflare-railgun">Railgun</a></li>
</ul>
</li>
<li><a href="#fastly">Fastly</a></li>
</ul>
</li>
<li><a href="#global-dns">全局 DNS</a></li>
<li><a href="#testing">测试</a></li>
</ul>
</li>
<li>应用层/代码
<ul>
<li><a href="#preparing-the-applications">应用层准备</a></li>
<li><a href="#global-login">全局登录</a></li>
<li><a href="#local-https-development">本地 HTTPS 开发</a></li>
<li>混合内容
<ul>
<li><a href="#mixed-content-from-you">来自你们</a></li>
<li><a href="#mixed-content-from-us">来自我们</a></li>
</ul>
</li>
<li><a href="#redirects-301s">跳转（301）</a></li>
<li><a href="#websockets">Websockets</a></li>
</ul>
</li>
<li><a href="#unknowns">未知</a></li>
<li><a href="#mistakes">错误</a>
<ul>
<li><a href="#mistakes-protocol-relative-urls">相对协议 URL</a></li>
<li><a href="#mistakes-apis-and-internal">API 及 .internal</a></li>
<li><a href="#mistakes-301-caching">301 缓存</a></li>
<li><a href="#mistakes-help-center-snafu">帮助中心的小插曲</a></li>
</ul>
</li>
<li><a href="#open-source">开源</a></li>
<li><a href="#next-steps">下一步</a>
<ul>
<li><a href="#hsts-preloading">HSTS 预加载</a></li>
<li><a href="#chat">聊天</a></li>
<li><a href="#today">今天</a></li>
</ul>
</li>
</ul>
<h3 id="开篇">开篇</h3>
<p>我们<a href="https://nickcraver.com/blog/2013/04/23/stackoverflow-com-the-road-to-ssl/">早在 2013</a> 年就开始考虑在 Stack Overflow 上部署 HTTPS 了。是的，现在是 2017 年。所以，**究竟是什么拖了我们四年？**这个问题的答案放在任何一个 IT 项目上都适用：依赖和优先级。老实说，Stack Overflow 在信息安全性上的要求并不像别家那么高。我们不是银行，也不是医院，我们也不涉及信用卡支付，<a href="https://archive.org/details/stackexchange">甚至于我们每个季度都会通过 HTTP 和 BT 种子的方式发布我们大部分的数据库</a>。这意味着，从安全的角度来看，这件事情的紧急程度不像它在其他领域里那么高。而从依赖上来说，我们的复杂度比别人要高，在部署 HTTPS 时会在几大领域里踩坑，这些问题的组合是比较特殊的。后文中会看到，有一些域名的问题还是一直存在的。</p>
<p>容易踩坑的几个领域包括：</p>
<ul>
<li>用户内容（用户可以上传图片或者指定 URL）</li>
<li>广告网络（合同及支持）</li>
<li>单数据中心托管（延迟）</li>
<li>不同层级下的<a href="https://stackexchange.com/sites"><strong>几百个</strong>域名</a>（证书）</li>
</ul>
<p>那我们究竟是为什么需要 HTTPS 呢？因为数据并不是唯一需要安全性的东西。我们的用户中有操作员、开发者、还有各个级别的公司员工。我们希望他们到我们站点的通信是安全的。我们希望每一个用户的浏览历史是安全的。某些用户暗地里喜欢 monad 却又害怕被人发现。同时，Google 会<a href="https://webmasters.googleblog.com/2014/08/https-as-ranking-signal.html">提升 HTTPS 站点的搜索排名</a>（虽然我们不知道能提升多少）。</p>
<p>哦，还有<strong>性能</strong>。我们热爱性能。我热爱性能。你热爱性能。我的狗热爱性能。让我给你一个性能的拥抱。很好。谢谢。你闻起来很香。</p>
<h3 id="懒人包">懒人包</h3>
<p>很多人喜欢情人包，所以我们来一场快速问答（我们喜欢问答！）：</p>
<ul>
<li>问：你们支持什么协议？
<ul>
<li>答：TLS 1.0、1.1、1.2（注意：<a href="https://www.fastly.com/blog/phase-two-our-tls-10-and-11-deprecation-plan">Fastly 准备放弃 TLS 1.0 和 1.1</a>)。我们马上也会支持 TLS 1.3。</li>
</ul>
</li>
<li>问：你们支持 SSL v2 或者 v3 吗？
<ul>
<li>答：不支持。<a href="http://disablessl3.com/">这些协议不安全</a>。大家都应该尽早禁用。</li>
</ul>
</li>
<li>问：你们支持哪些加密套件？
<ul>
<li>答：CDN 上，我们用的是 <a href="https://www.ssllabs.com/ssltest/analyze.html?d=meta.stackexchange.com&amp;s=151.101.129.69#suitesHeading">Fastly 的默认套件</a>；</li>
<li>答：我们自己的负载均衡器上用的是 <a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility">Mozilla 的现代兼容性套件</a>。</li>
</ul>
</li>
<li>问：Fastly 回源走的是 HTTPS 吗？
<ul>
<li>答：是。如果到 CDN 的请求是 HTTPS，回源的请求也是 HTTPS。</li>
</ul>
</li>
<li>问：你们支持前向安全性吗？
<ul>
<li>答：是。</li>
</ul>
</li>
<li>问：你们支持 <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HSTS</a> 吗？
<ul>
<li>答：支持。我们正在 Q&amp;A 站点中逐步支持。一旦完成的话我们就会将其移至节点上。</li>
</ul>
</li>
<li>问：你们支持 HPKP 吗？
<ul>
<li>答：不支持，应该也不会支持。</li>
</ul>
</li>
<li>问：你们支持 SNI 吗？
<ul>
<li>答：不支持。出于 HTTP/2 性能考虑，我们使用是一个合并的通配符证书（详见后文）。</li>
</ul>
</li>
<li>问：你们的证书是哪来的？
<ul>
<li>答：我们用的是 <a href="https://www.digicert.com/">DigiCert</a>，他们很棒。</li>
</ul>
</li>
<li>问：你们支持 IE 6 吗？
<ul>
<li>答：这次之后终于不再支持了。IE 6 默认不支持 TLS（尽管你可以启用 1.0 的支持），而我们则不支持 SSL。当我们 301 跳转就绪的时候大部分 IE 6 用户就不能访问 Stack Overflow 了。一旦我们弃用 TLS 1.0，所有 IE 6 用户都不行了。</li>
</ul>
</li>
<li>问：你们负载均衡器用的什么？
<ul>
<li>答：<a href="https://www.haproxy.org/">HAProxy</a>（内部使用的是 <a href="https://www.openssl.org/">OpenSSL</a>）。</li>
</ul>
</li>
<li>问：使用 HTTPS 的动机是什么？
<ul>
<li>答：有人一直攻击我们的管员员路由，如 <a href="https://stackoverflow.com/admin.php">stackoverflow.com/admin.php</a>。</li>
</ul>
</li>
</ul>
<h3 id="证书">证书</h3>
<p>让我们先聊聊证书，因为这是最容易被误解的部分。不少朋友跟我说，他安装了 HTTPS 证书，因此他们已经完成 HTTPS 准备了。呵呵，麻烦你看一眼右侧那个小小的滚动条，这篇文章才刚刚开始，你觉得真的这么简单么？<a href="https://en.wikipedia.org/wiki/Scientific_wild-ass_guess">我有这个必要告诉你们一点人生的经验</a> ：没这么容易的。</p>
<p>一个最常见的问题是：「为何不直接用 <a href="https://letsencrypt.org/">Let’s Encrypt</a>？」</p>
<p>答案是：这个方案不适合我们。 Let’s Encrypt 的确是一个伟大的产品，我希望他们能够长期服务于大家。当你只有一个或少数几个域名时，它是非常出色的选择。但是很可惜，我们 Stack Exchange 有<a href="https://stackexchange.com/sites">数百个站点</a>，而 Let’s Encrypt 并<a href="https://letsencrypt.org/docs/faq/">不支持通配域名配置</a>。这导致 Let’s Encrypt 无法满足我们的需求。要这么做，我们就不得不在每上一个新的 Q&amp;A 站点的时候都部署一个（或两个）证书。这样会增加我们部署的复杂性，并且我们要么放弃不支持 SNI 的客户端（大约占 2% 的流量）要么提供超多的 IP——而我们目前没这么多的 IP。</p>
<p>我们之所以想控制证书，还有另外一个原因是我们想在本地负载均衡器以及 CDN / 代理提供商那边使用完成相同的证书。如果不做到这个，我们无法顺畅地做从代理那里做失效备援（failover）。支持 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning">HTTP 公钥固定（HPKP）</a>的客户端会报认证失败。虽然我们仍在评估是否使用 HPKP，但是如果有一天要用的话我们得提前做好准备。</p>
<p>很多朋友在看见我们的主证书时候会吓得目瞪口呆，因为它包含了我们的主域名和通配符子域名。它看上去长成这样：</p>
<p><a href="../../static/images/upload_dropbox/201709/HTTPS-MainCertificate.png">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/HTTPS-MainCertificate.png" alt="Main Certificate"  />


</a></p>
<p>为什么这么做？老实说，是我们让 <a href="https://www.digicert.com/">DigiCert</a> 替我们做的。这么做会导致每次发生变化的时候都需要手动合并证书，了　我们为什么要忍受这么麻烦的事呢？首先，我们期望能够尽可能让更多用户使用我们产品。这里面包括了那些还不支持 SNI 的用户（比如在我们项目启动的时候 Android 2.3 势头正猛）。另外，也包括 HTTP/2 与一些现实问题——我们过会儿会谈到这一块。</p>
<p>Meta 子域（meta.*.<a href="http://stackexcange.com/">stackexcange.com</a>）</p>
<p>Stack Exchage 的一个设计理念是，针对每个 Q&amp;A 站点，我们都有一个地方供讨论。我们称之为 <a href="https://stackoverflow.blog/2010/04/29/do-trilogy-sites-need-a-third-place/">“second place”</a>。比如 <code>meta.gaming.stackexchange.com</code> 用来讨论 <code>gaming.stackexchange.com</code>。这个有什么特别之处呢？好吧，并没有，除了域名：这是一个 4 级域名。</p>
<p>我之前已经说过<a href="https://nickcraver.com/blog/2013/04/23/stackoverflow-com-the-road-to-ssl/">这个问题</a>，但后来怎么样了呢？具体来说，现在面临的问题是 <code>*.stackexchange.com</code> 包含 <code>gaming.stackexchange.com</code>（及几百个其它站点），但它<strong>并不包含</strong> <code>meta.gaming.stackexchange.com</code>。<a href="https://tools.ietf.org/html/rfc6125#section-6.4.3">RFC 6125 （第 6.4.3 节）</a> 写道：</p>
<blockquote>
<p>客户端 <strong>不应该</strong> 尝试匹配一个通配符在中间的域名（比如，不要匹配 <code>bar.*.example.net</code>）</p>
</blockquote>
<p>这意味着我们无法使用 <code>meta.*.stackexchange.com</code>，那怎么办呢？</p>
<ul>
<li>方案一：部署 <a href="https://www.digicert.com/subject-alternative-name.htm">SAN 证书（多域名证书）</a>
<ul>
<li>我们需要准备 3 个证书和 3 个 IP（每张证书支持域名上限是 100），并且会把新站上线复杂化（虽然这个机制已经改了）</li>
<li>我们要在 CDN/代理层上部署三个自定义证书</li>
<li>我们要给 <code>meta.*</code> 这种形式的域名配置额外的 DNS 词条
<ul>
<li>根据 DNS 规则，我们必须给每个这样的站点配置一条 DNS，无法批量配置，从而提高了新站上线和维护代理的成本</li>
</ul>
</li>
</ul>
</li>
<li>方案二：将所有域名迁移到 <code>*.meta.stackexchange.com</code>
<ul>
<li>我们会有一次痛苦的迁移过程，但这是一次性的，并且未来维护证书成本较低</li>
<li>我们需要部署一个全局登录系统（<a href="#global-login">详情见此</a>）</li>
<li>这个方案仍然不解决 HSTS 预加载下面的 <code>includeSubDomains</code> 问题（<a href="#hsts-reloading">详情见此</a>）</li>
</ul>
</li>
<li>方案三：啥都不做，放弃
<ul>
<li>这个方案最简单，然而这是假方案</li>
</ul>
</li>
</ul>
<p>我们部署了 <a href="#global-login">全局登录系统</a>，然后将子 meta 域名用 301 重定向到新地址，比如 <a href="https://gaming.meta.stackexchange.com">gaming.meta.stackexchange.com</a>。做完这个之后我们才意识到，因为这些域名<em>曾经</em>存在过，所以对于 HSTS 预加载来说是个很大的问题。这件事情还在进行中，我会在<a href="#hsts-preloading">文章最后面</a>讨论这个问题。这类问题对于 <code>meta.pt.stackoverflow.com</code> 等站点也存在，不过还好我们只有四个非英语版本的 Stack Overflow，所以问题没有被扩大。</p>
<p>对了，这个方案本身还存在<em>另一个</em>问题。由于将 cookies 移动到顶级目录，然后依赖于子域名对其的继承，我们必须调整一些其他域名。比如，在我们新系统中，我们使用 SendGrid 来发送邮件（进行中）。我们从 <code>stackoverflow.email</code> 这个域名发邮件，邮件内容里的链接域名是 <code>sg-links.stackoverflow.email</code>（使用 <a href="https://en.wikipedia.org/wiki/CNAME_record">CNAME</a> 管理)，这样你的浏览器就不会将敏感的 cookie 发出去。如果这个域名是 <code>links.stackoverflow.com</code>，那么你的浏览器会将你在这个域名下的 cookie 发送出去。 我们有不少虽然使用我们的域名，但并不属于我们自己的服务。这些子域名都需要从我们受信的域名下移走，否则我们就会把你们的 cookie 发给非我们自有的服务器上。如果因为这种错误而导致 cookie 数据泄露，这将是件很丢人的事情。</p>
<p>我们有试过通过代理的方式来访问我们的 Hubspot CRM 网站，在传输过程中可以将 cookies 移除掉。但是很不幸 Hubspot 使用 <a href="https://www.akamai.com/">Akamai</a>，它会判定我们的 HAProxy 实例是机器人，并将其封掉。头三次的时候还挺有意思的……当然这也说明这个方式真的不管用。我们后来再也没试过了。</p>
<p>你是否好奇为什么 Stack Overflow 的博客地址是  <a href="https://stackoverflow.blog/">https://stackoverflow.blog/</a>？没错，这也是出于安全目的。我们把博客搭在一个外部服务上，这样市场部门和其他团队能够更便利地使用。正因为这样，我们不能把它放在有 cookie 的域名下面。</p>
<p>上面的方案会牵涉到子域名，引出 <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HSTS</a> <a href="https://hstspreload.org/">预加载</a> 和 <code>includeSubDomains</code> 命令问题，我们一会来谈这块内容。</p>
<h3 id="性能http2">性能：HTTP/2</h3>
<p>很久之前，大家都认为 HTTPS 更慢。在那时候也确实是这样。但是时代在变化，我们说 HTTPS 的时候不再是单纯的 HTTPS，而是基于 HTTPS 的 HTTP/2。虽然 <a href="https://http2.github.io/faq/#does-http2-require-encryption">HTTP/2 不要求加密</a>，但<em>事实上</em>却是加密的。主流浏览器都要求 HTTP/2 提供加密连接来启用其大部分特性。你可以来说 spec 或者规定上不是这么说的，但浏览器才是你要面对的现实。我诚挚地期望这个协议直接改名叫做 HTTPS/2，这样也能给大家省点时间。各浏览器厂商，你们听见了吗？</p>
<p>HTTP/2 有很多功能上的增强，特别是在用户请求之前可以主动推送资源这点。这里我就不展开了，<a href="https://hpbn.co/http2/">Ilya Grigorik 已经写了一篇非常不错的文章</a>。我这里简单罗列一下主要优点：</p>
<ul>
<li><a href="https://hpbn.co/http2/#request-and-response-multiplexing">请求/响应多路复用</a></li>
<li><a href="https://hpbn.co/http2/#server-push">服务端推送</a></li>
<li><a href="https://hpbn.co/http2/#header-compression">Header 压缩</a></li>
<li><a href="https://hpbn.co/http2/#stream-prioritization">网络流优先级</a></li>
<li><a href="https://hpbn.co/http2/#one-connection-per-origin">更少的连接</a></li>
</ul>
<p>咦？怎么没提到证书呢？</p>
<p>一个很少人知道的特性是，<a href="https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding">你可以推送内容到不同的域名</a>，只要满足以下的条件：</p>
<ol>
<li>这两个域名需要解析到同一个 IP 上</li>
<li>这两个域名需要使用同一张 TLS 证书（看到没！）</li>
</ol>
<p>让我们看一下我们当前 DNS 配置：</p>
<pre tabindex="0"><code>λ dig stackoverflow.com +noall +answer
; &lt;&lt;&gt;&gt; DiG 9.10.2-P3 &lt;&lt;&gt;&gt; stackoverflow.com +noall +answer
;; global options: +cmd
stackoverflow.com.      201     IN      A       151.101.1.69
stackoverflow.com.      201     IN      A       151.101.65.69
stackoverflow.com.      201     IN      A       151.101.129.69
stackoverflow.com.      201     IN      A       151.101.193.69

λ dig cdn.sstatic.net +noall +answer
; &lt;&lt;&gt;&gt; DiG 9.10.2-P3 &lt;&lt;&gt;&gt; cdn.sstatic.net +noall +answer
;; global options: +cmd
cdn.sstatic.net.        724     IN      A       151.101.193.69
cdn.sstatic.net.        724     IN      A       151.101.1.69
cdn.sstatic.net.        724     IN      A       151.101.65.69
cdn.sstatic.net.        724     IN      A       151.101.129.69
</code></pre><p>嘿，这些 IP 都是一致的，并且他们也拥有相同的证书！这意味着你可以直接使用 HTTP/2 的服务器推送功能，而无需影响 HTTP/1.1 用户。 HTTP/2 有推送的同时，HTTP/1.1 也有了<a href="https://blog.stackpath.com/glossary/domain-sharding/">域名共享</a>（通过 <code>sstatic.net</code>）。我们暂未部署服务器推送功能，但一切都尽在掌握之中。</p>
<p>HTTPS 是我们实现性能目标的一个手段。可以这么说，我们的主要目标是性能，而非站点安全性。我们想要安全性，但光是安全性不足以让我们花那么多精力来在全网部署 HTTPS。当我们把所有因素都考虑在一起的时候，我们可以评估出要完成这件事情需要付出的巨大的时间和精力。在 2013 年，HTTP/2 还没有扮演那么重要的角色。而现在形势变了，对其的支持也多了，最终这成为了我们花时间调研 HTTPS 的催化剂。</p>
<p>值得注意的是 HTTP/2 标准在我们项目进展时还在持续发生变化。它从 <a href="https://en.wikipedia.org/wiki/SPDY">SPDY</a> 演化为 <a href="https://en.wikipedia.org/wiki/HTTP/2">HTTP/2</a>，从 <a href="https://tools.ietf.org/id/draft-agl-tls-nextprotoneg-03.html">NPN</a> 演化为 <a href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">ALPN</a>。我们这里不会过多涉及到这部分细节，因为我们并没有为其做太多贡献。我们观望并从中获准，但整个互联网却在推进其向前发展。如果你感兴趣，可以看看 <a href="https://blog.cloudflare.com/introducing-http2/">Cloudflare 是怎么讲述其演变的</a>。</p>
<h3 id="haproxy支持-https">HAProxy：支持 HTTPS</h3>
<p>我们最早在 2013 年开始在 HAProxy 中使用 HTTPS。为什么是 <a href="https://www.haproxy.org/">HAProxy</a> 呢？这是历史原因，我们已经在使用它了，而它在 2013 年 的 <a href="https://www.haproxy.org/news.html">1.5 开发版</a>中支持了 HTTPS，并在 2014 年发布了正式版。曾经有段时间，我们把 Nginx 放置在 HAProxy 之前（<a href="https://nickcraver.com/blog/2013/04/23/stackoverflow-com-the-road-to-ssl/">详情看这里</a>）。但是简单些总是更好，我们总是想着要避免在链路、部署和其他问题上的复杂问题。</p>
<p>我不会探讨太多细节，因为也没什么好说的。HAProxy 在 1.5 之后使用 OpenSSL 支持 HTTPS，配置文件也是清晰易懂的。我们的配置方式如下：</p>
<ul>
<li>跑在 4 个进程上
<ul>
<li>1 个用来做 HTTP/前端处理</li>
<li>2-4 个用来处理 HTTPS 通讯</li>
</ul>
</li>
<li>HTTPS 前端使用 <a href="https://unix.stackexchange.com/a/206395/400">socket 抽象命名空间</a>来连接至 HTTP 后端，这样可以极大减少资源消耗</li>
<li>每一个前端或者每一「层」都监听了 :433 端口（我们有主、二级、websockets 及开发环境）</li>
<li>当请求进来的时候，我们在请求头上加入一些数据（也会移除掉一些你们发送过来的），再将其转发给 web 层</li>
<li>我们使用  <a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility">Mozilla 提供的加密套件</a>。注意，这和我们 CDN 用的不是同样的套件。</li>
</ul>
<p>HAProxy 比较简单，这是我们使用一个 SSL 证书来支持 :433 端口的第一步。事后看来，这也只是一小步。</p>
<p>这里是上面描述情况下的架构图，我们马上来说前面的那块云是怎么回事：</p>
<p><a href="../../static/images/upload_dropbox/201709/HTTPS-Layout.svg">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/HTTPS-Layout.svg" alt="Logical Architecture"  />


</a></p>
<h3 id="cdn代理层通过-cloudflare-和-fastly-优化延迟">CDN/代理层：通过 Cloudflare 和 Fastly 优化延迟</h3>
<p>我对 Stack Overflow <a href="https://nickcraver.com/blog/2016/02/17/stack-overflow-the-architecture-2016-edition/">架构</a><a href="https://stackexchange.com/performance">的效率</a>一直很自豪。我们很厉害吧？仅用一个数据中心和几个服务器就撑起了一个大型网站。不过这次不一样了。尽管效率这件事情很好，但是在延迟上就成了个问题。我们不需要那么多服务器，我们也不需要多地扩展（不过我们有一个灾备节点）。这一次，这就成为了问题。由于光速，我们（暂时）无法解决延迟这个基础性问题。我们听说有人已经在处理这个问题了，不过他们造的时间机器好像有点问题。</p>
<p>让我们用数字来理解延迟。赤道长度是 40000 公里（光绕地球一圈的最坏情况）。<a href="https://en.wikipedia.org/wiki/Speed_of_light">光速</a>在真空中是 299,792,458 米/秒。很多人用这个数字，但光纤并不是真空的。实际上光纤有 <a href="https://physics.stackexchange.com/q/80043/653">30-31% 损耗</a>，所以我们的这个数字是：(40,075,000 m) / (299,792,458 m/s * .70) = 0.191s，也就是说最坏情况下绕地球一圈是 191ms，对吧？不对。这假设的是一条理想路径，而实际上两个网络节点的之间几乎不可能是直线。中间还有路由器、交换机、缓存、处理器队列等各种各样的延迟。累加起来的延迟相当可观。</p>
<p>这些和 Stack Overflow 有什么关系呢？云主机的优势出来了。如果你用一家云供应商，你访问到的就是相对较近的服务器。但对我们来说不是这样，你离服务部署在纽约或丹佛（主备模式）越远，延迟就越高。而使用 HTTPS，在协商连接的时候需要一个额外的往返。这还是最好的情况（<a href="https://blog.cloudflare.com/introducing-0-rtt/">使用 0-RTT 优化 TLS 1.3</a>）。<a href="https://twitter.com/igrigorik">Ilya Grigorik</a> 的 <a href="https://istlsfastyet.com/">这个总结</a> 讲的很好。</p>
<p>来说 <a href="https://www.cloudflare.com/">Cloudflare</a> 和 <a href="https://www.fastly.com/">Fastly</a>。HTTPS 并不是闭门造车的一个项目，你看下去就会知道，我们还有好几个项目在并行。在搭建一个靠近用户的 HTTPS 终端（以降低往返时间）时，我们主要考虑的是：</p>
<ul>
<li>终端 HTTPS 支持</li>
<li>DDoS 防护</li>
<li>CDN 功能</li>
<li>与直连等同或更优的性能</li>
</ul>
<h3 id="优化代理层的准备客户端性能测试">优化代理层的准备：客户端性能测试</h3>
<p>开始正式启用终端链路加速之前，我们需要有性能测试报告。我们在浏览器搭好了一整套覆盖全链路性能数据的测试。 浏览器里可以通过 JavaScript 从 <a href="https://www.w3.org/TR/navigation-timing/"><code>window.performance</code></a> 取性能耗时。打开你浏览器的审查器，你可以亲手试一下。我们希望这个过程透明，所以从第一天开始就把详细信息<a href="https://teststackoverflow.com/">放在了 teststackoverflow.com</a> 上。这上面并没有敏感信息，只有一些由页面<em>直接</em>载入的 URI 和资源，以及它们的耗时。每一张记录下来的页面大概长这样：</p>
<p><a href="../../static/images/upload_dropbox/201709/HTTPS-Teststackoverflow.png">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/HTTPS-Teststackoverflow.png" alt="teststackoverflow.com"  />


</a></p>
<p>我们目前对 5% 的流量做性能监控。这个过程没有那么复杂，但是我们需要做的事情包括：</p>
<ol>
<li>把耗时转成 JSON</li>
<li>页面加载后上传性能测试数据</li>
<li>将性能测试上传给我们后台服务器</li>
<li>在 SQL Server 中使用 <a href="http://www.nikoport.com/columnstore/">clustered columnstore</a> 存储数据</li>
<li>使用 <a href="https://bosun.org/">Bosun</a> (具体是 <a href="https://github.com/bretcope/BosunReporter.NET">BosunReporter.NET</a>) 汇集数据</li>
</ol>
<p>最终的结果是我们有了一份来自于全球<em>真实</em>用户的很好的实时汇总。这些数据可供我们分析、监控、报警，以及用于评估变化。它大概长这样：</p>
<p><a href="../../static/images/upload_dropbox/201709/HTTPS-ClientTimings.png">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/HTTPS-ClientTimings.png" alt="Client Timings Dashboard"  />


</a></p>
<p>幸好，我们有持续的流量来获取数据以供我们决策使用，目前的量级是 50 亿，并且还在增长中。这些数据概览如下：</p>
<p><a href="../../static/images/upload_dropbox/201709/HTTPS-ClientTimingsDatabase.png">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/HTTPS-ClientTimingsDatabase.png" alt="Client Timings Database"  />


</a></p>
<p>OK，我们已经把基础工作准备好了，是时候来测试 CDN/代理层供应商了。</p>
<h3 id="cloudflare">Cloudflare</h3>
<p>我们评估了很多 CDN/DDoS 防护层供应商。最终选择了 <a href="https://www.cloudflare.com/">Cloudflare</a>，主要是考虑到他们的基础设施、快速响应、还有他们承诺的 <a href="https://www.cloudflare.com/website-optimization/railgun/">Railgun</a>。那么我们如何测试使用了 Cloudfalre 之后用户的真实效果？是否需要部署服务来获取用户数据？答案是不需要！</p>
<p>Stack Overflow 的数据量非常大：月 PV 过十亿。记得我们上面讲的客户端耗时纪录吗？我们每天都有几百万的访问了，所以不是直接可以问他们吗？我们是可以这么做，只需要在页面中嵌入 <code>&lt;iframe&gt;</code> 就行了。Cloudflare 已经是我们 <a href="https://cdn.sstatic.net/">cdn.sstatic.net</a>（我们共用的无 cookie 的静态内容域）的托管商了。但是这是通过一条<a href="https://en.wikipedia.org/wiki/CNAME_record"><code>CNAME</code> DNS 纪录</a>来做的，我们把 DNS 指向他们的 DNS。所以要用 Cloudflare 来当代理服务的话，我们需要他们指向我们的 DNS。所以我们先需要测试他们 DNS 的性能。</p>
<p>实际上，要测试性能我们需要把二级域名给他们，而不是 <code>something.stackoverflow.com</code>，因为这样可能会有不一致的<a href="https://wiki.gandi.net/en/glossary/glue-record">胶水记录</a>而导致多次查询。明确一下，<a href="https://en.wikipedia.org/wiki/Top-level_domain">一级域名 (TLDs)</a>指的是 <code>.com</code>, <code>.net</code>, <code>.org</code>, <code>.dance</code>, <code>.duck</code>, <code>.fail</code>, <code>.gripe</code>, <code>.here</code>, <code>.horse</code>, <code>.ing</code>, <code>.kim</code>, <code>.lol</code>, <code>.ninja</code>, <code>.pink</code>, <code>.red</code>, <code>.vodka</code>. 和 <code>.wtf</code>。 注意，<a href="https://en.wikipedia.org/wiki/List_of_Internet_top-level_domains">这些域名尾缀都是</a>，我可没开玩笑。 <a href="https://en.wikipedia.org/wiki/Second-level_domain">二级域名 (SLDs)</a> 就多了一级，比如 <code>stackoverflow.com</code>, <code>superuser.com</code> 等等。我们需要测的就是这些域名的行为及表现。因此，我们就有了 <code>teststackoverflow.com</code>，通过这个新域名，我们在全球范围内测试 DNS 性能。对一部分比例的用户，通过嵌一个 <code>&lt;iframe&gt;</code>（在测试中开关），我们可以轻松地获取用户访问 DNS 的相关数据。</p>
<p>注意，测试过程最少需要 24 小时。在各个时区，互联网的表现会随着用户作息或者 Netflix 的使用情况等发生变化。所以要测试一个国家，需要完整的一天数据。最好是在工作日（而不要半天落在周六）。我们知道会有各种意外情况。互联网的性能并不是稳定的，我们要通过数据来证明这一点。</p>
<p>我们最初的假设是，多增加了的一个节点会带来额外的延时，我们会因此损失一部分页面加载性能。但是 DNS 性能上的增加其实弥补了这一块。比起我们只有一个数据中心来说，Cloudflare 的 DNS 服务器部署在离用户更近的地方，这一块性能要好得多得多。我希望我们能有空来放出这一块的数据，只不过这一块需要很多处理（以及托管），而我现在也没有足够多的时间。</p>
<p>接下来，我们开始将 <code>teststackoverflow.com</code> 放在 Cloudflare 的代理上做链路加速，同样也是放在 <code>&lt;iframe&gt;</code> 中。我们发现美国和加拿大的服务由于多余的节点而变慢，但是世界其他地方都是持平或者更好。这满足我们的期望。我们开始使用 Cloudflare 的网络对接我们的服务。期间发生了一些 DDos 的攻击，不过这是另外的事了。那么，为什么我们接受在美国和加拿大地区慢一点呢？因为每个页面加载需要的时间仅为 200-300ms，哪怕慢一点也还是飞快。当时我们认为 <a href="https://www.cloudflare.com/website-optimization/railgun/">Railgun</a> 可以将这些损耗弥补回来。</p>
<p>这些测试完成之后，我们为了预防 DDos 工作，做了一些其他工作。我们接入了额外的 ISP 服务商以供我们的 CDN/代理层对接。毕竟如果能绕过攻击的话，我们没必要在代理层做防护。现在每个机房都有 4 个 ISP 服务商（译者注：相当于电信、联通、移动、教育网），两组路由器，他们之间使用 <a href="https://en.wikipedia.org/wiki/Border_Gateway_Protocol">BGP</a>协议。我们还额外添置了两组负载均衡器专门用于处理 CDN/代理层的流量。</p>
<p>Cloudflare: Railgun</p>
<p>与此配套，我们启用了两组 <a href="https://www.cloudflare.com/website-optimization/railgun/">Railgun</a>。Railgun 的原理是在 Cloudflare 那边，使用 <a href="https://memcached.org/">memcached</a> 匹配 URL 进行缓存数据。当 Railgun 启用的时候，每个页面（有一个大小阈值）都会被缓存下来。那么在下一次请求时候，如果在这个 URL 在 Cloudflare 节点上和我们这里都缓存的话，我们仍然会问 web 服务器最新的数据。但是我们不需要传输完整的数据，只需要把传输和上次请求的差异数据传给 Cloudflure。他们把这个差异运用于他们的缓存上，然后再发回给客户端。这时候， <a href="https://en.wikipedia.org/wiki/Gzip">gzip 压缩</a> 的操作也从 Stack Overflow 的 9 台 Web Server 转移到了一个 Railgun 服务上，这台服务器得是 CPU 密集型的——我指出这点是因为，这项服务需要评估、购买，并且部署在我们这边。</p>
<p>举个例子，想象一下，两个用户打开同一个问题的页面。从浏览效果来看，他们的页面技术上长得<em>几乎</em>一样，仅仅有细微的差别。如果我们大部分的传输内容只是一个 diff 的话，这将是一个巨大的性能提升。</p>
<p>总而言之，Railgun 通过减少大量数据传输的方式提高性能。当它顺利工作的时候确实是这样。除此之外，还有一个额外的优点：请求不会重置连接。由于 <a href="https://en.wikipedia.org/wiki/TCP_congestion_control#Slow_start">TCP 慢启动</a>，当连接环境较为复杂时候，可能导致连接被限流。而 Railgun 始终以固定的连接数连接到 Cloudflare 的终端，对用户请求采用了多路复用，从而其不会受慢启动影响。小的 diff 也减少了慢启动的开销。</p>
<p>很可惜，我们由于种种原因我们在使用 Railgun 过程中一直遇到问题。据我所知，我们拥有当时最大的 Railgun 部署规模，这把 Railgun 逼到了极限。尽管我们花了一年追踪各种问题，最终还是不得不放弃了。这种状况不仅没有给我们省钱，还耗费了更多的精力。现在几年过去了。如果你正在评估使用 Railgun，你最好看最新的版本，他们一直在做<a href="https://www.cloudflare.com/docs/railgun/changelog.html">优化</a>。我也建议你自己做决定是否使用 Railgun。</p>
<h3 id="fastly">Fastly</h3>
<p>我们最近才迁到 <a href="https://www.fastly.com/">Fastly</a>，因为我们在讲 CDN/代理层，我也会顺带一提。由于很多技术工作在 Cloudflare 那边已经完成，所以迁移本身并没有什么值得说的。大家会更感兴趣的是：为什么迁移？毕竟 Cloudflare 在各方面是不错的：丰富的数据中心、稳定的带宽价格、包含 DNS 服务。答案是：它不再是我们最佳的选择了。Flastly 提供了一些我们更为看中的特性：灵活的终端节点控制能力、配置快速分发、自动配置分发。并不是说 Cloudflare 不行，只是它不再适合 Stack Overflow 了。</p>
<p>事实胜于雄辩：如果我不认可 Cloudflare，我的私人博客不可能选择它，嘿，就是这个博客，你现在正在阅读的。</p>
<p>Fastly 吸引我们的主要功能是提供了 <a href="https://en.wikipedia.org/wiki/Varnish_(software)">Varnish</a> 和 <a href="https://docs.fastly.com/guides/vcl/">VCL</a>。这提供了高度的终端可定制性。有些功能吧，Cloudfalre 无法快速提供（因为他们是通用化的，会影响所有用户），在 Fastly 我们可以自己做。这是这两家架构上的差异，这种「代码级别高可配置」对于我们很适用。同时，我们也很喜欢他们在沟通、基础设施的开放性。</p>
<p>我来展示一个 VCL 好用在哪里的例子。最近我们遇到 .NET 4.6.2 的一个<a href="https://github.com/Microsoft/dotnet/issues/330">超恶心 bug</a>，它会导致 max-age 有超过 2000 年的缓存时间。快速解决方法是在终端节点上有需要的时候去覆盖掉这个头部，当我写这篇文章的时候，这个 VCL 配置是这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nginx" data-lang="nginx"><span class="line"><span class="cl"><span class="k">sub</span> <span class="s">vcl_fetch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kn">if</span> <span class="s">(beresp.http.Cache-Control)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kn">if</span> <span class="s">(req.url.path</span> <span class="p">~</span> <span class="sr">&#34;^/users/flair/&#34;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kn">set</span> <span class="s">beresp.http.Cache-Control</span> <span class="p">=</span> <span class="s">&#34;public,</span> <span class="s">max-age=180&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="kn">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kn">set</span> <span class="s">beresp.http.Cache-Control</span> <span class="p">=</span> <span class="s">&#34;private&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p>这将给用户能力展示页 3 分钟的缓存时间（数据量还好），其余页面都不设置。这是一个为解决紧急时间的非常便于部署的全局性解决方案。 我们很开心现在有能力在终端做一些事情。我们的 <a href="https://twitter.com/alioth">Jason Harvey</a> 负责 VCL 配置，并写了一些自动化推送的功能。我们基于一个 Go 的开源库 <a href="https://github.com/alienth/fastlyctl">fastlyctl</a> 做了开发。</p>
<p>另一个 Fastly 的特点是可以使用我们自己的证书，Cloudflare 虽然也有这个服务，但是费用太高。如我上文提到的，我们现在已经具备使用 HTTP/2 推送的能力。但是，Fastly 就不支持 DNS，这个在 Cloudflare 那里是支持的。现在我们需要自己解决 DNS 的问题了。可能最有意思的就是这些来回的折腾吧？</p>
<h3 id="全局-dns">全局 DNS</h3>
<p>当我们从 Cloudflare 迁移到 Fastly 时候，我们必须评估并部署一个新的 DNS 供应商。这里有篇 <a href="https://twitter.com/thefarseeker">Mark Henderson</a> 写的 <a href="http://blog.serverfault.com/2017/01/09/surviving-the-next-dns-attack/">文章</a> 。鉴于此，我们必须管理：</p>
<ul>
<li>我们自己的 DNS 服务器（备用）</li>
<li><a href="http://name.com/">Name.com</a> 的服务器（为了那些不需要 HTTPS 的跳转服务）</li>
<li>Cloudflare DNS</li>
<li>Route 53 DNS</li>
<li>Google DNS</li>
<li>Azure DNS</li>
<li>其他一些（测试时候使用）</li>
</ul>
<p>这个本身就是另一个项目了。为了高效管理，我们开发了 <a href="http://blog.serverfault.com/2017/04/11/introducing-dnscontrol-dns-as-code-has-arrived/">DNSControl</a>。这现在已经是<a href="https://stackexchange.github.io/dnscontrol/">开源项目了</a>，<a href="https://github.com/StackExchange/dnscontrol">托管在 GiHub</a> 上，使用 <a href="https://golang.org/">Go</a> 语言编写。 简而言之，每当我们推送 JavaScript 的配置到 git，它都会马上在全球范围里面部署好 DNS 配置。这里有一个简单的例子，我们拿 <a href="https://askubuntu.com/">askubuntu.com</a> 做示范：</p>
<pre tabindex="0"><code>D(&#39;askubuntu.com&#39;, REG_NAMECOM,
    DnsProvider(R53,2),
    DnsProvider(GOOGLECLOUD,2),
    SPF,
    TXT(&#39;@&#39;, &#39;google-site-verification=PgJFv7ljJQmUa7wupnJgoim3Lx22fbQzyhES7-Q9cv8&#39;), // webmasters
    A(&#39;@&#39;, ADDRESS24, FASTLY_ON),
    CNAME(&#39;www&#39;, &#39;@&#39;),
    CNAME(&#39;chat&#39;, &#39;chat.stackexchange.com.&#39;),
    A(&#39;meta&#39;, ADDRESS24, FASTLY_ON),
END)
</code></pre><p>太棒了，接下来我们就可以使用客户端响应测试工具来测试啦！<a href="#preparing-for-a-proxy-client-timings">上面提到的工具</a>可以实时告诉我们真实部署情况，而不是模拟数据。但是我们还需要测试所有部分都正常。</p>
<h3 id="测试">测试</h3>
<p>客户端响应测试的追踪可以方便我们做性能测试，但这个并不适合用来做配置测试。客户端响应测试非常适合展现结果，但是配置有时候并没有界面，所以我们开发了 <a href="https://godoc.org/github.com/StackExchange/httpunit">httpUnit</a> （后来知道<a href="http://httpunit.sourceforge.net/">这个项目重名了</a> ）。这也是一个使用 Go 语言的<a href="https://github.com/StackExchange/httpunit">开源项目</a>。以 <code>teststackoverflow.com</code> 举例，使用的配置如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ini" data-lang="ini"><span class="line"><span class="cl"><span class="k">[[plan]]</span>
</span></span><span class="line"><span class="cl">    <span class="na">label</span> <span class="o">=</span> <span class="s">&#34;teststackoverflow_com&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">    url = &#34;http://teststackoverflow.com&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">    ips = [&#34;28i&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s">    text = &#34;&lt;title&gt;Test Stack Overflow Domain&lt;/title&gt;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">    tags = [&#34;so&#34;]</span>
</span></span><span class="line"><span class="cl"><span class="k">[[plan]]</span>
</span></span><span class="line"><span class="cl">    <span class="na">label</span> <span class="o">=</span> <span class="s">&#34;tls_teststackoverflow_com&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">    url = &#34;https://teststackoverflow.com&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">    ips = [&#34;28&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s">    text = &#34;&lt;title&gt;Test Stack Overflow Domain&lt;/title&gt;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">    tags = [&#34;so&#34;]</span>
</span></span></code></pre></div><p>每次我们更新一下防火墙、证书、绑定、跳转时都有必要测一下。我们必须保证我们的修改不会影响用户访问（先在预发布环境进行部署）。 httpUnit 就是我们来做集成测试的工具。</p>
<p>我们还有一个开发的内部工具（由亲爱的 <a href="https://twitter.com/yesthattom">Tom Limoncelli</a> 开发），用来管理我们负载均衡上面的 <a href="https://en.wikipedia.org/wiki/Virtual_IP_address">VIP 地址</a> 。我们先在一个备用负载均衡上面测试完成，然后将所有流量切过去，让之前的主负载均衡保持一个稳定状态。如果期间发生任何问题，我们可以轻易回滚。如果一切顺利，我们就把这个变更应用到那台负载均衡上。这个工具叫做 <code>keepctl</code>（keepalived control 的简称），时间允许的话很快就会整理开源出来。</p>
<h3 id="应用层准备">应用层准备</h3>
<p>上面提到的只是架构方面的工作。这通常是由 <a href="http://stackoverflow.com/company/team#Engineering">Stack Overflow 的几名网站可靠性工程师</a>组成的团队完成的。而应用层也有很多需要完成的工作。这个列表会很长，先让我拿点咖啡和零食再慢慢说。</p>
<p>很重要的一点是，<a href="https://nickcraver.com/blog/2016/02/17/stack-overflow-the-architecture-2016-edition/">Stack Overflow 与 Stack Exchange 的架构</a> Q&amp;A 采用了<a href="https://en.wikipedia.org/wiki/Multitenancy">多租户技术</a>。这意味着如果你访问 <code>stackoverflow.com</code> 或者 <code>superuser.com</code> 又或者 <code>bicycles.stackexchange.com</code>，你返回到的其实是同一台服务器上的同一个 <code>w3wp.exe</code> 进程。我们通过浏览器发送的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host"><code>Host</code> 请求头</a>来改变请求的上下文。为了更好地理解我们下文中提到的一些概念，你需要知道我们代码中的 <code>Current.Site</code> 其实指的是 <em>请求</em> 中的站点。<code>Current.Site.Url()</code> 和 <code>Current.Site.Paths.FaviconUrl</code> 也是基于同样的概念。</p>
<p>换一句话说：我们的 Q&amp;A 全站都是跑在同一个服务器上的同一个进程，而用户对此没有感知。我们在九台服务器上每一台跑一个进程，只是为了发布版本和冗余的问题。</p>
<p>全局登录</p>
<p>整个项目中有一些看起来可以独立出来（事实上也是），不过也同属于整个大 HTTPS 迁移中的一部分。登录就是其中一个项目。我首先来说说这个，因为这比别它变化都要早上线。</p>
<p>在 Stack Overflow（及 Stack Exchange）的头五六年里，你登录的是一个个的独立网站。比如，<code>stackoverflow.com</code>、<code>stackexchange.com</code> 以及 <code>gaming.stackexchange.com</code> 都有它们自己的 cookies。值得注意的是：<code>meta.gaming.stackexchange.com</code> 的登录 cookie 是从 <code>gaming.stackexchange.com</code> 带过来的。这些是我们上面讨论证书时提到的 meta 站点。他们的登录信息是相关联的，你只能通过父站点登录。在技术上说并没有什么特别的，但考虑到用户体验就很糟糕了。你必须一个一个站登录。我们用「全局认证」的方法来<a href="https://stackoverflow.blog/2010/09/11/global-network-auto-login/">「修复」了这个问题</a>，方法是在页面上放一个 <code>&lt;iframe&gt;</code>，内面访问一下 <code>stackauth.com</code>。如果用户在别处登录过的话，它也会在这个站点上登录，至少会去试试。这个体验还行，但是会有弹出框问你是否点击重载以登录，这样就又不是太好。我们可以做得更好的。对了，你也可以去问问 <a href="https://twitter.com/kevinmontrose">Kevin Montrose</a> 关于移动 Safari 的匿名模式，你会震惊的。</p>
<p>于是我们有了「通用登录」。为什么用「通用」这个名字？因为我们已经用过「全局」了。我们就是如此单纯。所幸 cookies 也很单纯的东西。父域名里的 cookie（如 <code>stackexchange.com</code>）在你的浏览器里被带到所有子域名里去（如 <code>gaming.stackexchange.com</code>）。如果我们只二级域名的话，其实我们的域名并不多：</p>
<ul>
<li><a href="https://askubuntu.com/">askubuntu.com</a></li>
<li><a href="https://mathoverflow.net/">mathoverflow.net</a></li>
<li><a href="https://serverfault.com/">serverfault.com</a></li>
<li><a href="https://stackapps.com/">stackapps.com</a></li>
<li><a href="https://stackexchange.com/">stackexchange.com</a></li>
<li><a href="https://stackoverflow.com/">stackoverflow.com</a></li>
<li><a href="https://superuser.com/">superuser.com</a></li>
</ul>
<p>是的，我们有一些域名是跳转到上面的列表中的，比如 <a href="http://askdifferent.com/">askdifferent.com</a>。但是这些只是跳转而已，它们没有 cookies 也无需登录。</p>
<p>这里有很多细节的后端工作我没有提（归功于 <a href="https://twitter.com/superdalgas">Geoff Dalgas</a> 和 <a href="https://twitter.com/aalear">Adam Lear</a>），但大体思路就是，当你登录的时候，我们把这些域名都写入一个 cookie。我们是通过第三方的 cookie 和<a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">随机数</a>来做的。当你登录其中任意一个网站的时候，我们在页面上都会放 6 个 <code>&lt;img&gt;</code> 标签来往其它域名写入 cookie，本质上就完成了登录工作。这并不能在 <em>所有情况</em> 下都适用（尤其是移动 Safari 简直是要命了），但和之前比起来那是好得多了。</p>
<p>客户端的代码不复杂，基本上长这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">$</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/users/login/universal/request&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">$</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arrayId</span><span class="p">,</span> <span class="nx">group</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="s1">&#39;//&#39;</span> <span class="o">+</span> <span class="nx">group</span><span class="p">.</span><span class="nx">Host</span> <span class="o">+</span> <span class="s1">&#39;/users/login/universal.gif?authToken=&#39;</span> <span class="o">+</span> 
</span></span><span class="line"><span class="cl">            <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">group</span><span class="p">.</span><span class="nx">Token</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&amp;nonce=&#39;</span> <span class="o">+</span> <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">group</span><span class="p">.</span><span class="nx">Nonce</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nx">$</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="err"> </span><span class="p">)</span> <span class="p">{</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#footer&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;&lt;img style=&#34;display:none&#34; src=&#34;&#39;</span> <span class="o">+</span> <span class="nx">url</span> <span class="o">+</span> <span class="s1">&#39;&#34;&gt;&lt;/img&gt;&#39;</span><span class="p">);</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="s1">&#39;json&#39;</span><span class="p">);</span>
</span></span></code></pre></div><p>但是要做到这点，我们必须上升到账号级别的认证（之前是用户级别）、改变读取 cookie 的方式、改变这些 meta 站的登录工作方式，同时还要将这一新的变动整合到其它应用中。比如说，Careers（现在拆成了 Talent 和 Jobs）用的是另一份代码库。我们需要让这些应用读取相应的 cookies，然后通过 API 调用 Q&amp;A 应用来获取账户。我们部署了一个 NuGet 库来减少重复代码。底线是：你在一个地方登录，就在所有域名都登录。不弹框，不重载页面。</p>
<p>技术的层面上看，我们不用再关心 <code>*.*.stackexchange.com</code> 是什么了，只要它们是 <code>stackexchange.com</code> 下就行。这看起来和 HTTPS 没有关系，但这让我们可以把 <code>meta.gaming.stackexchange.com</code> 变成 <code>gaming.meta.stackexchange.com</code> 而不影响用户。</p>
<p>本地 HTTPS 开发</p>
<p>要想做得更好的话，本地环境应该尽量与开发和生产环境保持一致。幸好我们用的是 IIS，这件事情还简单的。我们使用一个工具来设置开发者环境，这个工具的名字叫「本地开发设置」——单纯吧？它可以安装工具（Visual Studio、git、SSMS 等）、服务（SQL Server、Redis、Elasticsearch）、仓库、数据库、网站以及一些其它东西。做好了基本的工具设置之后，我们要做的只是添加 SSL/TLS 证书。主要的思路如下：</p>
<pre tabindex="0"><code>Websites = @(
    @{
        Directory = &#34;StackOverflow&#34;;
        Site = &#34;local.mse.com&#34;;
        Aliases = &#34;discuss.local.area51.lse.com&#34;, &#34;local.sstatic.net&#34;;
        Databases = &#34;Sites.Database&#34;, &#34;Local.StackExchange.Meta&#34;, &#34;Local.Area51&#34;, &#34;Local.Area51.Meta&#34;;
        Certificate = $true;
    },
    @{
        Directory = &#34;StackExchange.Website&#34;;
        Site = &#34;local.lse.com&#34;;
        Databases = &#34;Sites.Database&#34;, &#34;Local.StackExchange&#34;, &#34;Local.StackExchange.Meta&#34;, &#34;Local.Area51.Meta&#34;;
        Certificate = $true;
    }
)
</code></pre><p>我把使用到的代码<a href="https://gist.github.com/NickCraver/6b5e75c153d60d0df5b0970d52412d4e">放在了一个 gist 上：<code>Register-Websites.psm1</code></a>。我们通过 host 头来设置网站（通过别名添加），如果直连的话就给它一个证书（嗯，现在应该把这个行为默认改为 <code>$true</code> 了），然后允许 AppPool 账号来访问数据库，于是我们本地也在使用 <code>https://</code> 开发了。嗯，我知道我们应该把这个设置过程开源出来，不过我们仍需去掉一些专有的业务。会有这么一天的。</p>
<p><strong>为什么这件事情很重要？</strong> 在此之前，我们从 <code>/content</code> 加载静态内容，而不是从另一个域名。这很方便，但也隐藏了类似于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">跨域请求（CORS）</a>的问题。在同一个域名下用同一个协议能正常加载的资源，换到开发或者生产环境下就有可能出错。<a href="https://blog.codinghorror.com/the-works-on-my-machine-certification-program/">「在我这里是好的。」</a></p>
<p>当我们使用和生产环境中同样协议以及同样架构的 CDN 还有域名设置时，我们就可以在开发机器上找出并修复更多的问题。比如，你是否知道，从 <code>https://</code> 跳转到 <code>http://</code> 时，<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3">浏览器是不会发送 referer</a> 的？这是一个安全上的问题，referer 头中可能带有以明文传输的敏感信息。</p>
<p>「Nick 你就扯吧，我们能拿到从 Google 拿到 referer 啊！」确实。但是这是因为他们<em>主动选择这一行为</em>。如果你看一下 Google 的搜索页面，你可以看到这样的 <code>&lt;meta&gt;</code> 指令：</p>
<pre><code>&lt;meta content=&quot;origin&quot; id=&quot;mref&quot; name=&quot;referrer&quot;&gt;
</code></pre>
<p>这也就是为什么你可以取到 referer。</p>
<p>好的，我们已经设置好了，现在该做些什么呢？</p>
<h3 id="混合内容来自于你们">混合内容：来自于你们</h3>
<p>混合内容是个筐，什么都能往里装。我们这些年下来积累了哪些混合内容呢？不幸的是，有很多。这个列表里我们必须处理的用户提交内容：</p>
<ul>
<li><code>http://</code> 图片，出现在<a href="https://stackoverflow.com/questions">问题</a>、答案、<a href="https://stackoverflow.com/tags">标签</a>、wiki 等内容中使用</li>
<li><code>http://</code> 头像</li>
<li><code>http://</code> 头像，出现在聊天中（站点侧边栏）</li>
<li><code>http://</code> 图片，出现于个人资料页的「关于我」部分</li>
<li><code>http://</code> 图片，出现于<a href="https://stackoverflow.com/help">帮助中心的文章中</a></li>
<li><code>http://</code> YouTube 视频（有些站点启用了，比如 <a href="https://gaming.stackexchange.com/">gaming.stackexchange.com</a>）</li>
<li><code>http://</code> 图片，出现于<a href="https://stackoverflow.com/help/privileges">特权描述中</a></li>
<li><code>http://</code> 图片，出现于<a href="http://stackoverflow.com/users/story/13249">开发者故事中</a></li>
<li><code>http://</code> 图片，出现于<a href="https://stackoverflow.com/jobs">工作描述中</a></li>
<li><code>http://</code> 图片，出现于<a href="https://stackoverflow.com/jobs/companies">公司页面中</a></li>
<li><code>http://</code> 源地址，出现在<a href="https://meta.stackoverflow.com/q/269753/13249"> JavaScript 代码中</a>.</li>
</ul>
<p>上面的每一个都带有自己独有的问题，我仅仅会覆盖一下值得一提的部分。注意：我谈论的每一个解决方案都必须扩展到我们这个架构下的几百个站点和数据库上。</p>
<p>在上面的所有情况中（除了代码片段），要消除混合内容的第一步工作就是：你必须先消除<em>新</em>的混合内容。否则，这个清理过程将会无穷无尽。要做到这一点，<a href="https://meta.stackexchange.com/q/291947/135201">我们开始全网强制仅允许内嵌 <code>https://</code> 图片</a>。一旦这个完成之后，我们就可以开始清理了。</p>
<p>对于问题、答案以及其他帖子形式中，我们需要具体问题具体分析。我们先来搞定 90% 以上的情况：<code>stack.imgur.com</code>。在我来之前 Stack Overflow 就已经有自己托管的 Imgur 实例了。你在编辑器中上传的图片就会传到那里去。绝大部分的帖子都是用的这种方法，而他们几年前就为我们添加了 HTTPS 支持。所以这个就是一个很直接的查找替换（我们称为帖子 markdown 重处理）。</p>
<p>然后我们通过通过 <a href="https://www.elastic.co/">Elasticsearch</a> 对所有内容的索引来找出所有剩下的文件。我说的我们其实指的是 <a href="https://twitter.com/m0sa">Samo</a>。他在这里处理了大量的混合内容工作。当我们看到大部分的域名其实已经支持 HTTPS 了之后，我们决定：</p>
<ol>
<li>对于每个 <code>&lt;img&gt;</code> 的源地址都尝试替换成 <code>https://</code>。如果能正常工作则替换帖子中的链接</li>
<li>如果源地址不支持 <code>https://</code>，将其转一个链接</li>
</ol>
<p>当然，并没有那么顺利。我们发现用于匹配 URL 的正则表达式其实已经坏了好几年了，并且没有人发现……所以我们修复了正则，重新做了索引。</p>
<p>有人问我们：「为什么不做个代理呢？」呃，从法律和道德上来说，代理对我们的内容来说是个灰色地带。比如，我们 <a href="https://photo.stackexchange.com/">photo.stackexchange.com</a> 上的摄像师会明确声明不用 Imgur 以保留他们的权利。我们充分理解。如果我们开始代理并缓存<em>全图</em>，这在法律上有点问题。我们后来发现在几百万张内嵌图片中，只有几千张即不支持 <code>https://</code> 也没有 404 失效的。这个比例（低于 1%）不足于让我们去搭一个代理。</p>
<p>我们确实<em>研究过</em>搭一个代理相关的问题。费用有多少？需要多少存储？我们的带宽足够吗？我们有了一个大体上的估算，当然有点答案也不是很确定。比如我们是否要用 Fastly，还是直接走运营商？哪一种比较快？哪一种比较便宜？哪一种可以扩展？这个足够写另一篇博客了，如果你有具体问题的话可以在评论里提出，我会尽力回答。</p>
<p>所幸，在这个过程中，为了解决几个问题，<a href="https://twitter.com/balpha">balpha</a> 更改了用 HTML5 嵌入 YouTube 的方式。我们也就顺便强制了一下 YouTube 的 <code>https://</code> 嵌入。</p>
<p>剩下的几个内容领域的事情差不多：先阻止新的混合内容进来，再替换掉老的。这需要我们在下面几个领域进行更改：</p>
<ul>
<li>帖子</li>
<li>个人资料</li>
<li>开发故事</li>
<li>帮助中心</li>
<li>职场</li>
<li>公司业务</li>
</ul>
<p>声明：JavaScript 片段的问题仍然没有解决。这个有点难度的原因是：</p>
<ol>
<li>资源有可能不以 <code>https://</code> 的方式存在（比如一个库）</li>
<li>由于这个是 JavaScript，你可以自己构建出任意的 URL。这里我们就无力检查了。
<ul>
<li>如果你有更好的方式来处理这个问题，<strong>请告诉我们</strong>。我们在可用性与安全性上不可兼得。</li>
</ul>
</li>
</ol>
<h3 id="混合内容来自我们">混合内容：来自我们</h3>
<p>并不是处理完用户提交的内容就解决问题了。我们自己还是有不少 <code>http://</code> 的地方需要处理。这些更改本身没什么特别的，但是这至少能解答「为什么花了那么长时间？」这个问题：</p>
<ul>
<li>广告服务（Calculon）</li>
<li>广告服务（Adzerk）</li>
<li>标签赞助商</li>
<li>JavaScript 假定</li>
<li>Area 51（这代码库也太老了）</li>
<li>分析跟踪器（Quantcast, GA）</li>
<li>每个站点引用的 JavaScript（社区插件）</li>
<li><code>/jobs</code> 下的所有东西（这其实是个代理）</li>
<li>用户能力</li>
<li>……还有代码中所有出现 <code>http://</code> 的地方</li>
</ul>
<p>JavaScript 和链接比较令人痛苦，所以我在这里稍微提一下。</p>
<p>JavaScript 是一个不少人遗忘的角落，但这显然不能被无视。我们不少地方将主机域名传递给 JavaScript 时假定它是 <code>http://</code> ，同时也有不少地方写死了 meta 站里的 <code>meta.</code> 前缀。很多，真的很多，救命。还好现在已经不这样了，我们现在用服务器渲染出一个站点，然后在页面顶部放入相应的选择：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">StackExchange</span><span class="p">.</span><span class="nx">init</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;locale&#34;</span><span class="o">:</span><span class="s2">&#34;en&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;stackAuthUrl&#34;</span><span class="o">:</span><span class="s2">&#34;https://stackauth.com&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;site&#34;</span><span class="o">:</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;name&#34;</span><span class="o">:</span><span class="s2">&#34;Stack Overflow&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;childUrl&#34;</span><span class="o">:</span><span class="s2">&#34;https://meta.stackoverflow.com&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;protocol&#34;</span><span class="o">:</span><span class="s2">&#34;http&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;user&#34;</span><span class="o">:</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;gravatar&#34;</span><span class="o">:</span><span class="s2">&#34;&lt;div class=\&#34;gravatar-wrapper-32\&#34;&gt;&lt;img src=\&#34;https://i.stack.imgur.com/nGCYr.jpg\&#34;&gt;&lt;/div&gt;&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;profileUrl&#34;</span><span class="o">:</span><span class="s2">&#34;https://stackoverflow.com/users/13249/nick-craver&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>这几年来我们在代码里也用到了很多静态链接。比如，在页尾，在页脚，在帮助区域……到处都是。对每一个来说，解决方式都不复杂：把它们改成 <code>&lt;site&gt;.Url(&quot;/path&quot;)</code> 的形式就好了。不过要找出这些链接有点意思，因为你不能直接搜 <code>&quot;http://&quot;</code>。感谢 W3C 的丰功伟绩：</p>
<pre tabindex="0"><code>&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34;...
</code></pre><p>是的，这些是标识符，是不能改的。所以我希望 Visual Studio 在查找文件框中增加一个「排除文件类型」的选项。Visual Studio 你听见了吗？VS Code 前段时间就加了这个功能。我这要求不过分。</p>
<p>这件事情很枯燥，就是在代码中找出一千个链接然后替换而已（包括注释、许可链接等）。但这就是人生，我们必须要做。把这些链接改成 <code>.Url()</code> 的形式之后，一旦站点支持 HTTPS 的时候，我们就可以让链接动态切换过去。比如我们得等到 <code>meta.*.stackexchange.com</code> 搬迁完成之后再进行切换。插播一下我们数据中心的密码是「煎饼馃子」拼音全称，应该没有人会读到这里吧，所以在这里存密码很安全。当站点迁完之后，<code>.Url()</code> 仍会正常工作，然后用 <code>.Url()</code> 来渲染默认为 HTTPS 的站点也会继续工作。这将静态链接变成了动态。</p>
<p>另一件重要的事情：这让我们的开发和本地环境都能正常工作，而不仅仅是链到生产环境上。这件事情虽然枯燥，但还是值得去做的。对了，因为我们的规范网址（canonical）也通过 <code>.Url()</code> 来做了，所以一旦用户开始用上 HTTPS，Google 也可以感知到。</p>
<p>一旦一个站点迁到 HTTPS 之后，我们会让爬虫来更新站点链接。我们把这个叫修正「Google 果汁」，同时这也可以让用户不再碰到 301。</p>
<h3 id="跳转301">跳转（301）</h3>
<p>当你把站点移动到 HTTPS 之后，为了和 Google 配合，你有两件重要的事情要做：</p>
<ul>
<li>更新规范网址，比如 <code>&lt;link rel=&quot;canonical&quot; href=&quot;https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454&quot; /&gt;</code></li>
<li>把 <code>http://</code> 链接通过 301 跳转至 <code>https://</code></li>
</ul>
<p>这个不复杂，也不是浩大的工程，但这非常<em>非常</em>重要。Stack Overflow 大部分的流量都是从 Google 搜索结果中过来的，所以我们得保证这个不产生负面影响。这个是我们的生计，如果我们因此丢了流量那我真是要失业了。还记得那些 <code>.internal</code> 的 API 调用吗？对，我们同样不能把<em>所有东西</em>都进行跳转。所以我们在处理跳转的时候需要一定的逻辑（比如我们也不能跳转 <code>POST</code> 请求，因为浏览器处理得不好），当然这个处理还是比较直接的。这里是实际上用到的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">public</span> <span class="kr">static</span> <span class="k">void</span> <span class="nx">PerformHttpsRedirects</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">https</span> <span class="o">=</span> <span class="nx">Settings</span><span class="p">.</span><span class="nx">HTTPS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If we&#39;re on HTTPS, never redirect back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">Request</span><span class="p">.</span><span class="nx">IsSecureConnection</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Not HTTPS-by-default? Abort.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">https</span><span class="p">.</span><span class="nx">IsDefault</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Not supposed to redirect anyone yet? Abort.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">https</span><span class="p">.</span><span class="nx">RedirectFor</span> <span class="o">==</span> <span class="nx">SiteSettings</span><span class="p">.</span><span class="nx">RedirectAudience</span><span class="p">.</span><span class="nx">NoOne</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Don&#39;t redirect .internal or any other direct connection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...as this would break direct HOSTS to webserver as well
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">RequestIPIsInternal</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Only redirect GET/HEAD during the transition - we&#39;ll 301 and HSTS everything in Fastly later
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">string</span><span class="p">.</span><span class="nx">Equals</span><span class="p">(</span><span class="nx">Request</span><span class="p">.</span><span class="nx">HttpMethod</span><span class="p">,</span> <span class="s2">&#34;GET&#34;</span><span class="p">,</span> <span class="nx">StringComparison</span><span class="p">.</span><span class="nx">InvariantCultureIgnoreCase</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">||</span> <span class="nx">string</span><span class="p">.</span><span class="nx">Equals</span><span class="p">(</span><span class="nx">Request</span><span class="p">.</span><span class="nx">HttpMethod</span><span class="p">,</span> <span class="s2">&#34;HEAD&#34;</span><span class="p">,</span> <span class="nx">StringComparison</span><span class="p">.</span><span class="nx">InvariantCultureIgnoreCase</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Only redirect if we&#39;re redirecting everyone, or a crawler (if we&#39;re a crawler)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">https</span><span class="p">.</span><span class="nx">RedirectFor</span> <span class="o">==</span> <span class="nx">SiteSettings</span><span class="p">.</span><span class="nx">RedirectAudience</span><span class="p">.</span><span class="nx">Everyone</span>
</span></span><span class="line"><span class="cl">            <span class="o">||</span> <span class="p">(</span><span class="nx">https</span><span class="p">.</span><span class="nx">RedirectFor</span> <span class="o">==</span> <span class="nx">SiteSettings</span><span class="p">.</span><span class="nx">RedirectAudience</span><span class="p">.</span><span class="nx">Crawlers</span> <span class="o">&amp;&amp;</span> <span class="nx">Current</span><span class="p">.</span><span class="nx">IsSearchEngine</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">var</span> <span class="nx">resp</span> <span class="o">=</span> <span class="nx">Context</span><span class="p">.</span><span class="nx">InnerHttpContext</span><span class="p">.</span><span class="nx">Response</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 301 when we&#39;re really sure (302 is the default)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="nx">https</span><span class="p">.</span><span class="nx">RedirectVia301</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">resp</span><span class="p">.</span><span class="nx">RedirectPermanent</span><span class="p">(</span><span class="nx">Site</span><span class="p">.</span><span class="nx">Url</span><span class="p">(</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Url</span><span class="p">.</span><span class="nx">PathAndQuery</span><span class="p">),</span> <span class="kc">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">resp</span><span class="p">.</span><span class="nx">Redirect</span><span class="p">(</span><span class="nx">Site</span><span class="p">.</span><span class="nx">Url</span><span class="p">(</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Url</span><span class="p">.</span><span class="nx">PathAndQuery</span><span class="p">),</span> <span class="kc">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">Context</span><span class="p">.</span><span class="nx">InnerHttpContext</span><span class="p">.</span><span class="nx">ApplicationInstance</span><span class="p">.</span><span class="nx">CompleteRequest</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意我们并不是默认就跳 301（有一个 <code>.RedirectVia301</code> 设置)，因为我们做一些会产生永久影响的事情之前必须仔细测试。我们会<a href="#hsts-preloading">晚一点</a>来讨论 <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HSTS</a> 以及后续影响。</p>
<h3 id="websockets">Websockets</h3>
<p>这一块会过得快一点。Websocket 不难，从某种角度来说，这是我们做过的最简单的事情。我们用 websockets 来处理实时的用户影响力变化、收件箱通知、新问的问题、新增加的答案等等。这也就说基本上每开一个 Stack Overflow 的页面，我们都会有一个对应的 websocket 连接连到我们的负载均衡器上。</p>
<p>所以怎么改呢？其实很简单：安装一个证书，监听 <code>:443</code> 端口，然后用 <code>wss://qa.sockets.stackexchange.com</code> 来代替 <code>ws://</code> 。后者其实早就做完了（我们用了一个专有的证书，但是这不重要）。从 <code>ws://</code> 到 <code>wss://</code> 只是配置一下的问题。一开始我们还用 <code>ws://</code> 作为 <code>wss://</code> 的备份方案，不过后来就变成<em>仅用</em> <code>wss://</code> 了。这么做有两个原因：</p>
<ol>
<li>不用的话在 <code>https://</code> 下面会有混合内容警告</li>
<li>可以支持更多用户。因为很多老的代理不能很好地处理 websockets。如果使用加密流量，大多数代理就只是透传而不会弄乱流量。对移动用户来说尤其是这样。</li>
</ol>
<p>最大的问题就是：「我们能处理了这个负载吗？」我们全网处理了不少并发 websocket，在我写这估的时候我们有超过 600000 个<strong>并发</strong>的连接。这个是我们 HAProxy 的仪表盘在 <a href="https://github.com/opserver/Opserver">Opserver</a> 中的界面：</p>
<p><a href="../../static/images/upload_dropbox/201709/HTTPS-Websockets.png">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/HTTPS-Websockets.png" alt="HAProxy Websockets"  />


</a></p>
<p>不管是在终端、抽象命名空间套接字还是前端来说都有很多连接。由于启用了 <a href="https://tools.ietf.org/html/rfc5077">TLS 会话恢复</a>，HAProxy 本身的负载也很重。要让用户下一次重新连接更快，第一次协商之后用户会拿到一个令牌，下一次会把这个令牌发送过来。如果我们的内存足够并且没有超时，我们会恢复上次的会话而不是再开一个。这个操作可以节省 CPU，对用户来说有性能提升，但会用到到更多内存。这个多因 key 大小而异（2048，4096 或是更多？）我们现在用的是 4096 位的 key。在开了 600000 个 websocket 的情况下，我们只用掉了负载均衡器 64GB 内存里的 19GB。这里面 12GB 是 HAProxy 在用，大多数为 TLS 会话缓存。所以结果来说还不错，如果<em>我们不得不买内存的话</em>，这也会是整个 HTTPS 迁移中最便宜的东西。</p>
<p><a href="../../static/images/upload_dropbox/201709/HTTPS-WebsocketMemory.png">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/HTTPS-WebsocketMemory.png" alt="HAProxy Websocket Memory"  />


</a></p>
<h3 id="未知">未知</h3>
<p>我猜现在可能是我们来谈论一些未知问题的时候。有些问题是在我们尝试之前无法真正知道的：</p>
<ul>
<li>Google Analytics 里的流量表现怎么样？（我们会失去 referer 吗？）</li>
<li>Google Webmasters 的转换是否平滑？（301 生效吗？规范域名呢？要多长时间？）</li>
<li>Google 搜索分析会怎么工作（我们会在搜索分析中看到 <code>https://</code> 吗？）</li>
<li>我们搜索排名会下降吗？（最恐怖的）</li>
</ul>
<p>有很多人都谈过他们转化成 <code>https://</code> 的心得，但对我们却有点不一样。我们不是一个站点。我们是多个域名下的多个站点。我们不知道 Google 会怎么对待我们的网络。它会知道 <code>stackoverflow.com</code> 和 <code>superuser.com</code> 有关联吗？不知道。我们也不能指望 Google 来告诉我们这些。</p>
<p>所以我们就做测试。在我们<a href="https://meta.stackexchange.com/q/292058/135201">全网发布</a> 中，我们测试了几个域名：</p>
<ul>
<li><a href="https://meta.stackexchange.com/">meta.stackexchange.com</a></li>
<li><a href="https://security.stackexchange.com/">security.stackexchange.com</a></li>
<li><a href="https://superuser.com/">superuser.com</a></li>
</ul>
<p>对，这些是 Samo 和我会了仔细讨论出来的结果，花了有三分钟那么久吧。Meta 是因为这是我们最重要的反馈网站。Security 站上有很多专家可能会注意到相关的问题，特别是 HTTPS 方面。最后一个，Super User，我们需要知道搜索对我们内容的影响。比起 meta 和 security 来说法，Super User 的流量要大得多。最重要的是，它有<em>来自 Google</em> 的原生流量。</p>
<p>我们一直在观察并评估搜索的影响，所以 Super User 上了之后其他网站过了很久才跟上。到目前为止我们能说的是：基本上没影响。搜索、结果、点击还有排名的周变化都在正常范围内。我们公司<em>依赖</em>于这个流量，这对我们真的很重要。所幸，没有什么值得我们担心的点，我们可以继续发布。</p>
<h3 id="错误">错误</h3>
<p>如果不提到我们搞砸的部分，这篇文章就还不够好。错误永远是个选择。让我们来总结一下这一路让我们后悔的事情：</p>
<h4 id="错误相对协议-url">错误：相对协议 URL</h4>
<p>如果你的一个资源有一个 URL 的话，一般来说你会看到一些 <code>http://example.com</code> 或者 <code>https://example.com</code> 之类的东西，包括我们图片的路径等等。另一个选项就是你可以使用 <code>//example.com</code>。这被称为<a href="https://en.wikipedia.org/wiki/Wikipedia:Protocol-relative_URL">相对协议 URL</a>。我们很早之前就在图片、JavaScript、CSS 等中这么用了（我们自有的资源，不是指用户提交）。几年后，我们发现这不是一个好主意，至少对我们来说不是。相对协议链接中的「相对」是<em>对于页面而言</em>。当你在 <code>http://stackoverflow.com</code> 时，<code>//example.com</code> 指的是 <code>http://example.com</code>；如果你在 <code>https://stackoverflow.com</code> 时，就和 <code>https://example.com</code> 等同。那么这个有什么问题呢？</p>
<p>问题在于，图片 URL 不仅是用在页面中，它们还用在邮件、API 还有移动应用中。当我们理了一下路径结构然后在到处都使用图片路径时我们发现不对了。虽然这个变化极大降低了代码冗余，并且简化了很多东西，结果却是我们在邮件中使用了相对 URL。绝大多数邮件客户端都不能处理相对协议 URL 的图片。因为它们不知道是什么协议。Email 不是 <code>http://</code> 也不是 <code>https://</code>。只有你在浏览器里查看邮件，有可能是预期的效果。</p>
<p>那该怎么办？我们把所有的地方都换成了 <code>https://</code>。我把我们所有的路径代码统一到两个变量上：CDN 根路径，和对应特定站点的文件夹。例如 Stack Overflow 的样式表在 <a href="https://cdn.sstatic.net/Sites/stackoverflow/all.css"><code>https://cdn.sstatic.net/Sites/stackoverflow/all.css</code></a> 上（当然我们有缓存中断器），换成本地就是 <code>https://local.sstatic.net/Sites/stackoverflow/all.css</code>。你能看出其中的共同点。通过拼接路径，逻辑简单了不少。则　通过强制 <code>https://</code>，用户还可以在整站切换之前就享受 HTTP/2 的好处，因为所有静态资源都已经就位。都用 <code>https://</code> 也表示我们可以在页面、邮件、移动还有 API 上使用<strong>同一个</strong>属性。这种统一也意味着我们有一个固定的地方来处理所有路径——我们到处都有缓存中断器。</p>
<p>注意：如果你像我们一样中断缓存，比如 <code>https://cdn.sstatic.net/Sites/stackoverflow/all.css?v=070eac3e8cf4</code>，请不要用构建号。我们的缓存中断使用的是文件的<a href="https://en.wikipedia.org/wiki/Checksum">校验值</a>，也就是说只有当文件真正变化的时候你才会下载一个新的文件。用构建号的话可能会稍微简单点，但同时也会对你的费用还有性能有所损伤。</p>
<p>能做这个当然很好，可我们为什么不从一开始就做呢？因为 HTTPS 在那个时候性能还不行。用户通过 <code>https://</code> 访问会比 <code>http://</code>慢很多。举一个大一点的例子：我们上个月在 <code>sstatic.net</code> 上收到了四百万个请求，总共有 94TB。如果 HTTPS 性能不好的话，这里累积下来的延迟就很可观了。不过因为我们上了 HTTP/2，以及设置好 CDN/代理层，性能的问题已经好很多了。对于用户来说更快了，对我们来说则更简单，何乐不为呢！</p>
<h4 id="错误api-及-internal">错误：API 及 .internal</h4>
<p>当我们把代理架起来开始测试的时候发现了什么？我们忘了一件很重要的事，准确地说，我忘了一件很重要的事。我们在内部 API 里大量地使用了 HTTP。当然这个是正常工作的，只是它们变得更慢、更复杂、也更容易出问题了。</p>
<p>比方说一个内部 API 需要访问 <code>stackoverflow.com/some-internal-route</code>，之前，节点是这些：</p>
<ul>
<li>原始 app</li>
<li>网关/防火墙（暴露给公网）</li>
<li>本地负载均衡器</li>
<li>目标 web 服务器</li>
</ul>
<p>这是因为我们是可以解析 <code>stackoverflow.com</code> 的，解析出来的 IP 就是我们的负载均衡器。当有代理的情况下，为了让用户能访问到最近的节点，他们访问到的是不同的 IP 和目标点。他们的 DNS 解析出来的 IP 是 CDN/代理层 (Fastly)。糟了，这意识着我们现在的路径是这样的：</p>
<ul>
<li>原始 app</li>
<li>网关/防火墙（暴露给公网）</li>
<li>我们的外部路由器</li>
<li>运营商（多节点）</li>
<li>代理（Cloudflare/Fastly）</li>
<li>运营商（到我们的代理路）</li>
<li>我们的外部路由器</li>
<li>本地负载均衡器</li>
<li>目标 web 服务器</li>
</ul>
<p>嗯，这个看起来更糟了。为了实现一个从 A 调用一下 B，我们多了很多不必要的依赖，同时性能也下降了。我不是说我们的代理很慢，只是原本只需要 1ms 就可以连到我们数据中心……好吧，我们的代理很慢。</p>
<p>我们内部讨论了多次如何用最简单的方法解决这个问题。我们可以把请求改成 <code>internal.stackoverflow.com</code>，但是这会产生可观的修改（也许也会产生冲突）。我们也创建一个 DNS 来专门解析内部地址（但这样会产生通配符继承的问题）。我们也可以在内部把 <code>stackoverflow.com</code> 解析成不同的地址（这被称为<a href="https://en.wikipedia.org/wiki/Split-horizon_DNS">水平分割 DNS</a>），但是这一来不好调试，二来在多数据中心的场景下不知道该到哪一个。</p>
<p>最终，我们在所有暴露给外部 DNS 的域名后面都加了一个 <code>.internal</code> 后续。比如，在我们的网络中，<code>stackoverflow.com.internal</code> 会解析到我们的负载均衡器后面（DMZ）的一个内部子网内。我们这么做有几个原因：</p>
<ul>
<li>我们可以在内部的 DNS 服务器里覆盖且包含一个顶级域名服务器（活动目录）</li>
<li>当请求从 HAProxy 传到 web 应用中时，我们可以把 <code>.internal</code> 从 <code>Host</code> 头中移除（应用层无感知）</li>
<li>如果我们需要内部到 DMZ 的 SSL，我们可以用一个类似的通配符组合</li>
<li>客户端 API 的代码很简单（如果在域名列表中就加一个 <code>.internal</code>）</li>
</ul>
<p>我们客户端的 API 代码是大部分是由 <a href="https://twitter.com/marcgravell">Marc Gravell</a> 写的一个 <code>StackExchange.Network</code> 的 NuGet 库。对于每一个要访问的 URL，我们都用静态的方法调用（所以也就只有通用的获取方法那几个地方）。如果存在的话就会返回一个「内部化」URL，否则保持不变。这意味着一次简单的 NuGet 更新就可以把这个逻辑变化部署到所有应用上。这个调用挺简单的：</p>
<p># uri = SubstituteInternalUrl(uri);</p>
<p>这里是 <code>stackoverflow.com</code> DNS 行为的一个例子：</p>
<ul>
<li>Fastly：151.101.193.69, 151.101.129.69, 151.101.65.69, 151.101.1.69</li>
<li>直连（外部路由）：198.252.206.16</li>
<li>内部：10.7.3.16</li>
</ul>
<p>记得我们之前提到的 <a href="https://github.com/StackExchange/dnscontrol">dnscontrol</a> 吗？我们可以用这个快速同步。归功于 JavaScript 的配置/定义，我们可以简单地共享、简化代码。我们匹配所有所有子网和所有数据中心中的所有 IP 的最后一个字节，所以用几个变量，所有 AD 和外部的 DNS 条目都对齐了。这也意味着我们的 HAProxy 配置更简单了，基本上就是这样：</p>
<pre tabindex="0"><code>stacklb::external::frontend_normal { &#39;t1_http-in&#39;:
  section_name    =&gt; &#39;http-in&#39;,
  maxconn         =&gt; $t1_http_in_maxconn,
  inputs          =&gt; {
    &#34;${external_ip_base}.16:80&#34;  =&gt; [ &#39;name stackexchange&#39; ],
    &#34;${external_ip_base}.17:80&#34;  =&gt; [ &#39;name careers&#39; ],
    &#34;${external_ip_base}.18:80&#34;  =&gt; [ &#39;name openid&#39; ],
    &#34;${external_ip_base}.24:80&#34;  =&gt; [ &#39;name misc&#39; ],
</code></pre><p>综上，API 路径更快了，也更可靠了：</p>
<ul>
<li>原始 app</li>
<li>本地负载均衡器（DMZ）</li>
<li>目标 web 服务器</li>
</ul>
<p>我们解决了几个问题，还剩下几百个等着我们。</p>
<h4 id="错误301-缓存">错误：301 缓存</h4>
<p>在从 <code>http://</code> 301 跳到 <code>https://</code> 时有一点我们没有意识的是，Fastly 缓存了我们的返回值。在 Fastly 中，<a href="https://docs.fastly.com/guides/vcl/manipulating-the-cache-key">默认的缓存键</a>并不考虑协议。我个人不同意这个行为，因为在源站默认启用 301 跳转会导致无限循环。这个问题是这样造成的：</p>
<ol>
<li>用户访问 <code>http://</code> 上的一个网络</li>
<li>通过 301 跳转到了 <code>https://</code></li>
<li>Fastly 缓存了这个跳转</li>
<li>任意一个用户（包括 #1 中的那个）以 <code>https://</code> 访问同一个页面</li>
<li>Fastly 返回一个跳至 <code>https://</code> 的 301，尽量你已经在这个页面上了</li>
</ol>
<p>这就是为什么我们会有无限循环。要解决这个问题，我们得关掉 301，清掉 Fastly 缓存，然后开始调查。Fastly <a href="https://docs.fastly.com/guides/vcl/manipulating-the-cache-key#purging-adjustments-when-making-additions-to-cache-keys">建议我们在 vary 中加入 <code>Fastly-SSL</code></a>，像这样：</p>
<pre tabindex="0"><code>sub vcl_fetch {
  set beresp.http.Vary = if(beresp.http.Vary, beresp.http.Vary &#34;,&#34;, &#34;&#34;) &#34;Fastly-SSL&#34;;
</code></pre><p>在我看来，这应该是默认行为。</p>
<p>错误：帮助中心的小插曲</p>
<p>记得我们必须修复的帮助文档吗？帮助文档都是按语言区分，只有极少数是按站点来分，所以本来它们是可以共享的。为了不产生大量重复代码及存储结构，我们做了一点小小的处理。我们把实际上的帖子对象（和问题、答案一样）存在了 <code>meta.stackexchange.com</code> 或者是这篇帖子关联的站点中。我们把生成的 <code>HelpPost</code> 存在中心的 <code>Sites</code> 数据库里，其实也就是生成的 HTML。在处理混合内容的时候，我们也处理了单个站里的帖子，简单吧！</p>
<p>当原始的帖子修复后，我们只需要为每个站点去再生成 HTML 然后填充回去就行了。但是这个时候我犯了个错误。回填的时候拿的是<em>当前站点</em>（调用回填的那个站点），而不是原始站。这导致 <code>meta.stackexchange.com</code> 里的 12345 帖子被 <code>stackoverflow.com</code> 里的 12345 帖子所替代。有的时候是答案、有的时候是问题，有的时候有一个 tag wiki。这也导致了一些<a href="https://meta.stackoverflow.com/q/345280/13249">很有意思的帮助文档</a>。这里有一些<a href="https://meta.stackoverflow.com/a/345282/13249">相应的后果</a>。</p>
<p>我只能说，还好修复的过程挺简单的：</p>
<p> </p>
<p><a href="../../static/images/upload_dropbox/201709/HTTPS-HelpCommit.png">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/HTTPS-HelpCommit.png" alt="Me being a dumbass"  />


</a></p>
<p>再一次将数据填充回去就能修复了。不过怎么说，这个当时算是在公共场合闹了个笑话。抱歉。</p>
<h3 id="开源">开源</h3>
<p>这里有我们在这个过程中产出的项目，帮助我们改进了 HTTPS 部署的工作，希望有一天这些能拯救世界吧：</p>
<ul>
<li><a href="https://github.com/StackExchange/blackbox">BlackBox</a> （在版本控制中安全存储私密信息）作者 <a href="https://twitter.com/yesthattom">Tom Limoncelli</a></li>
<li><a href="https://github.com/StackExchange/capnproto-net">capnproto-net</a>（不再支持 —— .NET 版本的 <a href="https://capnproto.org/">Cap’n Proto</a>）作者 <a href="https://twitter.com/marcgravell">Marc Gravell</a></li>
<li><a href="https://github.com/StackExchange/dnscontrol">DNSControl</a>（控制多个 DNS 提供商）作者 <a href="https://twitter.com/captncraig">Craig Peterson</a> and <a href="https://twitter.com/yesthattom">Tom Limoncelli</a></li>
<li><a href="https://github.com/StackExchange/httpunit">httpUnit</a> （网站集成测试） 作者 <a href="https://twitter.com/mjibson">Matt Jibson</a> and <a href="https://twitter.com/yesthattom">Tom Limoncelli</a></li>
<li><a href="https://github.com/opserver/Opserver">Opserver</a> （支持 Cloudflare DNS） 作者 <a href="https://twitter.com/Nick_Craver">Nick Craver</a></li>
<li><a href="https://github.com/alienth/fastlyctl">fastlyctl</a>（Go 语言的 Fastly API 调用）作者 <a href="https://twitter.com/alioth">Jason Harvey</a></li>
<li><a href="https://github.com/alienth/fastly-ratelimit">fastly-ratelimit</a>（基于 Fastly syslog 流量的限流方案）作者 <a href="https://twitter.com/alioth/">Jason Harvey</a></li>
</ul>
<h3 id="下一步">下一步</h3>
<p>我们的工作并没有做完。接下去还有一此要做的：</p>
<ul>
<li>我们要修复我们聊天域名下的混合内容，如 <a href="https://chat.stackoverflow.com/">chat.stackoverflow.com</a>，这里有用户嵌入的图片等</li>
<li>如果可能的话，我们把所有适用的域名加进 <a href="https://hstspreload.org/">Chrome HSTS 预加载列表</a></li>
<li>我们要评估 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning">HPKP</a> 以及我们是否想部署（这个很危险，目前我们倾向于不部署）</li>
<li>我们需要把聊天移到 <code>https://</code></li>
<li>我们需要把所有的 cookies 迁移成安全模式</li>
<li>我们在等能支持 HTTP/2 的 HAProxy 1.8（大概在九月出来）</li>
<li>我们需要利用 HTTP/2 的推送（我会在六月与 Fastly 讨论这件事情——他们还现在不支持跨域名推送）</li>
<li>我们需要把 301 行为从 CDN/代理移出以达到更好的性能（需要按站点发布）</li>
</ul>
<p>HSTS 预加载</p>
<p><a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HSTS</a> 指的是「HTTP 严格传输安全」。OWASP 在<a href="https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet">这里</a>有一篇很好的总结。这个概念其实很简单：</p>
<ul>
<li>当你访问 <code>https://</code> 页面的时候，我们给你发一个这样的头部：<code>Strict-Transport-Security: max-age=31536000</code></li>
<li>在这个时间内（秒），你的浏览器只会通过 <code>https://</code> 访问这个域名</li>
</ul>
<p>哪怕你是点击一个 <code>http://</code> 的链接，你的浏览器也会<em>直接</em>跳到 <code>https://</code>。哪怕你有可能已经设置了一个 <code>http://</code> 的跳转，但你的浏览器不会访问，它会直接访问 SSL/TLS。这也避免了用户访问不安全的 <code>http://</code> 而遭到劫持。比如它可以把你劫持到一个 <code>https://stack&lt;长得很像o但实际是个圈的unicode&gt;verflow.com</code> 上，那个站点甚至有可能部好了 SSL/TLS 证书。只有不访问这个站点才是安全的。</p>
<p>但这需要我们至少访问一次站点，然后才能有这个头部，对吧？对。所以我们有 <a href="https://hstspreload.org/">HSTS 预加载</a>，这是一个域名列表，随着所有主流浏览器分发且由它们预加载。也就是说它们在第一次访问的时候就会跳到 <code>https://</code> 去，所以<strong>永远不会</strong>有任何 <code>http://</code> 通信。</p>
<p>很赞吧！所以要怎么才能上这个列表呢？这里是要求：</p>
<ol>
<li>要有一个有效的证书</li>
<li>如果你监听 80 端口的话，HTTP 应该跳到同一个主机的 HTTPS 上</li>
<li>所有子域名都要支持 HTTPS</li>
<li>特别是如果有 DNS 纪录的话，www 子域名要支持 HTTPS</li>
<li>主域名的 HSTS 头必要满足如下条件：</li>
<li>max-aget 至少得是十八周（10886400 秒）</li>
<li>必须有 includeSubDomains 指令</li>
<li>必须指定 preload 指令</li>
<li>如果你要跳转到 HTTPS 站点上，跳转也必须有 HSTS 头部（而不仅仅是跳过去的那个页面）</li>
</ol>
<p>这听起来还行吧？我们所有的活跃域名都支持 HTTPS 并且有有效的证书了。不对，我们还有一个问题。记得我们有一个 <code>meta.gaming.stackexchange.com</code> 吧，虽然它跳到 <code>gaming.meta.stackexchange.com</code>，但这个跳转本身并没有有效证书。</p>
<p>以 meta 为例，如果我们在 HSTS 头里加入 <code>includeSubDomains</code> 指令，那么网上所有指向旧域名的链接都会踩坑。它们本该跳到一个 <code>http:///</code> 站点上（现在是这样的），一旦改了就会变成一个非法证书错误。昨天我们看了一下流量日志，每天仍有 8 万次访问的是通过 301 跳到 meta 子域上的。这里有很多是爬虫，但还是有不少人为的流量是从博客或者收藏夹过来的……而有些爬虫真的很蠢，从来不根据 301 来更新他们的信息。嗯，你还在看这篇文章？我自己写着写着都已经睡着 3 次了。</p>
<p>我们该怎么办呢？我们是否要启用 SAN 证书，加入几百个域名，然后调整我们的基础架构使得 301 跳转也严格遵守 HTTPS 呢？如果要通过 Fastly 来做的话就会提升我们的成本（需要更多 IP、证书等等）。<a href="https://letsencrypt.org/">Let’s Encrypt</a> <em>倒是</em>真的能帮上点忙。获取证书的成本比较低，如果你不考虑设置及维护的人力成本的话（因为我们由于<a href="#certificates">上文所述</a>内容并没有在使用它).</p>
<p>还有一块是上古遗留问题：我们内部的域名是 <code>ds.stackexchange.com</code>。为什么是 <code>ds.</code>？我不确定。我猜可能是我们不知道怎么拼 data center 这个词。这意味着 <code>includeSubDomains</code> 会自动包含<em>所有内部终端</em>。虽然我们大部分都已经上了 <code>https://</code> ，但是如果什么都走 HTTPS 会导致一些问题，也会带来一定延时。不是说我们不想在内部也用 <code>https://</code>，只不过这是一个整体的项目（大部分是证书分发和维护，还有多级证书），我们不想增加耦合。那为什么不改一下内部域名呢？主要还是时间问题，这一动迁需要大量的时间和协调。</p>
<p>目前，我们将 HSTS 的 <code>max-age</code> 设为两年，并且<strong>不包括</strong> <code>includeSubDomains</code>。除非迫不得以，我不会从代码里移除这个设定，因为它太危险了。一旦我们把所有 Q&amp;A 站点的 HSTS 时间都设置好之后，我们会和 Google 聊一下是不是能在不加 <code>includeSubDomains</code> 的情况下把我们加进 HSTS 列表中，至少我们会试试看。你可以看到，虽然很罕见，但<a href="https://chromium.googlesource.com/chromium/src/net/+/master/http/transport_security_state_static.json">目前的这份列表中</a>还是出现了这种情况的。希望从加强 Stack Overflow 安全性的角度，他们能同意这一点。</p>
<p>聊天</p>
<p>为了尽快启用 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Secure_and_HttpOnly_cookies"><code>安全</code> cookie</a>（仅在 HTTPS 下发送），我们会将聊天（<a href="https://chat.stackoverflow.com/">chat.stackoverflow.com</a>、[<a href="http://chat.stackexchange.com/">chat.stackexchange.com</a>及 <a href="https://chat.meta.stackexchange.com/">chat.meta.stackexchange.com</a>）跳转至 <code>https://</code>。 正如我们的通用登录所做的那样，聊天会依赖于二级域名下的 cookie。如果 cookie 仅在 <code>https://</code> 下发送，你就只能在 <code>https://</code> 下登录。</p>
<p>这一块有待斟酌，但其实在有混合内容的情况下将聊天迁至 <code>https://</code> 是一件好事。我们的网络更加安全了，而我们也可以处理实时聊天中的混合内容。希望这个能在接下去的一两周之内实施，这在我的计划之中。</p>
<p>今天</p>
<p>不管怎么说，这就是我们今天到达的地步，也是我们过去四年中一直在做的事情。确实有很多更高优先级的事情阻挡了 HTTPS 的脚步——这也远远不是我们唯一在做的事情。但这就是生活。做这件事情的人们还在很多你们看不见的地方努力着，而涉及到的人也远不止我所提到的这些。在这篇文章中我只提到了一些花了我们很多时间的、比较复杂的话题（否则就会太长了），但是这一路上不管是 Stack Overflow 内部还是外部都有很多人帮助过我们。</p>
<p>我知道你们会有很多的疑问、顾虑、报怨、建议等等。我们非常欢迎这些内容。本周我们会关注底下的评论、我们的 meta 站、Reddit、Hacker News 以及 Twitter，并尽可能地回答/帮助你们。感谢阅读，能全文读下的来真是太棒了。（比心）</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>一个关于 nolock 的故事：深入理解数据库隔离级别</title>
      <link>https://blog.alswl.com/2017/09/sql-server-nolock/</link>
      <pubDate>Tue, 19 Sep 2017 16:43:45 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2017/09/sql-server-nolock/</guid>
      <description>加入沪江不久，我就被扔到一个将集团 SQL Sever 的数据库迁移到 MySQL 的项目里， 同时伴随进行的还有 .net 系统迁移到 Java 系统。 在这个过程中我发现了一个很有趣的现象：历史遗留的 .net 项目中， 几乎所有的 SQL 中都会使用一个关键字：nolock。 这让我很困惑，nolock 的字面意思是对当前技术不使用锁技术，为什么要这样用呢？ 我找了一个范例如下： SELECT [id] FROM [dbo].[foos] WITH(nolock) WHERE aField = 42 AND bField = 1 作为横向支持工程师，开发工程师会问我：「数据库即将从 SQL Server 迁移到 My</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/sql-server.png" alt="sql-server.png"  />


</p>
<p>加入沪江不久，我就被扔到一个将集团 SQL Sever 的数据库迁移到 MySQL 的项目里，
同时伴随进行的还有 .net 系统迁移到 Java 系统。
在这个过程中我发现了一个很有趣的现象：历史遗留的 .net 项目中，
几乎所有的 SQL 中都会使用一个关键字：<code>nolock</code>。
这让我很困惑，<code>nolock</code> 的字面意思是对当前技术不使用锁技术，为什么要这样用呢？</p>
<!-- more -->
<p>我找了一个范例如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w">   </span><span class="p">[</span><span class="n">dbo</span><span class="p">].[</span><span class="n">foos</span><span class="p">]</span><span class="w"> </span><span class="k">WITH</span><span class="p">(</span><span class="n">nolock</span><span class="p">)</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w">  </span><span class="n">aField</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">AND</span><span class="w"> </span><span class="n">bField</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> 
</span></span></span></code></pre></div><p>作为横向支持工程师，开发工程师会问我：「数据库即将从 SQL Server
迁移到 MySQL，我们编码中还需要使用 <code>nolock</code> 么？
MySQL 里面对应的写法是什么？」。
我并没有 SQL Server 的生产环境使用经验，一时间无法回答。
于是课后做相关知识学习，这里就是这次学习的一点成果。</p>
<p>这个问题将被拆解成三个小问题进行回答：</p>
<ul>
<li><code>nolock</code> 是什么？</li>
<li>为什么会需要在每个 Query 语句使用 <code>nolock</code>？</li>
<li>MySQL 的对应写法是什么？</li>
</ul>
<p>让我们一个一个来看。</p>
<h2 id="第一个问题nolock-是什么">第一个问题：nolock 是什么？</h2>
<p><code>nolock</code> 是 SQL Server 的一个关键字，这类关键字官方将其称之为 Hints。
Hints 的设计目的是为了能够让 SQL 语句在运行时，动态修改查询优化器的行为。
在语法上，Hints 以 <code>WITH</code> 开头。除了 <code>WITH(nolock)</code>，
还有 <code>TABLOCK</code> / <code>INDEX</code> / <code>ROWLOCK</code> 等常见的 Hints。</p>
<p>让我们仔细看看 MSDN 文档上的解释：</p>
<blockquote>
<p><code>nolock</code> 的作用等同于 <code>READUNCOMMITTED</code></p>
</blockquote>
<p><code>READUNCOMMITTED</code> 这是一种 RDBMS 隔离级别。
使用 <code>nolock</code> 这个关键词，可以将当前查询语句隔离级别调整为 <code>READ UNCOMMITTED</code>。</p>
<p>计算机基础好的同学，应该对 <code>READUNCOMMITTED</code> 这个关键词还有印象。
而基础不扎实的同学，也许只是觉得这个关键词眼熟，但是讲不清楚这是什么。
如果阅读这句话完全没有理解困难，那恭喜你，你可以直接跳到下一节了。
其他朋友就跟随我继续探索一下 RDMBS 的世界，复习一下隔离级别相关的知识。</p>
<h3 id="隔离级别">隔离级别</h3>
<p>SQL 92 定义了四个隔离级别
（<a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels">Isolation (database systems) - Wikipedia</a>），
其隔离程度由高到低是：</p>
<ul>
<li>可序列化（Serializable）</li>
<li>可重复读（Repeatable reads）</li>
<li>提交读（Read committed）</li>
<li>未提交读（Read uncommitted）</li>
</ul>
<p>单单将这几个技术名词简单地罗列出来并没有什么意义，还有这几个问题需要搞清楚：</p>
<ul>
<li>隔离级别解决什么问题？</li>
<li>为什么存在多种隔离级别？</li>
<li>我们所谓的隔离级别从高到低，是什么含义，如何逐层降低的？</li>
</ul>
<p>首先是「隔离级别解决什么问题？」，
用通俗的语言描述就是：加一个针对数据资源的锁，从而保证数据操作过程中的一致性。</p>
<p>这是最简单的实现方式，过于粗暴的隔离性将大幅降低性能，
多种隔离级别就是是为了取得两者的平衡。</p>
<p>接下来我们来回答第二个问题「为什么存在多种粒度的隔离级别？」
这其实是一个需求和性能逐步平衡的过程，</p>
<p>我们逐层递进，将隔离级别由低到高逐层面临进行分析。</p>
<h3 id="read-uncommitted">Read Uncommitted</h3>
<p>Read Uncommitted 这个隔离级别是最低粒度的隔离级别，
如同它的名字一般，它允许在操作过程中不会锁，从而让当前事务读取到其他事务的数据。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/read-uncommitted.png" alt="read-uncommitted.png"  />


</p>
<p>如上图所示，在 Transaction 2 查询时候，Transaction 1 未提交的数据就已经对外暴露。
如果 Transaction 1 最后 Rollback 了，那么 Transaction 读取的数据就是错误的。</p>
<p>「读到了其他事务修改了但是未提交的数据」即是<strong>脏读</strong>。</p>
<h3 id="read-committed">Read Committed</h3>
<p>想要避免脏读，最简单的方式就是在事务更新操作上加一把写锁，
其他事务需要读取数据时候，需要等待这把写锁释放。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/read-committed-1.png" alt="read-committed-1.png"  />


</p>
<p>如上图所示，Transaction 1 在写操作时候，对数据 A 加了写锁，
那么 Transaction 2 想要读取 A，就必须等待这把锁释放。
这样就避免当前事务读取其他事务的未提交数据。</p>
<p>但是除了脏读，一致性的要求还需要「可重复读」，即
「在一个事务内，多次读取的特定数据都必须是一致的
（即便在这过程中该数据被其他事务修改）」。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/read-committed-2.png" alt="read-committed-2.png"  />


</p>
<p>上图就是没能保证「可重复度」，Transaction 2 第一次读取到了数据 A，
然后 Transaction 1 对数据 A 更新到 A&rsquo;，那么当 Tranction 2 再次读取 A 时候，
它本来期望读到 A，但是却读到了 A&rsquo;，这和它的预期不相符了。
解决这个问题，就需要提升隔离级别到「Repeatable Read」。</p>
<h3 id="repeatable-read">Repeatable Read</h3>
<p>这个名字非常容易理解，即保障在一个事务内重复读取时，
始终能够读取到相同的内容。来看图：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/repeatable-read.png" alt="repeatable-read.png"  />


</p>
<p>如上所示，当 Transation 2 读取 A 时候，会同时加上一把 Read Lock，
这把锁会阻止 Transaction 1 将 A 更新为 A&rsquo;，Transaction 1 要么选择等待，
要么就选择结束。</p>
<p>当我们将隔离级别升到这里是，似乎已经完美无缺了。
不管是写入还是读取，我们都可以保证数据的一致性不被破坏。
但是其实还有漏洞：新增数据的一致性！</p>
<p>上述的三个隔离级别，都是对特定的一行数据进行加锁，
那假如将要更新的数据还没有写入数据库，如何进行加锁呢？
比如自增表的新键，或者现有数据内的空缺 Key？</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/repeatable-read-2.png" alt="repeatable-read-2.png"  />


</p>
<p>如图所示，在上述操作中，Transaction 2 查询了一个范围 Range 之后，Transaction 1
在这个范围内插入了一条新的数据。此时 Transaction 2 再次进行范围查询时候，
会发现查询到的 Range 和上次已经不一样了，多了一个 newA。</p>
<p>这就是最高隔离级别才能解决的「幻影读」：
当两个完全相同的查询语句执行得到不同的结果集，
这常常在范围查询中出现。</p>
<h3 id="serializable">Serializable</h3>
<p>从字面意思看，该隔离级别需要将被操作的数据加锁加一把锁。
任何读写操作都需要先获得这把锁才能进行。如果操作中带 WHERE 条件，
还需要将 WHERE 条件相关的范围全部加锁。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201709/serializable.png" alt="serializable.png"  />


</p>
<p>如图所示，在 Transaction 2 操作过程中，会对 Range 进行加锁，
此时其他事务无法操作其中的数据，只能等待或者放弃。</p>
<h3 id="db-的默认隔离级别">DB 的默认隔离级别</h3>
<p>现在我们已经理解了隔离级别，那么「SQL Server 默认使用的隔离级别是什么呢？」
根据 <a href="https://msdn.microsoft.com/en-us/library/ms175909.aspx">Customizing Transaction Isolation Level</a>
这个文档描述，SQL Server 默认隔离级别是 READ COMMITTED。</p>
<p>MySQL InnoDB 的默认隔离级别可以在 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html">MySQL :: MySQL 5.7 Reference Manual :: 14.5.2.1 Transaction Isolation Levels</a>
查询到，是 Read-Repeatable。</p>
<p>隔离级别并没有最好之说，越高隔离级别会导致性能降低。
隔离级别的设定需要考虑业务场景。</p>
<h2 id="第二个问题为什么要使用-nolock">第二个问题：为什么要使用 nolock？</h2>
<p>我们已经知道 <code>nolock</code> 的作用是动态调整隔离级别。
那为什么在 SQL Server 的 Query 操作中，需要启用 <code>nolock</code> 呢？
我问了几个工程师，他们都语焉不详，或者是很泛泛地说：禁用读写锁，可以提升查询性能。</p>
<p>此时我产生了困惑：「那么此时的数据一致性就不需要考虑了么？
我们的数据库，已经到了需要禁用锁的程度来进行优化了么？」
我于是自己去探索，想知道为何广泛使用 <code>nolock</code> 会成为一个「最佳实践」？</p>
<p>由于时代久远，我只能追述到一些相关信息，比如
<a href="https://blogs.msdn.microsoft.com/sqlcat/2013/09/16/top-10-sql-server-integration-services-best-practices/">Top 10 SQL Server Integration Services Best Practices | SQL Server Customer Advisory Team</a>
中提到 「Use the NOLOCK or TABLOCK hints to remove locking overhead.」
但这个是针对于 SSIS 查询器，并不是针对业务内部使用。
反而能找到一大堆的文档，在反对使用 <code>nolock</code> 这个关键字。</p>
<p>继续追查下去，还从蛛丝马迹中寻找到一个使用 <code>nolock</code> 的理由，
SQL Server 默认是 Read Committed，
更新操作会产生排它锁，会 block 这个资源的查询操作，
已插入但未提交的数据主键也会产生一个共享锁，
而此时则会 block 这张表的全表查询和 Insert 操作。
为了避免 Insert 被 Block，就会推荐使用 <code>nolock</code>。</p>
<p>为了验证这是原因，我做一些 <code>nolock</code> 测试。</p>
<h3 id="nolock-测试">nolock 测试</h3>
<p>检查当前 SQL Server 隔离级别，确认隔离级别是默认的 Read Committed：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">CASE</span><span class="w"> </span><span class="n">transaction_isolation_level</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">WHEN</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">THEN</span><span class="w"> </span><span class="s1">&#39;Unspecified&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">WHEN</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">THEN</span><span class="w"> </span><span class="s1">&#39;ReadUncommitted&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">WHEN</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">THEN</span><span class="w"> </span><span class="s1">&#39;ReadCommitted&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">WHEN</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">THEN</span><span class="w"> </span><span class="s1">&#39;Repeatable&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">WHEN</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">THEN</span><span class="w"> </span><span class="s1">&#39;Serializable&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">WHEN</span><span class="w"> </span><span class="mi">5</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="k">THEN</span><span class="w"> </span><span class="s1">&#39;Snapshot&#39;</span><span class="w"> </span><span class="k">END</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">TRANSACTION_ISOLATION_LEVEL</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">dm_exec_sessions</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">session_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">@@</span><span class="n">SPID</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- ReadCommitted
</span></span></span></code></pre></div><p>创建表，初始化数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">foos</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">id</span><span class="w">    </span><span class="nb">BIGINT</span><span class="w">    </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">value</span><span class="w"> </span><span class="k">NCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">pk</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="n">clustered</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">foos</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;1&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;2&#39;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>在 Transaction 1 中发起 Update 操作（INSERT / DELETE 同理），但是并不做 Commit 提交：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">BEGIN</span><span class="w"> </span><span class="k">TRANSACTION</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">foos</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;3&#39;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>开启一个新的 Session，发起全表查询和新增 PK 查询操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">foos</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">foos</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>不出所料，此时查询果然会被 Block 住。</p>
<h3 id="mvcc">MVCC</h3>
<p>并发控制的手段有这些：封锁、时间戳、乐观并发控制、悲观并发控制。
SQL Server 在 2005 后，引入了 MVCC（多版本控制）。
如果最终数据是一致，会允许数据写入，否则其他事务会被阻止写入。
那么 MVCC 引入是否可以解决 Insert 数据的锁问题？
同样，我做了以下测试：</p>
<p>查询 SQL Server 使用启用 MVCC ALLOW_SNAPSHOT_ISOLATION：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">snapshot_isolation_state</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">databases</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>使用 T-SQL 启用测试表的 SNAPSHOT_ISOLATION：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">ALTER</span><span class="w"> </span><span class="k">DATABASE</span><span class="w"> </span><span class="n">HJ_Test3D</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">ALLOW_SNAPSHOT_ISOLATION</span><span class="w"> </span><span class="k">ON</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>接着重复上面里面的 Insert 试验，依然被 Block 住。
看来 MVCC 并不能解决 Insert 锁的问题。</p>
<h3 id="sql-server-2005-之后还需要使用-nolock-么">SQL Server 2005 之后还需要使用 nolock 么？</h3>
<p>从官方文档和上文测试可以看到，在 Insert 时候，由于排它锁的存在，
会导致 <code>SELECT ALL</code> 以及 <code>SELECT</code> 新插入数据的相关信息被锁住。
在这两种情景下面是需要使用 <code>nolock</code> 的。</p>
<p>除此之外，有这么几类场景可以使用 <code>nolock</code>：</p>
<ul>
<li>在 SSIS 查询器中进行数据分析，不需要精准数据</li>
<li>历史数据进行查询，没有数据更新操作，也不会产生脏数据</li>
</ul>
<p>我们需要思考一下，性能和数据一致性上的权衡上，
我们是否愿意放弃数据一致性而为了提高一丝丝性能？
以及我们有多少场景，会频繁使用 <code>SELECT ALL</code> 操作而没有查询条件？</p>
<p><del>微软官方在 2008 的特性列表里面，明确地指出 <code>nolock</code> 特性未来会在某个版本被废除：</del></p>
<blockquote>
<p><del>Specifying NOLOCK or READUNCOMMITTED in the FROM clause of an UPDATE or DELETE statement.</del></p>
</blockquote>
<p><del>而改为推荐：</del></p>
<blockquote>
<p><del>Remove the NOLOCK or READUNCOMMITTED table hints from the FROM clause.</del></p>
</blockquote>
<p>事实上，我听过不少团队会禁止在生产环境使用不带 WHERE 条件的 SQL。
那在这种模式下，产生相关的问题的几率也就更小了。
如果有很高的并发需求，那需要考虑一下是否需要其他优化策略：比如使用主从分离、
Snapshot 导出、流式分析等技术。</p>
<h2 id="第三个问题mysql-的对应写法是什么">第三个问题：MySQL 的对应写法是什么？</h2>
<p>终于轮到 MySQL 的讨论了。MySQL，InnoDB 天生支持 MVCC，
并且支持 <code>innodb_autoinc_lock_mode</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html">AUTO_INCREMENT Handling in InnoDB</a>。
这样可以避免 Insert 操作锁住全局 Select 操作。
只有在同时 Insert 时候，才会被 Block 住。</p>
<p><code>innodb_autoinc_lock_mode</code> 支持几种模式：</p>
<ul>
<li>innodb_autoinc_lock_mode = 0 (“traditional” lock mode)
<ul>
<li>涉及auto-increment列的插入语句加的表级AUTO-INC锁，只有插入执行结束后才会释放锁</li>
</ul>
</li>
<li>innodb_autoinc_lock_mode = 1 (“consecutive” lock mode)
<ul>
<li>可以事先确定插入行数的语句，分配连续的确定的 auto-increment 值</li>
<li>对于插入行数不确定的插入语句，仍加表锁</li>
<li>这种模式下，事务回滚，auto-increment 值不会回滚，换句话说，自增列内容会不连续</li>
</ul>
</li>
<li>innodb_autoinc_lock_mode = 2 (“interleaved” lock mode)
<ul>
<li>同一时刻多条 SQL 语句产生交错的 auto-increment 值</li>
</ul>
</li>
</ul>
<p>这里也做了相应的测试。首先检查数据库隔离级别和 <code>innodb_autoinc_lock_mode</code> 模式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">@@</span><span class="k">global</span><span class="p">.</span><span class="n">tx_isolation</span><span class="p">,</span><span class="w"> </span><span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">tx_isolation</span><span class="p">,</span><span class="w"> </span><span class="o">@@</span><span class="n">tx_isolation</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SHOW</span><span class="w"> </span><span class="n">variables</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;innodb_autoinc_lock_mode&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>检查后发现都是 Repeatable Read，<code>innodb_autoinc_lock_mode</code> 模式是 1。
然后创建测试表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">foos</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">name</span><span class="o">`</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">18</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>在 Transaction 1 中 Insert 数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">START</span><span class="w"> </span><span class="k">TRANSACTION</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">foos</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s2">&#34;a&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>在 Transaction 2 中 Select 数据，可以正常查询：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w">   </span><span class="n">foos</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>在 Transaction 2 中 Insert 数据，会被 Block 住：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">START</span><span class="w"> </span><span class="k">TRANSACTION</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">foos</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s2">&#34;a&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>这个测试可以证明 MySQL 可以在 <code>innodb_autoinc_lock_mode</code>=1 下，
Insert 同时 Query 不会被 Block，
但是在另外一个事务中 Insert 会被 Block。
结论是，由于 <code>innodb_autoinc_lock_mode</code> 的存在，MySQL 中可以不需要使用 <code>nolock</code>
关键词进行查询。</p>
<h2 id="回顾一下">回顾一下</h2>
<p>本文着重去回答这么几个问题：</p>
<ul>
<li>为什么要用 <code>noloc</code>？</li>
<li>为什么要改变隔离级别？</li>
<li>为什么 MySQL 不需要做类似的事情？</li>
</ul>
<p>虽然只凑足了三个 「为什么」 的排比，
但是聪明的读者仍然会发现，我是使用了著名的
<a href="https://zh.wikipedia.org/wiki/%E4%BA%94%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88">五个为什么</a>
方法思考问题。
通过使用这个方法，我们最后不但打破了老旧的最佳实践，还了解了本质原理，
并找到了新的最佳实践。</p>
<p>希望读者朋友在遇到困难时候，多问几个为什么，多抱着打破砂锅问到底的精神，
这样才能让每个困难成为我们成长的垫脚石。</p>
<h2 id="相关资料">相关资料</h2>
<ul>
<li><a href="https://zh.wikipedia.org/zh-cn/%E4%BA%8B%E5%8B%99%E9%9A%94%E9%9B%A2">事务隔离 - 维基百科，自由的百科全书</a></li>
<li><a href="https://docs.microsoft.com/en-us/sql/t-sql/queries/hints-transact-sql-table">Table Hints (Transact-SQL) | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/snapshot-isolation-in-sql-server">Snapshot Isolation in SQL Server | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/sql/relational-databases/system-catalog-views/sys-databases-transact-sql">sys.databases (Transact-SQL) | Microsoft Docs</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">MySQL :: MySQL 5.7 Reference Manual :: 15.3 InnoDB Multi-Versioning</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>当我们在聊监控，我们在聊什么？</title>
      <link>https://blog.alswl.com/2017/06/monitoring-introducing/</link>
      <pubDate>Thu, 08 Jun 2017 15:40:41 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2017/06/monitoring-introducing/</guid>
      <description>最近在团队中给大家做了一个分享，泛泛地聊了一些有关「监控」的话题。 其实做分享对分享者的作用往往大于参与者。 这是一次将自己知识的梳理的过程，于是我将这次分享整理成这篇文章。 目的 🎯 我们先来聊聊，什么是「监控」，以及我们期望通过「监控」完成哪些目的？ 传统意义上的监控，是指： 通过一些手段和工具，关注运行中的硬件、软件、用户体验的关键数据，将其暴露出来。 当关键数据出现异常时候发出警告，进行人工或者自动的响应</description>
      <content:encoded><![CDATA[<p>最近在团队中给大家做了一个分享，泛泛地聊了一些有关「监控」的话题。
其实做分享对分享者的作用往往大于参与者。
这是一次将自己知识的梳理的过程，于是我将这次分享整理成这篇文章。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201706/stock-exchange.png" alt="201706/stock-exchange.png"  />


</p>
<!-- more -->
<h2 id="目的-">目的 🎯</h2>
<p>我们先来聊聊，什么是「监控」，以及我们期望通过「监控」完成哪些目的？</p>
<p>传统意义上的监控，是指：</p>
<blockquote>
<p>通过一些手段和工具，关注运行中的<strong>硬件、软件、用户体验</strong>的关键数据，将其暴露出来。
当关键数据出现异常时候发出警告，进行人工或者自动的响应。</p>
</blockquote>
<p>我们平时看到的最常见的监控系统，比如 Zabbix，提供了丰富的模板，
可以监控服务器的 Load / CPU Usage / Alive 这些常规指标。
并在出现问题时候，对其进行报警通知。
随后运维工程师们会上线进行应急操作，case by case 的处理故障。</p>
<p>我将上面的使用目的归纳为：</p>
<ul>
<li>故障发生时提供数据报警</li>
<li>提供历史数据以供分析</li>
</ul>
<p>故事到这里似乎可以结束了，可监控真的是这么简单的么？
当然没，随着时代的进步，用户对服务提出了更为严苛的要求，
同时我们也有能力进一步控制平均故障修复时间
（<a href="https://en.wikipedia.org/wiki/Mean_time_between_failures">MTBF</a>），
上述描述的做法已经不能满足我们了。</p>
<p>现在让我们切换一下视角，从传统的 OPS 的视角切换到 SRE
（<a href="https://en.wikipedia.org/wiki/Site_reliability_engineering">Site Reliability Engineering</a>）的视角。
当我们在关注网站整体的可用性时，我们会发现：
故障警报处理当然很重要，但是我们根本上想减少甚至避免 MTBF。
我们有两种手段：
一种是去除单点故障，让问题自然发生，但是不对线上造成影响；
另一种是在问题出现的早期就发现并进行及时修复。
前者是高可用范畴，后者就是我们今天关注的「监控」了。</p>
<p>监控的目的是要<strong>将灾难消灭在襁褓里；在灾难即将出现或者发生问题时，
给大家展示直接的原因</strong>。</p>
<p>那为了达成这两个目标，我们需要回到问题的本质，重新思考两个问题：</p>
<ol>
<li>监控哪些对象？</li>
<li>如何识别故障？</li>
</ol>
<h2 id="对象-">对象 🐘🐘</h2>
<p>我们说的监控对象，一般指的都是某个资源，
资源即持有某种其他方需要的某些属性的载体，包括硬件、软件。
除了资源这种类型，还有一种常见的监控对象是「体验」，即终端用户的访问感受，
这块内容我们暂时略去。</p>
<p>让我们来先看一下常见的资源：</p>
<ul>
<li>硬件
<ul>
<li>服务器</li>
<li>网络设备</li>
</ul>
</li>
<li>软件
<ul>
<li>Application</li>
<li>Infrastructure</li>
</ul>
</li>
</ul>
<p>这个分类是粗粒度的描述，为了落地地描述监控对象对象的健康状况，
我们还要进一步细化。以「服务器」为例，我们可以将其监控的内容细化为以下监控项：</p>
<ul>
<li>CPU</li>
<li>Memory</li>
<li>Network interface</li>
<li>Storage devices</li>
<li>Controllers</li>
</ul>
<p>如何评估这些监控项的健康状况？我们使用
<a href="https://en.wikipedia.org/wiki/Service_level_indicator">SLI（Service Level Indicator）</a>。
比如<strong>可用性</strong>就是一个最容易理解的 SLI。
这里我将资源归为两类，面向用户提供服务的资源和面向存储的资源，
以下是针对这两类资源的常见 SLI：</p>
<ul>
<li>User-facing Service
<ul>
<li>Availability</li>
<li>Latency</li>
<li>Throughput</li>
</ul>
</li>
<li>Storage System
<ul>
<li>Latency</li>
<li>Throughput</li>
<li>durability</li>
</ul>
</li>
</ul>
<p>基于 SLI 建立的数字关键指标，称之为
<a href="https://en.wikipedia.org/wiki/Service_level_objective">Service Level Objective</a>。
SLO 往往是一组数字范围，比如 CPU 负载的 SLO 可以设置为 0.0-6.0（针对 8 核 CPU）。
不同的资源、不同的业务场景，会有不一样的 SLO 设计。</p>
<p>看到这里，我们已经聊了要监控哪些指标，那么接下来我们聊聊如何用量化的思想，
帮助指标更易于识别、分析和决策。</p>
<h2 id="量化的思想-">量化的思想 🔢</h2>
<p>刚开始担任线上救火队成员时候，当有个系统出现问题时候，我经常听到这样的描述：
网站挂了、页面打不开了，CPU 出问题了，内存爆了，线程池炸了等等。
这样的表述虽然没错，但带来的可用价值太少，信息熵太低。
这样的说辞多了，就给人产生一种不靠谱，不科学的感觉。</p>
<p>那怎样才能成为科学的描述？
古希腊哲学家在思考宇宙的时候，提出了一种心智能力，
从而打开了科学的窗子，这就是 Reasonable，中文名叫理智，这成为了自然科学的基石。
使用 Reasonable 探讨意味着探讨要深入问题的本质，不停留在表象，挖掘出真正有价值的内容。</p>
<p>但是光有 Reasonable 还不够，B站粉丝建了一个微博，每天会检查
<a href="http://weibo.com/yamanasion?refer_flag=1001030201_&amp;is_hot=1">今天B站炸了吗</a>，
他只能告诉我们炸没炸，不能给工程师带来实际的用处。
在科学的发展历史上，我们可以发现在亚里士多德的著作里没有任何数据公式。
他对现象只有描述，只是定性分析，通过描述性状来阐述定理。
这个定性的研究方式到了伽利略那里才出现了突破。
这里我们可以引入第二个关键词是  Quantifier，量化。
伽利略率先使用定量分析的方法，并将其运用到动力学和天文学，从而开创了近代科学。</p>
<p>如果我们以定量的方式来描述网站挂没挂，就会变成：网站的响应耗时在 30s，基本无法使用。
描述线程池出问题，就会变成：active 线程数量是 200，已经到达 maxCount 数量，无法进行分配。
你看，通过这样的描述，我们一下子就能发现问题出在哪里。</p>
<h2 id="use-">USE 💡</h2>
<p>现在我们已经了解了「监控哪些对象？」，以及尝试用「量化」这个法宝来「识别故障」。
那有没有一些最佳实践帮助大家高效的识别故障呢？这里我推荐 Brend Gregg 大神的 <a href="http://www.brendangregg.com/usemethod.html">USE 方法</a>。
Brend Gregg 是 Netflix 的首席 SRE，著有 <a href="http://www.brendangregg.com/sysperfbook.html">Systems Performance Book</a>，
目前已经出版中文版 <a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B0140I5WPK">性能之巅:洞悉系统、企业与云计算</a>。</p>
<p>USE 分别是三个单词的首字母缩写：</p>
<ul>
<li>Utilization：使用率，CPU running percent，硬盘的 IO</li>
<li>Saturation：饱和度，一般偏存储型资源，内存使用，硬盘使用</li>
<li>Error：错误数</li>
</ul>
<p>我们可以为每个资源找到各自的 USE 度量指标，具体的 Check List 清单可以参考
<a href="http://www.brendangregg.com/USEmethod/use-rosetta.html">USE Method: Rosetta Stone of Performance Checklists</a>。</p>
<p>这里举个例子，前段时间在设计 MySQL HA 方案时候，同时关注了 MySQL 的监控方案，
那么针对 MySQL，我们要做哪些监控呢？下面是使用 USE 方法设计出来的 SLI：</p>
<ul>
<li>Business
<ul>
<li>Questions：语句计总，Throughput</li>
<li>Slow_queries：慢查询计总，Error</li>
<li>Com_select：查询语句计总，Throughput</li>
<li>Com_insert：插入语句计总，Throughput</li>
<li>Com_update：更新语句计总，Throughput</li>
</ul>
</li>
<li>Threads &amp; Connections
<ul>
<li>Threads_connected：当前连接数，Utilization</li>
<li>Threads_running：当前使用中连接数，Utilization</li>
<li>Aborted_connects：尝试连接失败数，Error</li>
<li>Connection_errors_max_connections：由于连接数超标从而失败的连接数，Error</li>
</ul>
</li>
<li>Buffer
<ul>
<li>Innodb_buffer_pool_pages_total：内存使用页数，Utilization</li>
<li>Innodb_buffer_pool_read_requests：读请求数计总，Utilization</li>
</ul>
</li>
</ul>
<h2 id="完-">完 🏁</h2>
<p>如果你对我上面描述的还意犹未尽，建议你可以看 <a href="https://book.douban.com/subject/19992841/">Effective Monitoring and Alerting</a>。
虽然本书没有中文版，但是关于监控、报警的原理解析很到位，值得一看。
另外还有一本 <a href="https://book.douban.com/subject/26875239/">SRE: Google运维解密</a>，
里面有不少篇幅在讲「SLA」，也是和监控、报警息息相关的。</p>
<p>这次讲了一些概念性的内容，期望对大家有帮助，下一次我再分享一篇文章，聊聊 Metrics。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>XSS 攻击的处理</title>
      <link>https://blog.alswl.com/2017/05/xss/</link>
      <pubDate>Wed, 31 May 2017 22:04:00 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2017/05/xss/</guid>
      <description>这是一年前写的项目笔记，一直在我的待办事项里等待做总结，今天偶然翻到，就整理成文章发出来。 谨以此文怀念 乌云。 事情缘由 春节前的某一天，收到一封来自乌云（国内知名白帽子团队）的邮件， 告知我厂网站上出现一例 XSS 漏洞。 因为以前对 XSS 输入做过防御，还以为是某个前端 DOM 上的 XSS 漏洞， 后来仔细一看，不妙，是个影响甚大的存储型 XSS 漏洞。 这里简单科普一下 XSS 跨网站脚本 -维基百科，自由的百科全书 中介绍到： 跨网站脚本（Cross-</description>
      <content:encoded><![CDATA[<p>这是一年前写的项目笔记，一直在我的待办事项里等待做总结，今天偶然翻到，就整理成文章发出来。
谨以此文怀念 <a href="http://wooyun.org/">乌云</a>。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201705/wooyun.jpg" alt="201705/wooyun.jpg"  />


</p>
<hr />
<h2 id="事情缘由">事情缘由</h2>
<p>春节前的某一天，收到一封来自乌云（国内知名白帽子团队）的邮件，
告知我厂网站上出现一例 XSS 漏洞。
因为以前对 XSS 输入做过防御，还以为是某个前端 DOM 上的 XSS 漏洞，
后来仔细一看，不妙，是个影响甚大的存储型 XSS 漏洞。</p>
<p>这里简单科普一下 XSS
<a href="https://zh.wikipedia.org/zh-cn/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC">跨网站脚本 -维基百科，自由的百科全书</a>
中介绍到：</p>
<blockquote>
<p>跨网站脚本（Cross-site  scripting，通常简称为XSS或跨站脚本或跨站脚本攻击）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。
它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</p>
</blockquote>
<p>XSS 攻击可以分成两种，反射性 XSS / 存储型 XSS。前者是需要用户触发的 XSS，
针对当前用户的攻击行为。而后者存储型 XSS 则更为严重，一旦攻击代码被保存，
所有访问被攻击的页面，都会触发用户被攻击行为。</p>
<p>这次爆出的问题就是最严重的存储型 XSS，意味着每个访问到有问题页面的用户都会中招。
时间紧迫，问题必须被解决。</p>
<h2 id="xss-实现手段">XSS 实现手段</h2>
<p>在解决问题之前，需要对这个问题有必要的基础认识。
我们先看看 XSS 攻击是如何工作的，以及攻击者的目的是什么。</p>
<p>XSS 的原理是通过构造特殊的数据，并通过传递参数或者保存表单数据的方式，
让这些构建的数据破坏 DOM 结构，从而让自己预先构造数据中的 JS 脚本被执行。</p>
<p>检查存储型 XSS 漏洞的方法，可以在对应的 input field 里放入一些构造的数据，如果保存后可以被执行，就说明存在 XSS 漏洞。</p>
<p>常见的检测方法（来自 <a href="https://zh.wikipedia.org/zh-cn/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC#.E6.A3.80.E6.B5.8B.E6.96.B9.E6.B3.95">跨网站脚本 - 维基百科，自由的百科全书</a>：</p>
<pre tabindex="0"><code>&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;
=&#39;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;
&#34;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;
&lt;script&gt;alert(document.cookie)&lt;/script&gt;
&lt;script&gt;alert (vulnerable)&lt;/script&gt;
%3Cscript%3Ealert(&#39;XSS&#39;)%3C/script%3E
&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;
&lt;img src=&#34;javascript:alert(&#39;XSS&#39;)&#34;&gt;
&lt;img src=&#34;http://xxx.com/yyy.png&#34; onerror=&#34;alert(&#39;XSS&#39;)&#34;&gt;
（这个仅限IE有效）
</code></pre><p>攻击者通过 XSS 可以窃取用户的相关信息，如果用户是管理员，那么影响更大。
通过这些身份信息，攻击者可以进一步篡改信息或者进行诈骗，后果不堪设想。
PS：一个有效粗暴的方式，是将对公、对内系统的域名分离，对内部系统进行物理级别隔离。</p>
<h2 id="我厂历史上的处理方案">我厂历史上的处理方案</h2>
<p>XSS 问题又来已久，咱厂子开了这么久，历史上如何防御的呢？
答案是用了两个策略：第一个是使用 <a href="https://www.owasp.org/index.php/Main_Page">OWASP</a>
提供的库进行内容过滤，第二个是在存储数据时，存储了转义后的数据。</p>
<p>在技术上处理 XSS，有两种态度可以选择：第一种是前置过滤，即将用户所有数据都进行转义，
在输出时候在前端（模板渲染）层面直接输出。
第二种是用户输入的数据不经过转义就直接存储起来，前端在使用时候保证对数据进行转义。</p>
<p>我厂历史上使用的方案的前者，优点是在于前端不需要在每个地方转义，
避免某个地方忘记了转义，从而导致漏洞。缺点则是在输出内容到非 Web 客户端时候，比如
APP，需要进行额外的数据处理过程， 否则 HTMLEncode 的内容，在 APP
上面无法正确输出。</p>
<p>这个处理方案是稳妥的，那么为什么最近又暴露出问题了？
排查之后发现，原来最近有若干个服务迁移到了一个新系统，
而新系统在安全上面没有全局处理，所以爆出了漏洞。</p>
<h2 id="本次处理方案">本次处理方案</h2>
<p>知道了原因，那么可以快速解决问题了。在这次处理过程中，我们讨论了在当前移动平台增长迅速，Web 平台增长缓慢的大势下，能否直接存储用户原始数据？
而且由于规范制定不严格，目前系统内有些地方存储转码后数据，有些地方存储转码前数据。
导致在一些特殊的字符（颜文字）处理上不一致，从而导致在处理 <code>br</code> / <code>&lt;</code> 这类特殊字符时，表现不同。</p>
<p>由于 DB 中有部分数据转义处理，部分数据原文存储，所以先处理输出后敏感信息，在模板层面启用全局
encode。 将有危险的数据转移为在 HTML 文本。</p>
<p>PS：现代 Web 框架的模板渲染引擎，一般会默认开启 HTMLEncode，而
Freemarker 居然在 2.3.24-rc01 才支持，现在都没有发布，唉……</p>
<p>处理方案：</p>
<ul>
<li>开启全局 HTML 输出 Encode，有一个 <a href="http://watchitlater.com/blog/2011/10/default-html-escape-using-freemarker/">Default HTML-escape using Freemarker</a> 方案，可以默认开启 Html Encode，在这个处理方案中，需要注意有些地方真的需要输出原始 html，需要 <code>noescape</code> 特殊处理</li>
<li>检查所有前端操作，禁止字符串拼接，使用框架支持的模板进行渲染，拖小菊的福，新系统在这块工作完成度一直比较好</li>
<li>将 <a href="https://www.owasp.org/index.php/Main_Page">OWASP</a> 方案强制开启</li>
</ul>
<h2 id="其他-tips">其他 Tips</h2>
<p>OWASP 有一个很长的 <a href="https://www.owasp.org/index.php/SS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet">列表</a>，教导如何避免 XSS，里面提到了：</p>
<ul>
<li>为何以及如何进行「积极防御」，对立面是仅仅输出时候转义内容本身</li>
<li>几条对抗 XSS 的规则
<ul>
<li>尽量不在特定地方输出不可信变量：script / comment / attribute / tag / style， 因为逃脱 HTMl 规则的字符串太多了。</li>
<li>将不可信变量输出到 div / body / attribute / javascript tag / style 之前，对 <code>&amp; &lt; &gt; &quot; ' /</code> 进行转义</li>
<li>将不可信变量输出 URL 参数之前，进行 URLEncode</li>
<li>使用合适的 HTML 过滤库进行过滤</li>
<li>预防 DOM-based XSS，见 <a href="https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet">DOM based XSS Prevention Cheat Sheet</a></li>
<li>开启 HTTPOnly cookie，让浏览器接触不到 cookie</li>
</ul>
</li>
</ul>
<hr />
<p>最后送上一个 XSS 攻击工具 <a href="http://webxss.net/">http://webxss.net/</a>，知己知彼，百战不殆。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>👷如何做年前大扫除</title>
      <link>https://blog.alswl.com/2017/01/spring-cleaning/</link>
      <pubDate>Tue, 03 Jan 2017 23:20:50 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2017/01/spring-cleaning/</guid>
      <description>今年过年特别早，离春节只剩下二十多天了。 为期 7 天的春节里，工程师们不上班，那万一线上业务出现了故障怎么办？ 大公司的朋友们会安排专门的人进行值班（此处心疼一下那些需要大年三十还要值班保证高峰的工程师们）， 而作为创业团队人少，难做到在线值守，就需要对线上进行一些整理盘点，找出潜在问题，为春节长假做一些准备。 我们称之为年前大扫除。 大扫除需要做些什么呢，且听我一一道来。 PS: 冷知识，大扫除英文是 spring cleani</description>
      <content:encoded><![CDATA[<p>今年过年特别早，离春节只剩下二十多天了。
为期 7 天的春节里，工程师们不上班，那万一线上业务出现了故障怎么办？
大公司的朋友们会安排专门的人进行值班（此处心疼一下那些需要大年三十还要值班保证高峰的工程师们），
而作为创业团队人少，难做到在线值守，就需要对线上进行一些整理盘点，找出潜在问题，为春节长假做一些准备。</p>
<p>我们称之为年前大扫除。</p>
<p>大扫除需要做些什么呢，且听我一一道来。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201701/saber.jpeg" alt="201701/saber.jpeg"  />


</p>
<p>PS: 冷知识，大扫除英文是 spring cleaning，所以春节大扫除是 Spring Festival spring cleaning。</p>
<h2 id="大扫除的内容">大扫除的内容</h2>
<p>大扫除其实是一个查漏补缺+囤积粮草的事情。</p>
<p>查漏补缺，即找出潜在的问题。这些问题平时可能不会特意去查看，
借助大扫除这个运动，恰好进行盘点。
计算机的世界里，有一个方法论非常好使，在极多场景可以见到其身影：分层。
TCP 的七层模型，架构设计的 N 层 模型，都是对分层思想的使用。
查漏补缺也不例外，我们可以按照业务访问流程，将需要排查的问题拆分为：业务、应用、中间件、网络、物理、存储 etc。</p>
<p>通过分层，不仅仅完成了自上而下地遍历整个技术栈，也同时将不同模块的内容交给不同的责任方，
确保任务的分割。</p>
<p>分完模块，还要告知大家如何具体查找问题。
这里我介绍一个通用的方法：USE<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>：</p>
<blockquote>
<p>For every resource, check Utilization, Saturation, and Errors.</p>
</blockquote>
<p>USE 方法是从 Brend Gregg 那里学来的。
在技术设施的领域里，Resource 即是指各种类型的资源，比如 CPU、磁盘、网络、内存，
Utilization 指的是使用率，可以简单分为百分制和非百分制。
Saturation 是指饱和率，支持 queue 的资源，就会有这个指标。
Error 即错误，可以从错误统计和日志得知。<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<p>业务领域里面，USE 也有相对应的含义。以审核系统举例，
对应的 USE 可以理解为「审核应用实例跑的 CPU 占用如何，任务队列是否塞满，业务日志是否有异常」。</p>
<p>除了 USE 里面提到的指标，还有几个指标特别重要：
TPS 、Latency 和 Capacity。
这几个指标对性能敏感的尤为重要。
检查 USE 的同时，我们必须关注一下这三个指标，
确保 TPS / Latency 是否满足我们预期的 SLA。
哦？压根没有制定 SLA，不要慌，和历史数据对比，先制定一个粗糙的 SLA。
哦？连历史数据都没有？那只能找你 Leader 让他考量一下了。</p>
<p>负责每个子系统的同学，记得检查时候将这些收集到的数据列下来。
在 Metric 做的还不够完善时候，这些数据也是很宝贵的。</p>
<p>在我看来，检查 USE / TPS / Latency ，<strong><strong>最大的作用是将抽象的可用性指标描述为几个易于理解的数值进行量化。
一旦能够量化，就可以对比、观测、监控，并且 Review 起来也异常轻松</strong></strong>。</p>
<h2 id="应对方案">应对方案</h2>
<p>检查出问题之后，就要考虑应对了。时间急任务多，我们的应对方案是是囤积粮草 / 写救命笔记。</p>
<p>囤积粮草比较好理解，<strong><strong>基于已有的容量预估，为容易出问题的系统提供一份冗余</strong></strong>。
有些团队平时做基础设施就比较，做 Scale 就是小轻松。
那平时 Scalable 做的不好的朋友，就只能将应用实例多开一些，以避免临时出现的流量波动。</p>
<p>无状态的服务好搞，有状态的 DB 就很难在短时间内做 Scale。
检查这些服务的容量，如果重点资源临近阈值，比如 DB 的硬盘资源，缓存的内存容量。
核心服务的余量在检查中真的发现问题的话，那也只能短期内做扩容了。</p>
<p>对于小团队来说，春节长假的特殊性在于响应会变慢甚至是联系不上。
一旦线上有异常，可能找不到合适的人员来进行处理。
所以第二条写救命笔记则更为重要。
「Google SRE」里面有个小段子，一个绝对不能被按的按钮，
这个按钮会清空内存数据，在飞行过程中被宇航员按了。幸亏美女工程师（下图）写了相关的救命手册，
专门写了针对这种情况的操作，救了这些宇航员的命。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201701/sre.jpeg" alt="201701/sre.jpeg"  />


</p>
<p>图片来自 「Google SRE」</p>
<p>从这个故事里面可以看到，一个紧急操作手册是多么重要。
<strong><strong>所以在大扫除期间，我们还要补一补平时的文档，将一些常见问题 / 常规操作记录下来。</strong></strong>
步骤需要细致到能让让每个远程值班的同学做到 step by step 操作。</p>
<hr />
<p>啰嗦了这么多，相信大家对大扫除要做些什么已经有所印象了，祝大家过个好年，流量涨涨涨，还能平平安安的。</p>
<div class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn:1">
<p>[The USE Method] <a href="http://www.brendangregg.com/usemethod.html">http://www.brendangregg.com/usemethod.html</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>[USE Method: Linux Performance Checklist] <a href="http://www.brendangregg.com/USEmethod/use-linux.html">http://www.brendangregg.com/USEmethod/use-linux.html</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>🔑 也谈 HTTPS - 如何内测</title>
      <link>https://blog.alswl.com/2016/12/https-2/</link>
      <pubDate>Thu, 08 Dec 2016 20:16:26 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2016/12/https-2/</guid>
      <description>(图片来自 茶杯中的可爱小白鼠 壁纸 - 2560x1920－堆糖，美好生活研究所) 在上篇文章 🔒 也谈 HTTPS - HTTPDNS + HTTPS 中， 我们谈了如何基于 HTTPDNS 来部署无坚不摧的 HTTPS 通信环境， 这次我们讨论另外一个比较头疼的问题：部署。 小站点部署 HTTPS 相对成本低，改改前端代码，就可以上线了。 但作为业务有一定复杂度的大网站，就没办法这么暴力上线了。 前端在基础库中调整 Scheme 之后，仍然可能存在很多边边角角没有覆盖到。 比如 JS 里面写死了 HTTP，那在 HTTPS 下请</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201612/mouse.jpeg" alt="201612/mouse.jpeg"  />



(图片来自 <a href="https://www.duitang.com/blog/?id=48013745">茶杯中的可爱小白鼠 壁纸 - 2560x1920－堆糖，美好生活研究所</a>)</p>
<p>在上篇文章 <a href="https://blog.alswl.com/2016/11/https-1/">🔒 也谈 HTTPS - HTTPDNS + HTTPS</a> 中，
我们谈了如何基于 HTTPDNS 来部署无坚不摧的 HTTPS 通信环境，
这次我们讨论另外一个比较头疼的问题：部署。</p>
<!-- more -->
<p>小站点部署 HTTPS 相对成本低，改改前端代码，就可以上线了。
但作为业务有一定复杂度的大网站，就没办法这么暴力上线了。</p>
<p>前端在基础库中调整 Scheme 之后，仍然可能存在很多边边角角没有覆盖到。
比如 JS 里面写死了 HTTP，那在 HTTPS 下请求 HTTP XHR 的话，
浏览器会将请求拦截掉。
一旦出现这种故障，用户就无法正常使用业务，小白用户往往也不懂得自己将 <code>https://</code> 换成 <code>http://</code> 使用。</p>
<p>解决的思路是足够的内测，找一群人帮我在 HTTPS 环境下使用足够长时间。
让他们当小白鼠，提前发现问题并解决。
于是，我把目光转向了身边的一大大群小白鼠，整个办公室的同事~😄</p>
<p>没错，<strong><strong>我要强制所有同事使用 HTTPS 的公司网站</strong></strong>，从而靠他们帮我发现问题。</p>
<p>靠发邮件、QQ 广播呼吁大家使用 HTTPS 站点的方法，估计是不行的。
没有利益驱动，推动力是不足的，我必须想点强制的手段让他们使用 HTTPS。</p>
<p>有三种方法来达到这个效果：</p>
<ol>
<li>业务系统内入口判断用户身份，是雇员的话，切换到 HTTPS</li>
<li>Nginx 入口系统判断 IP 来源，办公室 IP 则切换到 HTTPS</li>
<li>改造办公室网络，访问站点时候，自动切换到 HTTPS</li>
</ol>
<p>为了避免对线上业务系统、基础设施造成影响，我采用了第三条方案。</p>
<p>说干就干，直接对公司网络出口设备是 ROS<a href="http://wiki.mikrotik.com/wiki/Main_Page">via</a> 动起刀子。</p>
<p>实现的原理如下：</p>
<ul>
<li>A：办公室网络的 🐁 们请求站点 <a href="http://www.duitang.com">http://www.duitang.com</a></li>
<li>B：操作 RouterOS 的防火墙，将 dst 为 <a href="https://www.duitang.com">www.duitang.com</a> IP 的 TCP 请求都 dst-nat 到新的一台 Nginx 服务器 proxy.duitang.com</li>
<li>C：这台 proxy.duitang.com 做过特别定制，将所有针对 *.duitang.com 请做一次 302 请求，将 <a href="http://www.duitang.com">http://www.duitang.com</a> 请求都转发到 <a href="https://www.duitang.com">https://www.duitang.com</a></li>
<li>D：Client 收到 302 请求，重新请求 <a href="https://www.duitang.com">https://www.duitang.com</a></li>
<li>E：同 B</li>
<li>F：proxy.duitang.com 将请求转发到真正的 <a href="https://www.duitang.com">www.duitang.com</a> 服务器</li>
</ul>
<p>PS：这里要小心的是，需要配置 proxy.duitang.com 的 <code>resolver</code> 避免 Nginx 内部请求。</p>
<p>流程图：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201612/https_ros_process.jpg" alt="201612/https_ros_process.jpg"  />


</p>
<p>这样操作之后，在办公室网络下，所有访问公司网站的 HTTP 流量都会跳转到 HTTPS。</p>
<p>PS：我原始方案想使用 ROS 的 L7 防火墙 直接抓 HTTP 包，match HTTP 头数据，
再修改返回的 TCP 包。
但测试下来发现 ROS L7 Firewall 不支持写 TCP 数据。
所以我最后只能使用中间跳转的方案。</p>
<p>如果不是使用 ROS 的朋友也不用担心，原理和流程已经讲清楚了，
无非是使用 Cisco / Huawei 网络设备的防火墙命令实现需要的功能。</p>
<hr />
<p>上篇文章发完之后，好几个朋友问我 IP 证书供应商的事情。我就简单说一下我了解的情况。</p>
<p>国内 SSL 证书供应商们会给他们兜售的产品起各种各样花里胡哨的名字，
什么超真、超强、超安、超快，国外有些企业也会搞什么 Pro / Super / Premium / Essential，
其实 SSL 证书的区分，笼统来说就三种类型：DV / OV / EV，
Domain Validation / Orgnization Validation / Extented Validation。
他们区别除了字面意思，就是所有权审核流程一个比一个麻烦。</p>
<p>想基于 IP 直接搞所有权审核，要看对应供应商的证书是否支持。
去年年底我做了一个调查，支持 IP 证书的厂家如下：</p>
<ul>
<li>Rapid SSL 不支持 ip</li>
<li>wosign OV 级别支持
<ul>
<li>OV 需要验证 需要验证申请单位的营业执照、等其他证明文件</li>
<li>浏览器支持情况
<ul>
<li>Firefox 32 <a href="https://mozillacaprogram.secure.force.com/CA/IncludedCACertificateReport">https://mozillacaprogram.secure.force.com/CA/IncludedCACertificateReport</a></li>
<li>交叉认证了 Startcom 的证书，可以支持老版本</li>
</ul>
</li>
</ul>
</li>
<li>GlobalSign OV 支持
<ul>
<li>$349 * 6 * 8 = 16752</li>
<li><a href="https://support.globalsign.com/customer/portal/articles/1216536-securing-a-public-ip-address---ssl-certificates">https://support.globalsign.com/customer/portal/articles/1216536-securing-a-public-ip-address&mdash;ssl-certificates</a></li>
<li>需要认证 RIPE ip， <a href="https://apps.db.ripe.net/search/query.html?searchtext=221.228.82.178#resultsAnchor">https://apps.db.ripe.net/search/query.html?searchtext=221.228.82.178#resultsAnchor</a></li>
</ul>
</li>
<li>Geotrust 明确表示不支持 <a href="https://www.geocerts.com/faq#Q47">https://www.geocerts.com/faq#Q47</a></li>
</ul>
<p>现在 Wosign 爆了丑闻，于是支持 IP SSL 又少了一家。
只剩下 GlobalSign 了，但是 GlobalSign OV 又贵审核又麻烦，
不知道看到此文的大神们有没有更好的推荐。</p>
<hr />
<p>参考链接：</p>
<ul>
<li><a href="http://serverfault.com/questions/193775/ssl-certificate-for-a-public-ip-address">domain name - SSL certificate for a public IP address? - Server Fault</a></li>
<li><a href="http://wiki.mikrotik.com/wiki/Manual:IP/Firewall/Filter">ROS Filter</a></li>
<li><a href="http://wiki.mikrotik.com/wiki/Manual:IP/Firewall/NAT">ROS NAT</a></li>
<li><a href="http://wiki.mikrotik.com/wiki/Manual:IP/Firewall/L7">ROS Firewall L7</a></li>
<li><a href="http://forum.mikrotik.com/viewtopic.php?f=13&amp;t=62152">How to block and redirect website - MikroTik RouterOS</a></li>
<li><a href="http://forum.mikrotik.com/viewtopic.php?t=39837">Mikrotik IP REDIRECT using firewall - MikroTik RouterOS</a></li>
<li><a href="http://forum.mikrotik.com/viewtopic.php?t=88049">Redirect all traffic from a spesific ip number to a web page - MikroTik RouterOS</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>🔒 也谈 HTTPS - HTTPDNS &#43; HTTPS</title>
      <link>https://blog.alswl.com/2016/11/https-1/</link>
      <pubDate>Wed, 30 Nov 2016 22:02:23 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2016/11/https-1/</guid>
      <description>最近谈论 HTTPS 的文章很多，其原因之一是运营商作恶底线越来越低，动不动就插播广告， 前两天小米还联合几家公司发文 关于抵制流量劫持等违法行为的联合声明 痛斥某些运营商。 另一方面也是苹果 ATS 政策的大力推动，逼迫大家在 APP 中全部使用 HTTPS 通信。 上 HTTPS 的好处很多：保护用户的数据不外泄，避免中间人篡改数据， 对企业信息进行鉴权。 关于 HTTPS 如何购买证书，如何部署，网上的教程已经太多了，实践起来没有太大的难处。 我们在部署 HTTPS 的时候，遇到了</description>
      <content:encoded><![CDATA[<p>最近谈论 HTTPS 的文章很多，其原因之一是运营商作恶底线越来越低，动不动就插播广告，
前两天小米还联合几家公司发文 <a href="http://weibo.com/1771925961/Da1aopxLQ?refer_flag=1001030103_&amp;type=comment#_rnd1480392491936">关于抵制流量劫持等违法行为的联合声明</a> 痛斥某些运营商。
另一方面也是苹果 <a href="https://techcrunch.com/2016/06/14/apple-will-require-https-connections-for-ios-apps-by-the-end-of-2016/">ATS</a> 政策的大力推动，逼迫大家在 APP 中全部使用 HTTPS 通信。
上 HTTPS 的好处很多：保护用户的数据不外泄，避免中间人篡改数据，
对企业信息进行鉴权。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201611/https.png" alt="201611/https.png"  />


</p>
<p>关于 HTTPS 如何购买证书，如何部署，网上的教程已经太多了，实践起来没有太大的难处。
我们在部署 HTTPS 的时候，遇到了一些新问题，首当其冲的就是 HTTPS 部分网络不可访问的问题：</p>
<blockquote>
<p>尽管使用了 HTTPS 技术，部分邪恶的运营商，仍然使用 DNS 污染技术，让域名指向的他们自己服务器
而这些服务器并没有部署 SSL 服务（就算部署了，也会触发 SSL 证书 Common name 不一致报警），
导致 443 端口直接被拒绝。</p>
</blockquote>
<!-- more -->
<p>这个问题不解决，强行上 HTTPS 的话，会导致一部分用户出现无法访问网站
一旦用户不爽了，轻则对产品不信任，重则直接导致用户流失。</p>
<p>运营商为了赚广告钱、省网间结算是不择手段的。
他们普遍使用的劫持手段是通过 ISP提供的 DNS 伪造域名。
那有没有什么方法可以解决 DNS 劫持呢？
业界有一套解决这类场景的方案，即 HTTPDNS。</p>
<p>HTTPDNS 的原理很简单，将 DNS 这种容易被劫持的协议，转为使用 HTTP 协议请求 Domain &lt;-&gt; IP 映射。
获得正确 IP 之后，Client 自己组装 HTTP 协议，从而避免 ISP 篡改数据。</p>
<p>有两篇文章很清晰的讲解了 HTTPDNS 的细节：</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODgyNzcwMw==&amp;mid=201837080&amp;idx=1&amp;sn=b2a152b84df1c7dbd294ea66037cf262&amp;scene=2&amp;from=timeline&amp;isappinstalled=0#rd">【鹅厂网事】全局精确流量调度新思路-HttpDNS服务详解</a>
<ul>
<li>腾讯这篇文章时间点是 2014 年，说明这个方案上线更早，也较为成熟</li>
</ul>
</li>
<li><a href="https://developers.google.com/speed/public-dns/docs/dns-over-https">DNS-over-HTTPS  |  Public DNS  |  Google Developers</a>
<ul>
<li>该方案更为先进，使用 HTTP 替换为 HTTPS，减少一个隐患点</li>
</ul>
</li>
</ul>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201611/httpdnsjbyl.png" alt="201611/httpdnsjbyl.png"  />


</p>
<p>点击 <a href="https://dns.google.com/resolve?name=www.duitang.com">https://dns.google.com/resolve?name=www.duitang.com</a> /
<a href="http://119.29.29.29/d?dn=www.duitang.com">http://119.29.29.29/d?dn=www.duitang.com</a> 感受一下 DNS-over-HTTPS / HTTPDNS。</p>
<h2 id="单-ip-多域名支持">单 IP 多域名支持</h2>
<p>这个方案看似完美，但是在实际生产中，会遇到一个问题。</p>
<p>Android / iOS 在操作系统级别对 HTTPS 通信是提供了封装。
APP 无法在发起连接时候，也没有权限直接操作 socket。
所以尽管 APP 拿到了域名对应的 IP，却没有办法让这个 IP 在 HTTPS 里生效。</p>
<p>解决的思路很暴力：<strong>彻底放弃域名系统，完全使用基于 IP 系统的通讯。</strong></p>
<p>原本请求 <code>https://www.duitang.com</code> 的 request，
调整为请求 <code>https://221.228.82.181</code>。</p>
<p>OK，做到这一步，我们就可以跟运营商劫持说拜拜了。</p>
<p>不，还没结束。</p>
<p>完全搞定运营商之后，这 IP 方案给我们自己带来一个困扰：
<strong>Nginx 服务器无法通过 Host 来识别不同域名下面的请求了！！！</strong>
在由于使用一个独立 IP，会导致所有域名请求混在一起，无法分别。
大公司可以 dedicated IP，小公司就玩不起了。</p>
<p>为了解决同一个 IP 下面多个域名的问题，我们引入了一个URL参数： <code>__domain</code>。
当请求 IP 域名时候，必须带着这个参数，服务器会将请求域名解析出来，再分发到对应的域名。</p>
<p>实现这个逻辑的 Nginx 核心代码：</p>
<pre tabindex="0"><code>set $query_domain $arg___domain;
if ($query_domain !~ &#39;(www|a|b)\.example\.com&#39;) {
    rewrite ^ http://www.example.com/404/ redirect;
}
set $my_host $query_domain;
location / {
    proxy_set_header Host $my_host;
    proxy_set_header X-REAL-IP $remote_addr;
    proxy_pass $scheme://127.0.0.1;
}
</code></pre><p>最后一个注意事项是，记得调整 Nginx 配置的 remote_addr，否则都变成了 127.0.0.1，
也许会导致其他一些策略失效。</p>
<p>完美收工，效果如下：<a href="https://221.228.82.181/?__domain=www.duitang.com">https://221.228.82.181/?__domain=www.duitang.com</a>。</p>
<p>恭喜你，已经掌握核心科技了，再也不怕运营商瞎折腾了，从此走上了业务蓬勃发展的金光大道……☀️</p>
<p>下一篇文章，我会再谈谈如何做 HTTPS 的「内测」，避免将线上业务一次性切到 HTTPS 导致不少边边角角业务无法正常使用。</p>
<hr />
]]></content:encoded>
    </item>
    
    <item>
      <title>API 集成测试实践</title>
      <link>https://blog.alswl.com/2016/08/api-integration-test/</link>
      <pubDate>Sun, 14 Aug 2016 19:08:20 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2016/08/api-integration-test/</guid>
      <description>为了提高测试，工程师需要对自己提交的产物进行测试，一般是单元测试、集成测试。 之后提交物流转到 QA 团队，QA 团队根据需求描述对提交物进行测试， 这个测试过程非常耗费人力。 尤其是当开发交付的质量不高时候，很可能自身没有经过测试，会遇到主干流程都无法进行的状况。 如果在 QA 人工介入测试之前，就进行一轮黑盒自动化集成测试，可以大大地提高 QA 团队的工作效率。 基于这样的判断，我们团队花了一些时间，将基于 API 的自动化测试系</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201608/abao_thumbnail.png" alt="abao.png"  />


</p>
<p>为了提高测试，工程师需要对自己提交的产物进行测试，一般是单元测试、集成测试。
之后提交物流转到 QA 团队，QA 团队根据需求描述对提交物进行测试，
这个测试过程非常耗费人力。
尤其是当开发交付的质量不高时候，很可能自身没有经过测试，会遇到主干流程都无法进行的状况。</p>
<p>如果在 QA 人工介入测试之前，就进行一轮黑盒自动化集成测试，可以大大地提高 QA 团队的工作效率。
基于这样的判断，我们团队花了一些时间，将基于 API 的自动化测试系统搭建起来。
现在将这个系统的选型和运行状况拎出来，和大家分享。</p>
<h2 id="确认测试范围目标和意义">确认测试范围、目标和意义</h2>
<ul>
<li>范围
<ul>
<li>后台输出的 API 级别 URL</li>
<li>使用场景
<ul>
<li>打包时候的冒烟</li>
<li>Dev / QA 手工添加添加新特性用例</li>
</ul>
</li>
</ul>
</li>
<li>目标
<ul>
<li>覆盖大部分的 URL，当期设计为 top 10 URL，仅包含 GET 接口</li>
<li>选型时，需要考虑非幂等（POST / DELETE / PUT）等接口</li>
</ul>
</li>
<li>意义
<ul>
<li>提高开发效率，一种自动化的 IT 测试方案</li>
<li>提高测试效率，减少人工集成测试成本</li>
<li>提高工程质量，通过覆盖率提升，保证工程质量逐步提升，放心开发新功能</li>
</ul>
</li>
</ul>
<h2 id="特性需求">特性需求</h2>
<p>选型一个系统，不是看市面上有哪些可以供选择，而是看我需要什么样特性的一款产品。
如果自己的需求和市面上的现成产品差异过大，也可以考虑自己定制。</p>
<ul>
<li>Required
<ul>
<li>开源</li>
<li>免费</li>
<li>使用 DSL 或者简单代码描述测试用例</li>
<li>支持细粒度的单 API 测试和构建带过程的测试用例</li>
<li>HTTP API</li>
</ul>
</li>
<li>Optional
<ul>
<li>CI 集成</li>
<li>UI</li>
</ul>
</li>
</ul>
<h2 id="挑选出来的选型和评价">挑选出来的选型和评价</h2>
<ul>
<li><a href="https://www.runscope.com/">API Monitoring and Testing · Runscope</a>
<ul>
<li>收费</li>
<li>非开源</li>
<li>有监控特性</li>
</ul>
</li>
<li><a href="https://www.atlassian.com/software/bamboo">Bamboo - Continuous integration, deployment &amp; release management | Atlassian</a>
<ul>
<li>收费</li>
<li>CI</li>
</ul>
</li>
<li><a href="https://circleci.com/features/">Continuous Integration Product and Features - CircleCI</a>
<ul>
<li>CI</li>
<li>收费</li>
</ul>
</li>
<li>Sauce Labs
<ul>
<li>客户端测试，收费</li>
</ul>
</li>
<li>Apiary
<ul>
<li>API 设计工具 + API Test</li>
</ul>
</li>
<li><a href="http://frisbyjs.com/">http://frisbyjs.com/</a>
<ul>
<li>code</li>
<li>npm</li>
<li>open source</li>
<li>NO UI</li>
</ul>
</li>
<li><a href="https://github.com/vowsjs/api-easy">https://github.com/vowsjs/api-easy</a>
<ul>
<li>同上</li>
<li>真是热爱造轮子的 JS 生态圈</li>
</ul>
</li>
<li><a href="https://github.com/visionmedia/supertest">https://github.com/visionmedia/supertest</a>
<ul>
<li>同上</li>
<li>从 Star 看，这个质量最高</li>
</ul>
</li>
<li><a href="http://dareid.github.io/chakram/">http://dareid.github.io/chakram/</a>
<ul>
<li>code</li>
<li>npm</li>
<li>open source</li>
<li>NO UI</li>
</ul>
</li>
<li><a href="https://vrest.io/">https://vrest.io/</a>
<ul>
<li>收费</li>
<li>不开源</li>
<li>无插件</li>
</ul>
</li>
<li><a href="http://swagger.io/open-source-integrations/">http://swagger.io/open-source-integrations/</a>
<ul>
<li>for API</li>
<li>生态环境强大</li>
<li><a href="https://github.com/cachecontrol/hippie-swagger">https://github.com/cachecontrol/hippie-swagger</a></li>
<li>用户端似乎在尝试用 swagger</li>
</ul>
</li>
<li><a href="http://robotframework.org/">http://robotframework.org/</a>
<ul>
<li>一个通用自动化测试工具</li>
<li>DSL</li>
<li>扩展性较强</li>
<li>活跃度在降低 <a href="https://github.com/robotframework/robotframework/graphs/contributors">https://github.com/robotframework/robotframework/graphs/contributors</a></li>
</ul>
</li>
<li><a href="https://cucumber.io/">https://cucumber.io/</a>
<ul>
<li><a href="https://cucumber.io/docs/reference">https://cucumber.io/docs/reference</a></li>
<li>和 Robotframework 相似，通用自动化测试工具</li>
<li>DSL</li>
<li>活跃度降低 <a href="https://github.com/cucumber/cucumber-jvm/graphs/contributors">https://github.com/cucumber/cucumber-jvm/graphs/contributors</a></li>
</ul>
</li>
<li><a href="https://www.solanolabs.com/">https://www.solanolabs.com/</a>
<ul>
<li>Airbnb 在用</li>
<li>收费</li>
<li>云端的通用测试环境</li>
</ul>
</li>
<li><a href="https://github.com/christophd/citrus">https://github.com/christophd/citrus</a>
<ul>
<li><a href="http://www.citrusframework.org/">http://www.citrusframework.org/</a></li>
<li>依赖 mvn / ant，离代码太近</li>
<li>项目不够活跃</li>
</ul>
</li>
<li>代码内测试
<ul>
<li>src/it/com/duitang/xxx</li>
<li>eg. tritornis</li>
<li>Spring
<ul>
<li><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/integration-testing.html">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/integration-testing.html</a></li>
<li><a href="http://docs.spring.io/autorepo/docs/spring-framework/3.2.x/spring-framework-reference/html/testing.html">http://docs.spring.io/autorepo/docs/spring-framework/3.2.x/spring-framework-reference/html/testing.html</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这部分工作，是和团队的其他成员一起去看的，大家各自分头寻找一些产品，然后进行评测，给出结论。</p>
<p>经过讨论，我们将重点关注放在这么几款下面：</p>
<ul>
<li>supertest</li>
<li>robotframework</li>
<li>swagger</li>
<li>讨论时候的新发现 <a href="https://github.com/svanoort/pyresttest">https://github.com/svanoort/pyresttest</a></li>
</ul>
<h2 id="搭建-demo进行试用">搭建 demo，进行试用</h2>
<p>在确定选用那几款产品之后，就可以集中精力在几款候选者里面。搭建相应的环境，对他们进行实际测试。</p>
<p>supertest：</p>
<ul>
<li>功能太简单了，简单到几乎可以自己写掉，不算一个 test framework</li>
</ul>
<p>pyresttest：</p>
<ul>
<li>哈哈哈，YAML based，dreamed feature</li>
<li>支持 YAML / extractor / validator</li>
<li>天生支持 host 为参数</li>
<li>create for me!!!</li>
</ul>
<p>hippie-swagger：</p>
<ul>
<li>在使用上，和 supertest 差异不大</li>
<li>仍然需要自己定义，在 swagger 描述文件不存在时候会抛错，描述文件不符合时会抛错</li>
</ul>
<p>robotframework：</p>
<ul>
<li>较为复杂</li>
<li>有 YAML 了，不用试了</li>
</ul>
<h2 id="使用感觉">使用感觉</h2>
<p>经过一个季度的试用，我们基于 pyresttest 的项目 abao 运行较稳定。
尽量在工程师提交代码之后，运行一次，从而可以在早期发现问题。</p>
<p>由于是基于 Python 的源代码，我们还给 pyresttest 开发了几款插件：</p>
<ul>
<li>cookie_extractor：用来解析特定的 cookie</li>
<li>file_choice_generator：从文件随机选择预设数据</li>
<li>file_seq_generator：从文件顺序选择预设数据</li>
</ul>
<p>在和 CI 的配合方面，我们在 Jinkins 搭建了 abao / abao-master 项目，
前者响应每次 Push 请求，都会自动构建一遍，后者每天凌晨会将 master 运行一遍。</p>
<p>感谢项目贡献者：</p>
<pre tabindex="0"><code>project  : abao
 repo age : 5 months
 active   : 32 days
 commits  : 109
 authors  :
    39  Chery.Peng  35.8%
    33  3D          30.3%
    17  yanqi.chen  15.6%
    11  橙子        10.1%
     7  fiona66     6.4%
     2  雪糕        1.8%
</code></pre><hr />
<p>参考文档</p>
<ul>
<li><a href="https://github.com/integrations">Integrations Directory</a></li>
<li><a href="http://www.infoq.com/cn/search.action?queryString=%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95&amp;page=1&amp;searchOrder=&amp;sst=guKeEhPzzhUs7xpS">http://www.infoq.com/cn/search.action?queryString=%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95&amp;page=1&amp;searchOrder=&amp;sst=guKeEhPzzhUs7xpS</a></li>
<li><a href="http://www.infoq.com/cn/news/2014/02/autotest-2013">http://www.infoq.com/cn/news/2014/02/autotest-2013</a></li>
<li><a href="http://www.infoq.com/cn/articles/cucumber-robotframework-comparison">http://www.infoq.com/cn/articles/cucumber-robotframework-comparison</a></li>
<li><a href="http://www.infoq.com/cn/articles/http-api-automated-test-from-manual-to-platform">http://www.infoq.com/cn/articles/http-api-automated-test-from-manual-to-platform</a></li>
<li><a href="http://nerds.airbnb.com/testing-at-airbnb/">http://nerds.airbnb.com/testing-at-airbnb/</a></li>
<li>Google keywords
<ul>
<li>integration api test framework</li>
<li>github intergration test</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>搞定暴涨的流量</title>
      <link>https://blog.alswl.com/2016/06/capacity-planning/</link>
      <pubDate>Sun, 19 Jun 2016 23:57:39 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2016/06/capacity-planning/</guid>
      <description>2013 年左右，我司业务发展迅速，每天晚上都会面临服务器濒临崩溃情况。 我相信每个高速发展的互联网企业在某个阶段都会面临这样的情形，比如去年爆红的「足迹」。 过程往往是：线上出现故障，手机会收到报警，然后登录到服务器上去解决问题。 处理这种问题工种现在有一个时髦的名称，叫做「SRE（Site Reliability Engineer）」系统可用性工程师。 虽然我常常救火，但是我还是想尽可能避免线上发生故障。「最好的消息，就是没有消息。</description>
      <content:encoded><![CDATA[<p>2013 年左右，我司业务发展迅速，每天晚上都会面临服务器濒临崩溃情况。
我相信每个高速发展的互联网企业在某个阶段都会面临这样的情形，比如去年爆红的「足迹」。
过程往往是：线上出现故障，手机会收到报警，然后登录到服务器上去解决问题。
处理这种问题工种现在有一个时髦的名称，叫做「SRE（Site Reliability Engineer）」系统可用性工程师。</p>
<p>虽然我常常救火，但是我还是想尽可能避免线上发生故障。「最好的消息，就是没有消息。」
减少故障出现概率，增强系统可用性，降低故障处理时间是 SRE 的最大课题。
在这里有最常用的两个手段，一个是优化性能，一个是做好容量规划和扩展。
这里我着重讨论后者「容量规划」。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201606/message.png" alt="看我的一堆报警消息"  />


</p>
<p>^ 看我的一堆报警消息</p>
<!-- more -->
<h2 id="面临的问题">面临的问题</h2>
<p>面对暴涨流量，一边是业务方的满心欢喜，一边就是工程师的烦恼和压力了。
也许是一个受欢迎的功能上线了，或者是某个社会活动导致流量爆发，系统开始出现高延迟，磁盘 IO 不够用了。
也许是 DB 第一个倒下，也许是 RPC 系统第一个倒下……
呃，大神可能会说，我艹，RPC 系统第一个倒下还搞个屁啊，赶紧倒闭算了。</p>
<p>核心的问题就是，在现有性能下面，在面临可能的大流量冲击时候，如何做到不慌不忙，能够 handle 住突如其来的流量？</p>
<h2 id="设定容量目标">设定容量目标</h2>
<p>在解决这个问题之前，我们得先考虑清楚，我们到底要多强的流量处理能力。
如果今天我们只是一个两三台服务器的小团队，却企图设计一个能够抗住 1 亿 pv 访问的系统，
显然是不现实的，至少是不经济的。</p>
<p>衡量系统容量的指标可以简化为在什么流量下面，提供什么样的可用性保证。
一个实际的样例是，在 1 亿 pv 下面，提供 99.99% 的可用性，
其可用性的评判标准是「服务器在 200ms 内返回正确的数据」。</p>
<p>这里有一个重要的概念，可用性保证，术语是服务等级协议（SLA）。
这个指标可以从大部分标准云供应商的标准条款里看到，比如我司机房供应商提供的可用性保证是 99.9%。
阿里云 ECS 的 SLA 是「99.95%」，统计周期是 1 个月
（如果故障时间低于 5 min，不计入故障时间，云供应商都这样，特别霸权）。</p>
<p>一个对 SLA 的直观认识是（具体数据来自 <a href="https://en.wikipedia.org/wiki/High_availability#Percentage_calculation">High availability - Wikipedia, the free encyclopedia</a>）：</p>
<ul>
<li>99.0% 意味着一年有 87 天不可用</li>
<li>99.5% 意味着一年 1.83 天不可用</li>
<li>99.9% 意味着一年 8.76 小时不可用</li>
<li>99.99% 意味着一年 52.56 分钟不可用</li>
<li>99.999% 意味着一年 5 分 15 秒不可用，这是高可用的一般标准</li>
</ul>
<p>设定越高的 SLA 的成本越高，具体 SLA 的设定是成本、收益、期望的平衡。
不同的业务需要的 SLA 也不一样，一般认为 99.9% 基本可用，99.99% 可用性较高，
99.999% 为高可用。</p>
<p>有些云供应商号称 8 个 9，9 个 9，那往往都是对于存储服务里面的数据不丢失这个指标。
除了忽悠忽悠人，这个 SLA 没什么用的。</p>
<h2 id="测量">测量</h2>
<p>做一件伟大事情时候，先有目标，下一步如果是迈出脚步出去闯荡，那么往往换来的是一个身心疲惫的自己。
更稳当的做法是，先摸摸清楚，自己有几把刷子，是不是还要再练练，有没有资格上战场。
没有 Profiling，就是瞎子，根本不用谈优化和容量规划。</p>
<p>对于一般的业务场景而言，常见的测量指标分为三类：</p>
<ul>
<li>服务器的硬件指标（CPU、内存、硬盘 IO、硬盘容量、网络）</li>
<li>服务的软件指标（QPS / latency / pool）</li>
<li>业务的数据指标（核心业务指标，比如注册数，核心动作次数）</li>
</ul>
<p>我司的实践情况是这样的，我们使用 Zabbix 测量服务器，用自己设计的系统收集服务数据，使用 Grafana 呈现。
后者被设计到 RPC 系统内部，数据是全量收集。
我司在业务层面的数据监控做的还不足，这种不足不仅仅体现在数据的全面性上面，还体现在相关成员（比如产品汪）对数据的利用率上面。</p>
<p>除了测量线上的实施数据，了解某个设施的性能极限也是很重要，目前常见的测量方式是：</p>
<ul>
<li>模拟流量进行测试</li>
<li>在线上进行测试，并实时跟踪进展情况，出现异常时候，停止流量切入</li>
<li>从线上引入流量到测试环境进行测试</li>
</ul>
<p>我发现，第一种方法往往不准，第三种方法对于小团队来说，成本太高。第二种方法是最粗暴和有效的。</p>
<h2 id="预警和提醒">预警和提醒</h2>
<p>仅仅知道当前系统的性能表现是不足的，重要的如何将这些数据利用起来，对未来系统增长进行预估。
流量增长 vs 资源消耗，这个曲线大部分情况是线性的，有些情况确实指数增长的。</p>
<p>常见的做法是，给核心指标设置一个阈值（比如 80% 磁盘使用率，40% 磁盘 IO 利用率），当监控的数据到达这个阈值时候。
就必须进行容量扩充，进行负载均衡。</p>
<p>一个从运维同学身上学到的是，提前采购一些设备放到机房里面，比如硬盘、内存，别到时候供应商来不及供货。
必要库存可以降低 MTBF。</p>
<p>除了设定阈值报警，应当定期跑一些脚本获得数据。定期检查报警系统，避免报警系统失效。</p>
<h2 id="必选项---scalable">必选项 - Scalable</h2>
<p>上文写到，「必要时候进行容量扩充，进行负载均衡」。
这点的提出，意味这需要<strong>保证基础设施是可扩展的，支持负载均衡，支持硬件扩容</strong>。</p>
<p>Web 系统比较容易做到横向扩容，使用 Nginx / LVS 等负载均衡即可。
中间件服务一般也是在设计时候就考虑了扩展。（什么？你们家 RPC 系统设计调用不支持扩展？什么脑残设计？！）</p>
<p>DB 级别的服务，往往就要花一些心思了，一些技术（比如 MySQL）想要做到横向扩展，
需要进行提前设计。而一些设施虽然容易进行扩展，比如 ES / Kafka 等现代化设施，
但在部署的时候仍然要进行一些提前准备。</p>
<p>除了提前做好 Scalable，还有几个和部署相关的 tips 可以供参考：</p>
<ul>
<li>使用工具：自动化部署，现在有太多工具可以供选择，比如 ansible 就是一个很好的工具</li>
<li>automatic everything：避免登录服务器操作才能保证未来自动化</li>
<li>工程化：用最佳实践去维护部署系统，用工程化的态度去写部署代码</li>
<li>保持同质，避免花样：避免使用 shell 级别的操作原语操作部署系统，使用预设的 module 去操作</li>
</ul>
<h2 id="end">End</h2>
<p>好了，现在去预测一下当大流量来临之际，你的服务会在哪些环节失败。
想不出来的话，就一点点去测量各个环节性能，然后做一把容量规划吧。</p>
<p>调优和增加容量，这是两个手段，这两个手段互相作用，互相影响。使用时候需要根据成本和收益进行选择。</p>
<p>关于容量规划的更多细节，可以看看 <a href="https://book.douban.com/subject/4200645/">Web容量规划的艺术 (豆瓣)</a>
这里看看。只是这本书写在 2010 年，并且作者介绍的过于传统运维视角一些。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>一例 Timeout 故障</title>
      <link>https://blog.alswl.com/2016/02/a-timeout-fault/</link>
      <pubDate>Tue, 02 Feb 2016 23:34:44 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2016/02/a-timeout-fault/</guid>
      <description>早晨刚到公司， HAProxy 报警，Trtornis（第三方云存储网关，用来统一管理阿里云和七牛云的对象存储） 全飘红。 检查日志，并没有 ERROR 信息，但是大量 WARN 报错。 WARN [2015-12-09 11:01:02,730] org.eclipse.jetty.util.thread.QueuedThreadPool: dw{STARTED,8&amp;lt;=50&amp;lt;=50,i=0,q=1024} rejected org.eclipse.jetty.io.AbstractConne ction$2@62c021c6 WARN [2015-12-09 11:01:02,731] org.eclipse.jetty.io.SelectorManager: Could not process key for channel java.nio.channels.SocketChannel[connected local=/10. 1.1.78:8350 remote=/10.1.1.74:63290] ! java.util.concurrent.RejectedExecutionException: org.eclipse.jetty.io.AbstractConnection$2@62c021c6 ! at org.eclipse.jetty.util.thread.QueuedThreadPool.execute(QueuedThreadPool.java:362) [tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at org.eclipse.jetty.io.AbstractConnection$FillingState.onEnter(AbstractConnection.java:379) ~[tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at org.eclipse.jetty.io.AbstractConnection.next(AbstractConnection.java:273) ~[tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:563) ~[tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:82) ~[tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at org.eclipse.jetty.io.SelectChannelEndPoint.onSelected(SelectChannelEndPoint.java:109) ~[tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at org.eclipse.jetty.io.SelectorManager$ManagedSelector.processKey(SelectorManager.java:636) [tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at org.eclipse.jetty.io.SelectorManager$ManagedSelector.select(SelectorManager.java:607) [tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at org.eclipse.jetty.io.SelectorManager$ManagedSelector.run(SelectorManager.java:545) [tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at org.eclipse.jetty.util.thread.NonBlockingThread.run(NonBlockingThread.java:52) [tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:635) [tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:555) [tritonis-shaded.jar:0.0.1-SNAPSHOT] ! at java.lang.Thread.run(Thread.java:745) [na:1.8.0_51] 这是七牛 API 调用出现问题，通过应用 Metrics API 检查 Threads： http http://A-DOMAIN:8351/threads | sort | uniq -c | sort -gr G qiniu 正常的实例： 异常的实例</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201602/i_love_timeouts_digital_design_mugs.jpg" alt="i_love_timeouts_digital_design_mugs.jpg"  />


</p>
<p>早晨刚到公司， HAProxy 报警，Trtornis（第三方云存储网关，用来统一管理阿里云和七牛云的对象存储） 全飘红。</p>
<!-- more -->
<p>检查日志，并没有 ERROR 信息，但是大量 WARN 报错。</p>
<pre tabindex="0"><code>WARN  [2015-12-09 11:01:02,730] org.eclipse.jetty.util.thread.QueuedThreadPool: dw{STARTED,8&lt;=50&lt;=50,i=0,q=1024} rejected org.eclipse.jetty.io.AbstractConne
ction$2@62c021c6
WARN  [2015-12-09 11:01:02,731] org.eclipse.jetty.io.SelectorManager: Could not process key for channel java.nio.channels.SocketChannel[connected local=/10.
1.1.78:8350 remote=/10.1.1.74:63290]
! java.util.concurrent.RejectedExecutionException: org.eclipse.jetty.io.AbstractConnection$2@62c021c6
! at org.eclipse.jetty.util.thread.QueuedThreadPool.execute(QueuedThreadPool.java:362) [tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at org.eclipse.jetty.io.AbstractConnection$FillingState.onEnter(AbstractConnection.java:379) ~[tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at org.eclipse.jetty.io.AbstractConnection.next(AbstractConnection.java:273) ~[tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:563) ~[tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:82) ~[tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at org.eclipse.jetty.io.SelectChannelEndPoint.onSelected(SelectChannelEndPoint.java:109) ~[tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at org.eclipse.jetty.io.SelectorManager$ManagedSelector.processKey(SelectorManager.java:636) [tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at org.eclipse.jetty.io.SelectorManager$ManagedSelector.select(SelectorManager.java:607) [tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at org.eclipse.jetty.io.SelectorManager$ManagedSelector.run(SelectorManager.java:545) [tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at org.eclipse.jetty.util.thread.NonBlockingThread.run(NonBlockingThread.java:52) [tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:635) [tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:555) [tritonis-shaded.jar:0.0.1-SNAPSHOT]
! at java.lang.Thread.run(Thread.java:745) [na:1.8.0_51]
</code></pre><p>这是七牛 API 调用出现问题，通过应用 Metrics API 检查 Threads：</p>
<p><code>http http://A-DOMAIN:8351/threads | sort | uniq -c | sort -gr G qiniu</code></p>
<p>正常的实例：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201602/image2015-12-9_1.png" alt="image2015-12-9_1.png"  />


</p>
<p>异常的实例：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201602/image2015-12-9_2.png" alt="image2015-12-9_2.png"  />


</p>
<p>确认是七牛服务慢导致现成爆掉，但是 46 这个值来自于哪里？</p>
<p>检查了 App 的配置文件，的确配置了 <code>maxThreads</code> 为 50:</p>
<pre tabindex="0"><code>server:
  gzip:
    enabled: false
  requestLog:
    appenders: []
  maxThreads: 50
  applicationConnectors:
    - type: http
      port: 8350
      acceptorThreads: 2
      selectorThreads: 2
  adminConnectors:
    - type: http
      port: 8351
</code></pre><p>一般对应服务不稳定，有个简单策略，超时，那么七牛服务超时是多少？找了一下相关代码，下巴都没合上：</p>
<pre tabindex="0"><code># com.qiniu.http.Client
    this.httpClient.setConnectTimeout((long)Config.CONNECT_TIMEOUT, TimeUnit.SECONDS);
    this.httpClient.setReadTimeout((long)Config.RESPONSE_TIMEOUT, TimeUnit.SECONDS);

# com.qiniu.common.Config
public static int CONNECT_TIMEOUT = 10000;
public static int RESPONSE_TIMEOUT = 30000;
</code></pre><p>超时时间 8h，吓得我赶紧关掉了显示器。
赶紧将这个 Connection 改成了 2 分钟，Connect 改成了 5s。</p>
<p>咨询了七牛的工程师故障当天的状况：</p>
<blockquote>
</blockquote>
<p>sorry 忘了回复，问题已经定位，早上因为有个别用户list请求数量过大，导致了整个list接口出现大量满请求，影响返回是list接口的调用 和 portal上内容管理界面列取文件key的速度，目前已经恢复</p>
<blockquote>
<p>大量慢请求，这个已经内部有告警和恢复机制，11点25恢复的</p>
</blockquote>
<p>国内一线的云服务供应商也会出这样不可用故障，即便是有服务放在云上，还是要自己留一个心眼，多关注可用性啊。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>怎么打日志</title>
      <link>https://blog.alswl.com/2015/10/how-to-log/</link>
      <pubDate>Sun, 18 Oct 2015 14:25:28 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2015/10/how-to-log/</guid>
      <description>需要解决的问题： 业务日志打太乱，没有位置和格式约束 什么情况打日志，如何避免滥用，提高日志作用 打日志最佳实践 Dropwizard 列出的打日志原则： Be human readable. Be machine parsable. Be easy for sleepy ops folks to figure out why things are pear-shaped at 3:30AM using standard UNIXy tools like tail and grep. eg.: TRACE [2010-04-06 06:42:35,271] com.example.dw.Thing: Contemplating doing a thing. DEBUG [2010-04-06 06:42:35,274] com.example.dw.Thing: About to do a thing. INFO [2010-04-06 06:42:35,274] com.example.dw.Thing: Doing a thing WARN [2010-04-06 06:42:35,275] com.example.dw.Thing: Doing a thing ERROR [2010-04-06 06:42:35,275] com.example.dw.Thing: This may get ugly. ! java.lang.RuntimeException: oh noes! ! at com.example.dw.Thing.run(Thing.java:16) ! splunk 的最佳实践： 使用清晰的键值对：key1=val1, key2=val2 对开发者易读 全部添加时间戳 使用唯一标记，比如 user_id, transaction_id 使用文本 使用开发者</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201510/logger.jpg" alt="logger"  />


</p>
<p>需要解决的问题：</p>
<ul>
<li>业务日志打太乱，没有位置和格式约束</li>
<li>什么情况打日志，如何避免滥用，提高日志作用</li>
</ul>
<h2 id="打日志最佳实践">打日志最佳实践</h2>
<p>Dropwizard 列出的打日志原则：</p>
<blockquote>
<p>Be human readable.</p>
<p>Be machine parsable.</p>
<p>Be easy for sleepy ops folks to figure out why things are pear-shaped at 3:30AM using standard UNIXy tools like tail and grep.</p>
</blockquote>
<p>eg.:</p>
<pre tabindex="0"><code>TRACE [2010-04-06 06:42:35,271] com.example.dw.Thing: Contemplating doing a thing.
DEBUG [2010-04-06 06:42:35,274] com.example.dw.Thing: About to do a thing.
INFO  [2010-04-06 06:42:35,274] com.example.dw.Thing: Doing a thing
WARN  [2010-04-06 06:42:35,275] com.example.dw.Thing: Doing a thing
ERROR [2010-04-06 06:42:35,275] com.example.dw.Thing: This may get ugly.
! java.lang.RuntimeException: oh noes!
! at com.example.dw.Thing.run(Thing.java:16)
!
</code></pre><p>splunk 的最佳实践：</p>
<ul>
<li>使用清晰的键值对：<code>key1=val1, key2=val2</code></li>
<li>对开发者易读</li>
<li>全部添加时间戳</li>
<li>使用唯一标记，比如 user_id, transaction_id</li>
<li>使用文本</li>
<li>使用开发者易用格式，比如 JSON</li>
<li>尽可能多加一下数据</li>
<li>标记调用来源，比如方法名，类名</li>
<li>将多行事件拆分</li>
</ul>
<p>除了一些浅显易懂的原则，还是 dropwizard 的三条原则和解决方案靠谱。
但是两篇文章都没有告诉如果在复杂系统里面记录有用的日志，打日志生命周期是怎样的。</p>
<p>既然找不到，我就就自行想想如何打有意义的日志。</p>
<p>日志不怕多，而是怕繁杂难搜索，产出的数据无意义难追踪问题。所以最关键是找到一个合理通用的方式组织起来即可：</p>
<ul>
<li>按照模块名 com.duitang.service.module.aaa 打日志，比如 <code>com.duitang.service.module.aaa.log</code></li>
<li>一个模块一个日志，模块复杂之后，可以拆分，<code>com.duitang.service.module.aaa.core.log</code> / <code>com.duitang.service.module.aaa.query.log</code>，其实在这个时侯，这个模块本身由于复杂性也会面临拆分。</li>
<li>不分离 error / info 日志，放到一个文件，通过 <code>grep</code> 或者日志工具分离</li>
<li>日志文件一定要 rotate，磁盘存储固定时间 N 天，远程文件存储固定时间 M 天，TTL 删除。</li>
</ul>
<p>补充一个日志常见使用场景：</p>
<ul>
<li>外部资源调用</li>
<li>状态变化</li>
<li>系统入口和出口</li>
<li>业务异常</li>
<li>非预期执行</li>
</ul>
<hr />
<p>参考文档：</p>
<ul>
<li><a href="https://dropwizard.github.io/dropwizard/manual/core.html#logging">Dropwizard Core | Dropwizard</a></li>
<li><a href="http://dev.splunk.com/view/logging-best-practices/SP-CAAADP6">Logging best practices | Splunk</a></li>
<li><a href="http://www.infoq.com/cn/articles/why-and-how-log">程序那些事：日志记录的作用和方法</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Redis 集群扩容</title>
      <link>https://blog.alswl.com/2015/07/redis-migration/</link>
      <pubDate>Sun, 26 Jul 2015 15:33:49 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2015/07/redis-migration/</guid>
      <description>几乎每一个网站都需要用户登录状态系统，其中核心是存储 Session 的用户登录状态存储系统。 主流的实现之一是使用 Redis 存储用户登录信息，Redis 特点是功能简单、无依赖、 存储结构丰富、有持久化功能。 我大堆糖的 Session 存储系统也正是基于 Redis。 可是 Redis 也存在一些问题，比如 Redis 自身没有 Sharding 功能，Replication 也是在逐步完善完善过程中 （2.4 支持 Replication，2.8 加入 Replication partial resynchronization 功能）。 纵观当下流行的 DB 系统，哪个不</description>
      <content:encoded><![CDATA[<p>几乎每一个网站都需要用户登录状态系统，其中核心是存储 Session 的用户登录状态存储系统。
主流的实现之一是使用 Redis 存储用户登录信息，Redis 特点是功能简单、无依赖、
存储结构丰富、有持久化功能。
我大堆糖的 Session 存储系统也正是基于 Redis。</p>
<p>可是 Redis 也存在一些问题，比如 Redis 自身没有 Sharding 功能，Replication
也是在逐步完善完善过程中
（2.4 支持 <code>Replication</code>，2.8 加入 <code>Replication partial resynchronization</code> 功能）。
纵观当下流行的 DB 系统，哪个不是自带这两个特性，这两个分布式特性应该成为新出产的 DB 系统的标配。
而且作者还经常发布延期，放烟雾弹，不知道 Redis 自带 Sharding 特性要等到何年马月。</p>
<p>随着业务规模的扩大，单台 Redis 实例不能满足需求。
考虑到 Redis 也是久经考验的战士，替换掉他成本比较高，那就对 Redis 进行扩容。</p>
<p>扩容的基本要求是：</p>
<ul>
<li>扩大系统容量，成为分布式系统，未来有横向扩展</li>
<li>业务不中断</li>
<li>保证原始数据的可用性</li>
</ul>
<p>Google 了一下，有两个项目可以参考：
<a href="https://github.com/idning/redis-mgr">https://github.com/idning/redis-mgr</a>
和豌豆荚的 <a href="https://github.com/wandoulabs/codis">Codis</a>。</p>
<p>研究了这两项目的代码之后，发现前者存在几个问题：
需要停机进行操作。
后者提供了完整一套解决方案，Server/Proxy/Config Manage，对我这次迁移来说，太重了，
而且项目比较新，风险高，只能用来参考实现方法。</p>
<p>最后我决定参考 redis-mgr 的方案，然后使用两种方式同步数据：
系统运行中打上 patch 完成数据的动态迁移；后台跑迁移数据脚本。</p>
<h2 id="方案的关键词">方案的关键词</h2>
<h3 id="dump--restore--pttl"><code>dump</code> / <code>restore</code> / <code>pttl</code></h3>
<p>核心的操作流程是：
使用 <code>dump</code> 命令导出数据，<code>restore</code> 命令恢复数据，<code>pttl</code> 命令获取设置 TTL。</p>
<h3 id="presharding">Presharding</h3>
<p>Redis 官方没有 sharding 方案，但提供一种策略 presharding。
Redis 作者写了一篇<a href="http://oldblog.antirez.com/post/redis-presharding.html">Redis Presharding</a>。核心是：
提前做 2^n 个实例，避免扩容时候数据迁移，一般使用 2^n 个实例，
目的是为了能够自然地乘以 2 进行拆分。
这些实例可以分开放，也可以放在同一台机器上面。</p>
<p>我这次操作，将 <code>OLD_CLUSTER</code> 的一个实例拆分为了 <code>NEW_CLUSTER</code> 的 32 个实例，
跑在 4 台服务器上面。</p>
<h3 id="twemproxy">Twemproxy</h3>
<p>Redis 的 经典款 Proxy，用来实现对多个 Redis 实例 sharding，
Twitter 出品，<a href="https://github.com/twitter/twemproxy">链接</a>。</p>
<h3 id="一致性-hash">一致性 Hash</h3>
<p>传统的 Hash 方法是 <code>hash(key) = value % nodes.length</code>，
当加入、减少 Hash 节点时候，会导致 <code>hash(key)</code> 的全部失效。
典型的一致性 Hash 算法，<a href="https://github.com/RJ/ketama">Ketama</a> 通过环状 node 分布，解决了这个问题。</p>
<p>Twemproxy 还提供 <code>modula</code> 和 random 两种分布式方案。</p>
<h3 id="db-大小预估">db 大小预估</h3>
<p>Redis 只能查看整个实例内存尺寸。不能查看单个 db。
使用 <code>ramdomkey</code> 做抽样检查，取 1% key 抽样，估计单个 key 大小，
然后做 benchmark 估算操作性能，估算操作时间。</p>
<h3 id="动态迁移数据">动态迁移数据</h3>
<p>为了在迁移过程中保证服务可用，需要将数据兼容 Redis 集群 <code>OLD_CLUSTER</code> / <code>NEW_CLUSTER</code>，
业务代码必须同时支持访问两个集群，做法也很简单</p>
<ul>
<li>访问 <code>NEW_CLUSTER</code></li>
<li>有数据则继续操作，无数据则访问 <code>OLD_CLUSTER</code>，获取数据 <code>DATA</code></li>
<li>将数据和 TTL 保存到 <code>NEW_CLUSTER</code></li>
</ul>
<p>将这个逻辑封装成一个 client，替换掉原来 Redis Client 即可。</p>
<p>注意，这个点可能产生幻读，读取 key 和写入 key 有个时间差，
但是我处理的 session 是 immutable 数据，不会出现问题。
而如果将 Redis 用作 Persistence，就要评估对业务的影响了。</p>
<h3 id="后台迁移数据">后台迁移数据</h3>
<p>依赖用户访问来进行迁移，效率太低了，这个迁移时间和最长 TTL 时间相当，
需要主动将这个数据从 <code>OLD_CLUSTER</code> 迁移到 <code>NEW_CLUSTER</code>。</p>
<p>方案也很简单，使用 <code>randomkey</code> 获取一批数据，然后按动态迁移数据方法进行迁移。</p>
<h3 id="pipeline">pipeline</h3>
<p>如果在业务逻辑中使用了 PIPELINE，就会遇到问题，需要改写掉业务方案，
待迁移完成之后，再进行恢复。</p>
<h3 id="multikey">multikey</h3>
<p><code>mget</code> / <code>mset</code> 等多键操作方法需要注意拆解 key，然后一一 <code>dump</code> / <code>restore</code> /
<code>ttl</code>。</p>
<h2 id="正式操作">正式操作</h2>
<p>线上操作的数据：</p>
<pre tabindex="0"><code># 0.483 g db0
12:05:19,444 - __main__ - INFO - v, dumps keys 1014/1375371/..., time: 974.183676004
# 4.552 g db1
17:38:36,422 - __main__ - INFO - v, dumps keys 1392/7711834/..., time: 3076.41647506
</code></pre><p>附上 Migration Script：<a href="https://gist.github.com/alswl/e96a5308ebac4f69f809f9ba56dfe168">https://blog.alswl.com/2015/07/redis-migration/ Redis Cluster Migration</a></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
