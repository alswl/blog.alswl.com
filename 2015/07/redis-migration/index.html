<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Redis 集群扩容 | Log4D</title>
<meta name="keywords" content="redis">
<meta name="description" content="几乎每一个网站都需要用户登录状态系统，其中核心是存储 Session 的用户登录状态存储系统。 主流的实现之一是使用 Redis 存储用户登录信息，Redis 特点是功能简单、无依赖、 存储结构丰富、有持久化功能。 我大堆糖的 Session 存储系统也正是基于 Redis。 可是 Redis 也存在一些问题，比如 Redis 自身没有 Sharding 功能，Replication 也是在逐步完善完善过程中 （2.4 支持 Replication，2.8 加入 Replication partial resynchronization 功能）。 纵观当下流行的 DB 系统，哪个不">
<meta name="author" content="alswl">
<link rel="canonical" href="https://blog.alswl.com/2015/07/redis-migration/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8a8fb2252e3b86ff50510aea076c0754a4ac19e57254bb71b15cc554106148fb.css" integrity="sha256-io&#43;yJS47hv9QUQrqB2wHVKSsGeVyVLtxsVzFVBBhSPs=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://blog.alswl.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.alswl.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.alswl.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.alswl.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.alswl.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7S40P40QGJ"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-7S40P40QGJ', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Redis 集群扩容" />
<meta property="og:description" content="几乎每一个网站都需要用户登录状态系统，其中核心是存储 Session 的用户登录状态存储系统。 主流的实现之一是使用 Redis 存储用户登录信息，Redis 特点是功能简单、无依赖、 存储结构丰富、有持久化功能。 我大堆糖的 Session 存储系统也正是基于 Redis。 可是 Redis 也存在一些问题，比如 Redis 自身没有 Sharding 功能，Replication 也是在逐步完善完善过程中 （2.4 支持 Replication，2.8 加入 Replication partial resynchronization 功能）。 纵观当下流行的 DB 系统，哪个不" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.alswl.com/2015/07/redis-migration/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-07-26T15:33:49+08:00" />
<meta property="article:modified_time" content="2015-07-26T15:33:49+08:00" /><meta property="og:site_name" content="Log4D" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis 集群扩容"/>
<meta name="twitter:description" content="几乎每一个网站都需要用户登录状态系统，其中核心是存储 Session 的用户登录状态存储系统。 主流的实现之一是使用 Redis 存储用户登录信息，Redis 特点是功能简单、无依赖、 存储结构丰富、有持久化功能。 我大堆糖的 Session 存储系统也正是基于 Redis。 可是 Redis 也存在一些问题，比如 Redis 自身没有 Sharding 功能，Replication 也是在逐步完善完善过程中 （2.4 支持 Replication，2.8 加入 Replication partial resynchronization 功能）。 纵观当下流行的 DB 系统，哪个不"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://blog.alswl.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Redis 集群扩容",
      "item": "https://blog.alswl.com/2015/07/redis-migration/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis 集群扩容",
  "name": "Redis 集群扩容",
  "description": "几乎每一个网站都需要用户登录状态系统，其中核心是存储 Session 的用户登录状态存储系统。 主流的实现之一是使用 Redis 存储用户登录信息，Redis 特点是功能简单、无依赖、 存储结构丰富、有持久化功能。 我大堆糖的 Session 存储系统也正是基于 Redis。 可是 Redis 也存在一些问题，比如 Redis 自身没有 Sharding 功能，Replication 也是在逐步完善完善过程中 （2.4 支持 Replication，2.8 加入 Replication partial resynchronization 功能）。 纵观当下流行的 DB 系统，哪个不",
  "keywords": [
    "redis"
  ],
  "articleBody": "几乎每一个网站都需要用户登录状态系统，其中核心是存储 Session 的用户登录状态存储系统。 主流的实现之一是使用 Redis 存储用户登录信息，Redis 特点是功能简单、无依赖、 存储结构丰富、有持久化功能。 我大堆糖的 Session 存储系统也正是基于 Redis。\n可是 Redis 也存在一些问题，比如 Redis 自身没有 Sharding 功能，Replication 也是在逐步完善完善过程中 （2.4 支持 Replication，2.8 加入 Replication partial resynchronization 功能）。 纵观当下流行的 DB 系统，哪个不是自带这两个特性，这两个分布式特性应该成为新出产的 DB 系统的标配。 而且作者还经常发布延期，放烟雾弹，不知道 Redis 自带 Sharding 特性要等到何年马月。\n随着业务规模的扩大，单台 Redis 实例不能满足需求。 考虑到 Redis 也是久经考验的战士，替换掉他成本比较高，那就对 Redis 进行扩容。\n扩容的基本要求是：\n扩大系统容量，成为分布式系统，未来有横向扩展 业务不中断 保证原始数据的可用性 Google 了一下，有两个项目可以参考： https://github.com/idning/redis-mgr 和豌豆荚的 Codis。\n研究了这两项目的代码之后，发现前者存在几个问题： 需要停机进行操作。 后者提供了完整一套解决方案，Server/Proxy/Config Manage，对我这次迁移来说，太重了， 而且项目比较新，风险高，只能用来参考实现方法。\n最后我决定参考 redis-mgr 的方案，然后使用两种方式同步数据： 系统运行中打上 patch 完成数据的动态迁移；后台跑迁移数据脚本。\n方案的关键词 dump / restore / pttl 核心的操作流程是： 使用 dump 命令导出数据，restore 命令恢复数据，pttl 命令获取设置 TTL。\nPresharding Redis 官方没有 sharding 方案，但提供一种策略 presharding。 Redis 作者写了一篇Redis Presharding。核心是： 提前做 2^n 个实例，避免扩容时候数据迁移，一般使用 2^n 个实例， 目的是为了能够自然地乘以 2 进行拆分。 这些实例可以分开放，也可以放在同一台机器上面。\n我这次操作，将 OLD_CLUSTER 的一个实例拆分为了 NEW_CLUSTER 的 32 个实例， 跑在 4 台服务器上面。\nTwemproxy Redis 的 经典款 Proxy，用来实现对多个 Redis 实例 sharding， Twitter 出品，链接。\n一致性 Hash 传统的 Hash 方法是 hash(key) = value % nodes.length， 当加入、减少 Hash 节点时候，会导致 hash(key) 的全部失效。 典型的一致性 Hash 算法，Ketama 通过环状 node 分布，解决了这个问题。\nTwemproxy 还提供 modula 和 random 两种分布式方案。\ndb 大小预估 Redis 只能查看整个实例内存尺寸。不能查看单个 db。 使用 ramdomkey 做抽样检查，取 1% key 抽样，估计单个 key 大小， 然后做 benchmark 估算操作性能，估算操作时间。\n动态迁移数据 为了在迁移过程中保证服务可用，需要将数据兼容 Redis 集群 OLD_CLUSTER / NEW_CLUSTER， 业务代码必须同时支持访问两个集群，做法也很简单\n访问 NEW_CLUSTER 有数据则继续操作，无数据则访问 OLD_CLUSTER，获取数据 DATA 将数据和 TTL 保存到 NEW_CLUSTER 将这个逻辑封装成一个 client，替换掉原来 Redis Client 即可。\n注意，这个点可能产生幻读，读取 key 和写入 key 有个时间差， 但是我处理的 session 是 immutable 数据，不会出现问题。 而如果将 Redis 用作 Persistence，就要评估对业务的影响了。\n后台迁移数据 依赖用户访问来进行迁移，效率太低了，这个迁移时间和最长 TTL 时间相当， 需要主动将这个数据从 OLD_CLUSTER 迁移到 NEW_CLUSTER。\n方案也很简单，使用 randomkey 获取一批数据，然后按动态迁移数据方法进行迁移。\npipeline 如果在业务逻辑中使用了 PIPELINE，就会遇到问题，需要改写掉业务方案， 待迁移完成之后，再进行恢复。\nmultikey mget / mset 等多键操作方法需要注意拆解 key，然后一一 dump / restore / ttl。\n正式操作 线上操作的数据：\n# 0.483 g db0 12:05:19,444 - __main__ - INFO - v, dumps keys 1014/1375371/..., time: 974.183676004 # 4.552 g db1 17:38:36,422 - __main__ - INFO - v, dumps keys 1392/7711834/..., time: 3076.41647506 附上 Migration Script：https://blog.alswl.com/2015/07/redis-migration/ Redis Cluster Migration\n",
  "wordCount" : "1480",
  "inLanguage": "en",
  "datePublished": "2015-07-26T15:33:49+08:00",
  "dateModified": "2015-07-26T15:33:49+08:00",
  "author":{
    "@type": "Person",
    "name": "alswl"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.alswl.com/2015/07/redis-migration/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Log4D",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.alswl.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.alswl.com" accesskey="h" title="Log4D (Alt + H)">Log4D</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://en.blog.alswl.com/" title="English Blog">
                    <span>English Blog</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/archives/" title="存档">
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/about/" title="关于我">
                    <span>关于我</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.alswl.com">Home</a>&nbsp;»&nbsp;<a href="https://blog.alswl.com/posts/">Posts</a></div>
    <h1 class="post-title">
      Redis 集群扩容
    </h1>
    <div class="post-meta"><span title='2015-07-26 15:33:49 +0800 +0800'>2015-07-26</span>&nbsp;·&nbsp;alswl

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#方案的关键词">方案的关键词</a>
      <ul>
        <li><a href="#dump--restore--pttl"><code>dump</code> / <code>restore</code> / <code>pttl</code></a></li>
        <li><a href="#presharding">Presharding</a></li>
        <li><a href="#twemproxy">Twemproxy</a></li>
        <li><a href="#一致性-hash">一致性 Hash</a></li>
        <li><a href="#db-大小预估">db 大小预估</a></li>
        <li><a href="#动态迁移数据">动态迁移数据</a></li>
        <li><a href="#后台迁移数据">后台迁移数据</a></li>
        <li><a href="#pipeline">pipeline</a></li>
        <li><a href="#multikey">multikey</a></li>
      </ul>
    </li>
    <li><a href="#正式操作">正式操作</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>几乎每一个网站都需要用户登录状态系统，其中核心是存储 Session 的用户登录状态存储系统。
主流的实现之一是使用 Redis 存储用户登录信息，Redis 特点是功能简单、无依赖、
存储结构丰富、有持久化功能。
我大堆糖的 Session 存储系统也正是基于 Redis。</p>
<p>可是 Redis 也存在一些问题，比如 Redis 自身没有 Sharding 功能，Replication
也是在逐步完善完善过程中
（2.4 支持 <code>Replication</code>，2.8 加入 <code>Replication partial resynchronization</code> 功能）。
纵观当下流行的 DB 系统，哪个不是自带这两个特性，这两个分布式特性应该成为新出产的 DB 系统的标配。
而且作者还经常发布延期，放烟雾弹，不知道 Redis 自带 Sharding 特性要等到何年马月。</p>
<p>随着业务规模的扩大，单台 Redis 实例不能满足需求。
考虑到 Redis 也是久经考验的战士，替换掉他成本比较高，那就对 Redis 进行扩容。</p>
<p>扩容的基本要求是：</p>
<ul>
<li>扩大系统容量，成为分布式系统，未来有横向扩展</li>
<li>业务不中断</li>
<li>保证原始数据的可用性</li>
</ul>
<p>Google 了一下，有两个项目可以参考：
<a href="https://github.com/idning/redis-mgr">https://github.com/idning/redis-mgr</a>
和豌豆荚的 <a href="https://github.com/wandoulabs/codis">Codis</a>。</p>
<p>研究了这两项目的代码之后，发现前者存在几个问题：
需要停机进行操作。
后者提供了完整一套解决方案，Server/Proxy/Config Manage，对我这次迁移来说，太重了，
而且项目比较新，风险高，只能用来参考实现方法。</p>
<p>最后我决定参考 redis-mgr 的方案，然后使用两种方式同步数据：
系统运行中打上 patch 完成数据的动态迁移；后台跑迁移数据脚本。</p>
<h2 id="方案的关键词">方案的关键词<a hidden class="anchor" aria-hidden="true" href="#方案的关键词">#</a></h2>
<h3 id="dump--restore--pttl"><code>dump</code> / <code>restore</code> / <code>pttl</code><a hidden class="anchor" aria-hidden="true" href="#dump--restore--pttl">#</a></h3>
<p>核心的操作流程是：
使用 <code>dump</code> 命令导出数据，<code>restore</code> 命令恢复数据，<code>pttl</code> 命令获取设置 TTL。</p>
<h3 id="presharding">Presharding<a hidden class="anchor" aria-hidden="true" href="#presharding">#</a></h3>
<p>Redis 官方没有 sharding 方案，但提供一种策略 presharding。
Redis 作者写了一篇<a href="http://oldblog.antirez.com/post/redis-presharding.html">Redis Presharding</a>。核心是：
提前做 2^n 个实例，避免扩容时候数据迁移，一般使用 2^n 个实例，
目的是为了能够自然地乘以 2 进行拆分。
这些实例可以分开放，也可以放在同一台机器上面。</p>
<p>我这次操作，将 <code>OLD_CLUSTER</code> 的一个实例拆分为了 <code>NEW_CLUSTER</code> 的 32 个实例，
跑在 4 台服务器上面。</p>
<h3 id="twemproxy">Twemproxy<a hidden class="anchor" aria-hidden="true" href="#twemproxy">#</a></h3>
<p>Redis 的 经典款 Proxy，用来实现对多个 Redis 实例 sharding，
Twitter 出品，<a href="https://github.com/twitter/twemproxy">链接</a>。</p>
<h3 id="一致性-hash">一致性 Hash<a hidden class="anchor" aria-hidden="true" href="#一致性-hash">#</a></h3>
<p>传统的 Hash 方法是 <code>hash(key) = value % nodes.length</code>，
当加入、减少 Hash 节点时候，会导致 <code>hash(key)</code> 的全部失效。
典型的一致性 Hash 算法，<a href="https://github.com/RJ/ketama">Ketama</a> 通过环状 node 分布，解决了这个问题。</p>
<p>Twemproxy 还提供 <code>modula</code> 和 random 两种分布式方案。</p>
<h3 id="db-大小预估">db 大小预估<a hidden class="anchor" aria-hidden="true" href="#db-大小预估">#</a></h3>
<p>Redis 只能查看整个实例内存尺寸。不能查看单个 db。
使用 <code>ramdomkey</code> 做抽样检查，取 1% key 抽样，估计单个 key 大小，
然后做 benchmark 估算操作性能，估算操作时间。</p>
<h3 id="动态迁移数据">动态迁移数据<a hidden class="anchor" aria-hidden="true" href="#动态迁移数据">#</a></h3>
<p>为了在迁移过程中保证服务可用，需要将数据兼容 Redis 集群 <code>OLD_CLUSTER</code> / <code>NEW_CLUSTER</code>，
业务代码必须同时支持访问两个集群，做法也很简单</p>
<ul>
<li>访问 <code>NEW_CLUSTER</code></li>
<li>有数据则继续操作，无数据则访问 <code>OLD_CLUSTER</code>，获取数据 <code>DATA</code></li>
<li>将数据和 TTL 保存到 <code>NEW_CLUSTER</code></li>
</ul>
<p>将这个逻辑封装成一个 client，替换掉原来 Redis Client 即可。</p>
<p>注意，这个点可能产生幻读，读取 key 和写入 key 有个时间差，
但是我处理的 session 是 immutable 数据，不会出现问题。
而如果将 Redis 用作 Persistence，就要评估对业务的影响了。</p>
<h3 id="后台迁移数据">后台迁移数据<a hidden class="anchor" aria-hidden="true" href="#后台迁移数据">#</a></h3>
<p>依赖用户访问来进行迁移，效率太低了，这个迁移时间和最长 TTL 时间相当，
需要主动将这个数据从 <code>OLD_CLUSTER</code> 迁移到 <code>NEW_CLUSTER</code>。</p>
<p>方案也很简单，使用 <code>randomkey</code> 获取一批数据，然后按动态迁移数据方法进行迁移。</p>
<h3 id="pipeline">pipeline<a hidden class="anchor" aria-hidden="true" href="#pipeline">#</a></h3>
<p>如果在业务逻辑中使用了 PIPELINE，就会遇到问题，需要改写掉业务方案，
待迁移完成之后，再进行恢复。</p>
<h3 id="multikey">multikey<a hidden class="anchor" aria-hidden="true" href="#multikey">#</a></h3>
<p><code>mget</code> / <code>mset</code> 等多键操作方法需要注意拆解 key，然后一一 <code>dump</code> / <code>restore</code> /
<code>ttl</code>。</p>
<h2 id="正式操作">正式操作<a hidden class="anchor" aria-hidden="true" href="#正式操作">#</a></h2>
<p>线上操作的数据：</p>
<pre tabindex="0"><code># 0.483 g db0
12:05:19,444 - __main__ - INFO - v, dumps keys 1014/1375371/..., time: 974.183676004
# 4.552 g db1
17:38:36,422 - __main__ - INFO - v, dumps keys 1392/7711834/..., time: 3076.41647506
</code></pre><p>附上 Migration Script：<a href="https://gist.github.com/alswl/e96a5308ebac4f69f809f9ba56dfe168">https://blog.alswl.com/2015/07/redis-migration/ Redis Cluster Migration</a></p>

<hr />
<p>原文链接: <a href="https://blog.alswl.com/2015/07/redis-migration/">Redis 集群扩容 | Log4D</a></p>
<p>3a1ff193cee606bd1e2ea554a16353ee</p>
<p>欢迎关注我的微信公众号：<a
href="http://mp.weixin.qq.com/mp/getmasssendmsg?__biz=MzIyNTIwMTU3MQ==#wechat_webview_type=1&amp;wechat_redirect">窥豹</a></p>
<figure>
<img
src="https://d05fae.dijingchao.com/upload_dropbox/201605/qrcode_for_gh_17e2f9c2caa4_258.jpg"
alt="窥豹" />
<figcaption aria-hidden="true">窥豹</figcaption>
</figure>

    
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.alswl.com/tags/redis/">redis</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.alswl.com/2015/10/how-to-log/">
    <span class="title">« Prev</span>
    <br>
    <span>怎么打日志</span>
  </a>
  <a class="next" href="https://blog.alswl.com/2015/07/liu-bi-xie-fu/">
    <span class="title">Next »</span>
    <br>
    <span>带理想的执行者 - 柳比歇夫的一生</span>
  </a>
</nav>

  </footer><div id="waline"></div>
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';

    
    
    init({
      el: '#waline',
      serverURL: 'https://comments-waline.blog.alswl.com',
      emoji: false,
      search: false,
      reaction: true, 
      requiredMeta: ['nick', 'mail'],
      login: 'disable',
      imageUploader: false,
      texRenderer: false,
    });
</script>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://blog.alswl.com">Log4D</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
