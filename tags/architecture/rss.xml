<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Architecture on Log4D</title>
    <link>https://blog.alswl.com/tags/architecture/</link>
    <description>Recent content in Architecture on Log4D</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 23 Sep 2023 18:22:27 +0800</lastBuildDate>
    <atom:link href="https://blog.alswl.com/tags/architecture/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GitOps 和版本管理</title>
      <link>https://blog.alswl.com/2023/09/gitops-and-version-management/</link>
      <pubDate>Sat, 23 Sep 2023 18:22:27 +0800</pubDate>
      <guid>https://blog.alswl.com/2023/09/gitops-and-version-management/</guid>
      <description>&lt;p&gt;




&lt;img loading=&#34;lazy&#34; src=&#34;https://blog.alswl.com/images/202309/car.png&#34; alt=&#34;car&#34;  /&gt;


&lt;/p&gt;
&lt;p&gt;&lt;small&gt;image via &lt;a href=&#34;https://www.shipvehicles.com/step-by-step-guide-for-state-to-state-transport/&#34;&gt;shipvehicles&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;使用 GitOps 管理交付内容是一个常见的 DevOps 使用模式。
我们会使用 Git 进行版本管理，
并通过 Git Tag 来跟踪部署软件的版本。
虽然这看上去可以工作，但在云原生技术的推动下，版本的概念远非如此简单。&lt;/p&gt;
&lt;h2 id=&#34;版本问题&#34;&gt;版本问题&lt;/h2&gt;
&lt;p&gt;在引入 GitOps 到 DevOps 流程后，我们可以借助 GitOps 的能力进行持续集成和持续交付。
GitOps 解决了三个核心问题：&lt;strong&gt;内容&lt;/strong&gt;、&lt;strong&gt;版本&lt;/strong&gt; 和 &lt;strong&gt;协作&lt;/strong&gt;。然而，我们经常将注意力集中在内容上，却经常忽略了版本管理问题。&lt;/p&gt;
&lt;p&gt;在 GitOps 过程中，有哪些版本管理问题需要解决呢？&lt;/p&gt;
&lt;p&gt;一套完整的 GitOps 解决方案包括内容描述（Manifest）、构建方案（Builder）和生效方案（Applier）。其中，内容描述衍生出多种描述语言，从最传统的 &lt;a href=&#34;https://www.ansible.com/&#34;&gt;Ansible&lt;/a&gt; / &lt;a href=&#34;https://www.chef.io/products/chef-infra&#34;&gt;Chef&lt;/a&gt;，到云计算和云原生流行起来的 &lt;a href=&#34;https://www.terraform.io/&#34;&gt;Terraform&lt;/a&gt;、&lt;a href=&#34;https://helm.sh/&#34;&gt;Helm&lt;/a&gt;、&lt;a href=&#34;https://kustomize.io/&#34;&gt;Kustomize&lt;/a&gt; 等。引入了这么多内容描述方式之后，当我们想要明确一个应用的版本时，变得非常复杂。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202309/car.png" alt="car"  />


</p>
<p><small>image via <a href="https://www.shipvehicles.com/step-by-step-guide-for-state-to-state-transport/">shipvehicles</a></small></p>
<p>使用 GitOps 管理交付内容是一个常见的 DevOps 使用模式。
我们会使用 Git 进行版本管理，
并通过 Git Tag 来跟踪部署软件的版本。
虽然这看上去可以工作，但在云原生技术的推动下，版本的概念远非如此简单。</p>
<h2 id="版本问题">版本问题</h2>
<p>在引入 GitOps 到 DevOps 流程后，我们可以借助 GitOps 的能力进行持续集成和持续交付。
GitOps 解决了三个核心问题：<strong>内容</strong>、<strong>版本</strong> 和 <strong>协作</strong>。然而，我们经常将注意力集中在内容上，却经常忽略了版本管理问题。</p>
<p>在 GitOps 过程中，有哪些版本管理问题需要解决呢？</p>
<p>一套完整的 GitOps 解决方案包括内容描述（Manifest）、构建方案（Builder）和生效方案（Applier）。其中，内容描述衍生出多种描述语言，从最传统的 <a href="https://www.ansible.com/">Ansible</a> / <a href="https://www.chef.io/products/chef-infra">Chef</a>，到云计算和云原生流行起来的 <a href="https://www.terraform.io/">Terraform</a>、<a href="https://helm.sh/">Helm</a>、<a href="https://kustomize.io/">Kustomize</a> 等。引入了这么多内容描述方式之后，当我们想要明确一个应用的版本时，变得非常复杂。</p>
<p>当提到版本时，我们是<mark>指应用源代码的版本？还是指镜像的版本？或者是指某个基础设施即代码（IaC）仓库的版本</mark>？进一步地，如果我们要发布一组相互关联的应用，例如前端和后端，或者由多个后端应用组成的系统，如何清晰地描述它们之间的<mark>版本依赖关系</mark>？</p>
<p>一旦版本描述不准确，就会引入一系列问题，例如错误的上线版本、混乱的应用依赖关系、无法回滚等。</p>
<p>大多数团队对于这个问题的解决方案比较模糊：发布最新的版本，先发布后端再发布前端。然而，在一个复杂的业务团队或需要同时保留多个稳定版本的团队中，这种粗暴的方案是无法接受的。</p>
<p>版本管理不仅解决了<mark>版本定位</mark>的问题，还可以用于管理应用之间的<mark>依赖关系</mark>。因此，GitOps 版本管理需要解决以下问题：</p>
<ul>
<li>如何构建交付给客户的制品，如何定义这些制品的版本以及如何展示所有版本的制品。</li>
<li>如果有一组软件存在版本依赖关系，如何解决这些依赖问题。</li>
<li>如果一组软件形成了一个系统，如何描述这个系统。</li>
</ul>
<p>在所有的交付产品中，版本管理都是一个重要问题。我们将逐步拆分版本管理这个命题，并从原始问题过渡到 GitOps 的版本管理最佳实践。</p>
<h2 id="gitops-简介">GitOps 简介</h2>
<p>在开始正文之前，我将简要介绍 GitOps，以避免对关键概念的理解出现分歧。</p>
<p>GitOps 最核心的技术是<mark>基础设施即代码（IaC）</mark>，即使用声明式描述来取代命令式描述。
通常，IaC 的内容基于某种范式，用于描述特定目标的期望状态。这个范式可以是 Terraform、Kubernetes YAML、<a href="https://www.pulumi.com/">Pulumi</a>，甚至是 Ansible。而特定目标可以是云服务、Kubernetes，甚至是物理机。
直观的说，通过使用 YAML 取代过去的 Bash 命令，我们可以大大提高变更的准确性和可控性。</p>
<p>对于 GitOps 来说，是否使用 Git 并不是最重要的，我们也可以使用 SVN 来实现 GitOps。只是 Git 具有更广泛的适用范围，并可以充分发挥 Git 仓库在团队协作和持续集成/持续部署中的能力。</p>
<p>引入 Git 仓库后，我们还同时拥有了基于 Git Revision / Tag / Branch 的版本管理能力，这体现在业务上就是版本记录、多版本并行管理等方面。</p>
<p>简单地基于 Git Revision 进行描述还不足以满足我们的实际需求。</p>
<h2 id="问题的源头---二进制文件和启动配置文件版本">问题的源头 - 二进制文件和启动配置文件版本</h2>
<p>在探索版本的源头时，我们会发现最原始的版本是代码的版本。</p>
<p>代码的版本是什么？是代码仓库的版本还是代码编译出来应用的版本。
这个版本并不是代码所在的版本管理系统（如 Git / Mercurial / SVN 等）的版本。尽管这两者经常相关，但事实上，一份代码本身只是一组代码文件，只要构建成功，就会有一个版本。如果没有定义，版本就是未知的，此时与仓库管理没有关联。</p>
<blockquote>
<p>注意：下文我们不再区分 Git / Mercurial / SVN 多种版本管理方案，统一使用 Git 进行描述</p></blockquote>
<p>还需要注意的是，中文中有两个概念（库 Libray 和仓库 Repository）。
无论是哪种定义，都没有表示一个库一定是一个版本化（Git / SVN）仓库，
这意味着我们并没有假设代码库一定是被版本化管理的。当我们将代码文件打包成一个 zip 文件时（GitHub 的 zip 下载就是这种形式），即使这个 zip 文件失去了所有的 Git 历史，它仍然是一个代码库。</p>
<p>代码的版本实质上是<mark>应用的版本</mark>，这是作者的意图表达。这个版本往往是 <code>vx.y.z</code> 这种形式，而不是 Git commit hash，
最常见的管理方案是基于<a href="https://semver.org/">语义化版本</a>。</p>
<p>我推荐的版本存储方式是使用一个 <code>VERSION</code> 文件将版本存储在代码目录中。例如，Git 的 <a href="https://github.com/git/git/blob/master/GIT-VERSION-GEN">Version</a> 文件可以清楚地看到当前 Git 的版本是：</p>
<pre tabindex="0"><code>GVF=GIT-VERSION-FILE
DEF_VER=v2.42.GIT
</code></pre><p>其中的 <code>.GIT</code> 也明确说明了这个代码是一个开发模式下的版本。如果我们切换到一个发布版本的代码，例如 <a href="https://github.com/git/git/blob/v2.39.3/GIT-VERSION-GEN">v2.39.3</a> 版本，我们可以看到 <code>DEF_VER=v2.39.3</code>，这是一个遵循标准的制品（Artifacts）格式。这里还有两个最佳实践：</p>
<ul>
<li>使用文件来保存源代码的版本。</li>
<li>源代码中的版本文件始终处于 <code>dev</code> 模式，只有在进行标记封版之后才会成为正式版本号。</li>
</ul>
<p>源代码的最终产物不仅包括二进制文件、可执行文件和动态库（<code>.dll</code> / <code>.so</code> / <code>.dylib</code>），还包括相应的启动配置文件。这些启动配置文件通常与对应的版本一起进行管理。例如，Nginx 的启动文件 <code>nginx.conf</code> 和 Redis 的启动文件 <code>redis.conf</code>，这些启动配置文件也应该纳入版本管理。</p>
<p>从源代码仓库构建出来的内容就是制品（Artifacts）。制品已经具有两个版本：</p>
<ul>
<li>源代码版本，即使用 <code>VERSION</code> 文件中定义的版本。</li>
<li>源代码仓库版本，即 Git Revision</li>
</ul>
<h2 id="制品版本管理">制品版本管理</h2>
<p>引入制品版本管理后，问题变得更加复杂，因为制品带来了更多的问题：</p>
<ul>
<li>制品是什么，由什么构成？（上文已经回答）</li>
<li>制品如何进行安装，安装程序（Installer）是什么，运行时（Runtime）是什么？</li>
<li>制品信息如何进行集中管理，数据如何管理？</li>
<li>制品之间是否存在依赖关系，如何处理依赖关系，版本如何约束？</li>
</ul>
<p>制品的概念非常重要，其中最核心的一个理念是：<mark>制品可以通过打包器形成新的制品</mark>。</p>
<p>由于制品具有版本，而新的制品将形成新的版本，我们将进入多层嵌套。为了避免最原始的版本信息丢失，我们将 Version 的概念扩展为 <mark>Upstream Version</mark>，这是软件作者人为指定的版本，是所有版本的源头。</p>
<p>为什么制品可以形成新的制品呢？我举一个 Kubernetes 容器环境下的例子。
容器是一种交付形式，它将可执行文件和启动配置文件写入镜像文件中，并可以在容器环境中运行。形成的镜像文件存在于镜像仓库中，本身也是一种制品。</p>
<p>另外，Helm / Kustomize 也是一种交付形式（打包工具链）。
每个构建层解决其特定问题，并且可以在特定环境（例如容器、Kubernetes、云基础设施）中运行。</p>
<p>每个制品都需要构建，过程中会有自己的<mark>额外描述信息（Packaging Info）</mark>，这些额外的描述信息本身也会发生变化，因此会增加一个版本。在实践中，我们希望制品的版本与其上游版本绑定。每种打包机制可能会包含自己的一些定义配置，但仍然遵循上游的版本。例如，Kubernetes 的 Workload 包含一个镜像，Workload 的描述是附加信息，而镜像仍然受到上游控制。</p>
<p><mark>Artifact + Packaging Info = New Artifact</mark>，制品经过打包可以形成新的制品。直到最后的 Installer 放置到相应的环境中生效。</p>
<p>如果这些制品可以通过文件（IaC）进行描述，就形成了各种 IaC 仓库，这些仓库成为了 GitOps 的核心对象。</p>
<h2 id="概念梳理">概念梳理</h2>
<p>让我们来理清一下这些略有晦涩的概念：</p>
<table>
  <thead>
      <tr>
          <th>中文</th>
          <th>英文</th>
          <th>解释</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>源代码</td>
          <td>Source Code</td>
          <td>程序、应用的源文件集合</td>
      </tr>
      <tr>
          <td>代码仓库</td>
          <td>Source Code Repo</td>
          <td>源代码放到版本管理系统中的管理单元</td>
      </tr>
      <tr>
          <td>版本</td>
          <td>Version</td>
          <td>源代码对应的应用版本，人为定义，语义化，有些场景会说 Upstream Version</td>
      </tr>
      <tr>
          <td>可执行文件</td>
          <td>Executable File</td>
          <td>源代码构建出来的结果，一般是 ELF 可执行文件，也可以是 Lib 文件</td>
      </tr>
      <tr>
          <td>启动配置文件</td>
          <td>Configuration File</td>
          <td>配套 ELF / Lib 的启动配置文件，区别于广泛意义上的配置文件（比如 Kubernetes YAML）</td>
      </tr>
      <tr>
          <td>制品</td>
          <td>Artifact</td>
          <td>包含可执行文件和启动配置文件的集合，可以运行在运行时下面，一般是文件形态。制品可以嵌套制品。</td>
      </tr>
      <tr>
          <td>安装器</td>
          <td>Installer</td>
          <td>将制品安装到运行时的工具</td>
      </tr>
      <tr>
          <td>运行时</td>
          <td>Runtime</td>
          <td>制品的运行环境，比如特定操作系统，Kubernetes，Docker Engine。</td>
      </tr>
      <tr>
          <td>打包器</td>
          <td>Packer</td>
          <td>将制品打包成特定格式（新的制品）的工具</td>
      </tr>
      <tr>
          <td>打包附属信息</td>
          <td>Packaging Info</td>
          <td>制品打包时候需要的额外信息，比如容器的操作系统，进程的运行容量，默认环境变量等</td>
      </tr>
  </tbody>
</table>
<p>这些概念共同构成了制品版本管理的核心要素，帮助我们管理和跟踪制品的不同版本，以及它们之间的关联和依赖关系。</p>
<h3 id="打包器-packer">打包器 Packer</h3>
<p>打包器是一种工具，通过打包操作（Packaging）将制品组织成特定的格式，形成全新的制品。
打包的过程涉及编译、链接、合并和存档等常见概念。</p>
<p>它通常以上游（Upstream）作为输入，上游可以是源码，也可以是其他系统生成的制品（Artifacts）。</p>
<p>例如，在打包 Docker Compose 时，输入是镜像（Image），而对于 Helm，输入则包括镜像、启动配置文件和 Helm 模板，而输出则是 YAML 文件。</p>
<h3 id="制品-artifacts">制品 Artifacts</h3>
<p>制品是一种数据集合，可以在特定环境中运行。
它由可执行文件和启动配置文件等组成，通常以文件形式存在，并且可以在运行时环境下运行。制品具有嵌套的能力，可以包含其他制品。</p>
<p>最常见的形态是二进制文件（ELF），也可以是适用于特定环境的运行物，如容器镜像。</p>
<p>制品通常以文件形式进行传输。</p>
<h3 id="安装器-installer">安装器 Installer</h3>
<p>安装器是一种工具，用于将制品安装到运行时环境中。
它负责将制品部署到目标环境并确保其正常运行。
例如，dpkg、Pacman 是常见的安装器工具，而在 Windows 平台上，我们常见自引导的安装器。</p>
<p>对于特定的环境如 Kubernetes，我们可以使用 kubectl 命令进行安装，而 Helm 则使用<code>helm</code>命令来进行安装。</p>
<h2 id="linux-社区实践">Linux 社区实践</h2>
<p>当我们理解了这些概念后，我们或许会惊讶地发现，这些概念与 Linux 社区多年来的实践是如此相似。抛开云原生等新概念，Linux 社区早就拥有了完整的解决方案。</p>
<p>每一层制品都会引入新的配置（Config）/ 扩展（Extension）/ 值（Values）/ 环境变量（Env）等等，无论如何称呼，
我们统一称之为配置。
这些新加入的 Packaging Info 的描述在大规模集群管理下也带来了新的问题。</p>
<blockquote>
<p>自豪地使用 ArchLinux。</p></blockquote>
<h3 id="arch-linux-社区的实践">Arch Linux 社区的实践</h3>
<p>Arch Linux 使用 <a href="https://wiki.archlinux.org/title/Pacman">Pacman</a> 作为包安装器，并且拥有一套完整的<a href="https://wiki.archlinux.org/title/Arch_build_system">构建方案</a>。</p>
<p>在 Arch Linux 中，<code>PKGBUILD</code> <a href="https://wiki.archlinux.org/title/PKGBUILD">link</a>用于描述包的构建方式，它本身是 Bash 的子集，是描述包的核心文件。</p>
<p>版本管理方面，Arch Linux 提供了清晰明确的方案，并且设计了完整的<mark>制品嵌套</mark>解决方案。
在 <code>PKGBUILD</code> 中，<code>pkgver</code> 表示上游版本，并经过适当的修正，使用 <code>_</code> 替代 <code>-</code>，并调整了时间戳的格式。而 <code>pkgrel</code> 则表示发布号，而不是构建号，每次发布都会增加该号码，用于管理 Arch Linux 的发布动作。当大部分 <code>PKGBUILD</code> 发生变化时，发布号都会发生变化。</p>
<p>此外，<code>epoch</code> 是一个强制构建版本的机制，默认为 0 并且隐藏起来。使用 <code>epoch</code> 是一种兜底的解决方案，通过破坏版本对比来强制进行新版本的升级。</p>
<p>另外，在 <code>PKGBUILD</code> 中，使用了版本依赖的方式来优雅地解决模块的问题。
例如，<code>base-devel</code> 包是对 26 个基础软件的依赖，而<a href="https://gitlab.archlinux.org/archlinux/packaging/packages/base-devel/-/blob/main/PKGBUILD">该包本身</a>并<mark>没有具体的内容</mark>。这种方案非常优雅，避免了引入一个新的模型（比如叫做 Group / 产品）。</p>
<h2 id="基于-gitops-的版本管理解决方案">基于 GitOps 的版本管理解决方案</h2>
<p>最后让我们回归到 GitOps 版本管理本身，让我们重新面对文中的几个问题，通过以上的分析和调研，是否已经解决了这些问题呢？</p>
<ul>
<li>交付给客户的制品如何构成，如何定义这个制品的版本，以及如何呈现所有版本的制品？
<ul>
<li>使用 <code>VERSION</code> 文件来确定软件版本，也就是上游版本（Upstream Version）</li>
<li>不同形式的制品有独立的版本号，这些版本号需要与上游版本关联。例如，可以使用 <code>v1.2.3-afe12c</code> 的形式来追踪 Git 仓库中的版本，使用 <code>v1.2.3-afe12c-b1</code> 来追踪镜像构建物的版本。</li>
</ul>
</li>
<li>如果存在一组软件，如何解决这组软件之间的版本依赖问题？
<ul>
<li>这个问题可以交给具体的安装器处理，一般这些元信息会在对应的打包信息（Packaging Info）中定义，并由 Installer 识别和处理。</li>
</ul>
</li>
<li>如果一组软件形成了一套体系，如何表达这个体系？
<ul>
<li>创建一个没有上游版本的新制品，其中交付的内容可能为空，但包含相应的打包信息和依赖信息。</li>
<li>（或者）也可以真正抽象出一个新的概念来进行管理，这取决于打包器和安装器之间的协作。</li>
</ul>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>版本管理的智慧，其实已经体现在当年的 RPM / DEB / PKGBUILD 中。
我们通过明确版本定义权交给应用作者，提出制品嵌套的概念，允许版本的概念进行多层嵌套。</p>
<p>我们希望，最后运行的制品版本仍然是原始应用版本（Upstream Version）的衍生。毕竟，
让每个运行的程序都知道自己来自何处、自己是谁，在大规模集群管理下已经变得相当重要。</p>
]]></content:encoded>
    </item>
    <item>
      <title>架构设计 the Easy Way</title>
      <link>https://blog.alswl.com/2023/07/architecture-design-the-easy-way/</link>
      <pubDate>Sat, 29 Jul 2023 14:54:27 +0800</pubDate>
      <guid>https://blog.alswl.com/2023/07/architecture-design-the-easy-way/</guid>
      <description>&lt;p&gt;




&lt;img loading=&#34;lazy&#34; src=&#34;https://blog.alswl.com/images/202307/arch-easy.png&#34; alt=&#34;arch-easy&#34;  /&gt;


&lt;/p&gt;
&lt;p&gt;&lt;small&gt;image via &lt;a href=&#34;https://pixabay.com/photos/child-tower-building-blocks-blocks-1864718/&#34;&gt;Pixabay&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;
&lt;p&gt;前几日，我在团队内部举行了一场技术分享，我介绍了关于架构设计的最佳实践。将这些实践凝练成了 &lt;mark&gt;20 字口诀&lt;/mark&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;架构看问题&lt;/li&gt;
&lt;li&gt;需求看用例&lt;/li&gt;
&lt;li&gt;设计看模型&lt;/li&gt;
&lt;li&gt;细节看时序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我将顺口溜转到了 &lt;a href=&#34;https://twitter.com/alswl/status/1683778487726006272&#34;&gt;Twitter&lt;/a&gt;，不少朋友对这些顺口溜产生了浓厚兴趣，希望深入了解。因此，我将我分享中的观点扩展成了这篇文章。&lt;/p&gt;
&lt;h2 id=&#34;架构设计和系统分析&#34;&gt;架构设计和系统分析&lt;/h2&gt;
&lt;p&gt;让我们首先澄清 &lt;mark&gt;什么是架构设计和系统分析&lt;/mark&gt;（简称系分）。有些朋友对前者很熟悉，对后者却不太了解。
不过没关系，以下是维基百科上的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;架构，&lt;strong&gt;软件架构&lt;/strong&gt;是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。&lt;/p&gt;
&lt;p&gt;系统分析，旨在研究特定系统结构中各部分（各子系统）的相互作用，系统的对外接口与界面，以及该系统整体的行为、
功能和局限，从而为系统未来的变迁与有关决策提供参考和依据。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/arch-easy.png" alt="arch-easy"  />


</p>
<p><small>image via <a href="https://pixabay.com/photos/child-tower-building-blocks-blocks-1864718/">Pixabay</a></small></p>
<h2 id="概览">概览</h2>
<p>前几日，我在团队内部举行了一场技术分享，我介绍了关于架构设计的最佳实践。将这些实践凝练成了 <mark>20 字口诀</mark>：</p>
<ol>
<li>架构看问题</li>
<li>需求看用例</li>
<li>设计看模型</li>
<li>细节看时序</li>
</ol>
<p>我将顺口溜转到了 <a href="https://twitter.com/alswl/status/1683778487726006272">Twitter</a>，不少朋友对这些顺口溜产生了浓厚兴趣，希望深入了解。因此，我将我分享中的观点扩展成了这篇文章。</p>
<h2 id="架构设计和系统分析">架构设计和系统分析</h2>
<p>让我们首先澄清 <mark>什么是架构设计和系统分析</mark>（简称系分）。有些朋友对前者很熟悉，对后者却不太了解。
不过没关系，以下是维基百科上的介绍：</p>
<blockquote>
<p>架构，<strong>软件架构</strong>是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。</p>
<p>系统分析，旨在研究特定系统结构中各部分（各子系统）的相互作用，系统的对外接口与界面，以及该系统整体的行为、
功能和局限，从而为系统未来的变迁与有关决策提供参考和依据。</p></blockquote>
<p>来看一下英文定义可能会更清晰：</p>
<ul>
<li>架构 = 软件架构（设计） = Software Architecture <a href="https://en.wikipedia.org/wiki/Software_architecture">Software architecture - Wikipedia</a></li>
<li>系分 = 系统分析 = System Analysis
<a href="https://en.wikipedia.org/wiki/Systems_analysis">Systems analysis - Wikipedia</a> + <a href="https://en.wikipedia.org/wiki/Systems_design">Systems design - Wikipedia</a></li>
</ul>
<p>我们有时候提到的设计文档，可能涵盖整个设计过程，包括架构设计、系统分析以及其他设计活动（交流、PoC）。</p>
<p>软件架构（设计）= Software Architecture</p>
<ul>
<li>设计和实现软件系统的基本结构和组织形式</li>
<li>在业务层面：明确问题，厘定概念，呈现价值</li>
<li>在技术层面：确定基础框架，将不确定性转化为确定性</li>
<li>工程层面：识别边界和拆分各个模块，提高应用开发效率</li>
</ul>
<p>系统分析 = System Analysis</p>
<ul>
<li>对业务需求和问题进行分析和研究的过程</li>
<li>在业务层面：需求收集、需求分析</li>
<li>在技术层面：建模，绘制流程图、数据流图和接口设计</li>
<li>工程层面：在应用、系统框架内实现需求</li>
</ul>
<p>最后，我来解释一下我对这两者边界的理解。实际上，我认为<mark>架构设计和系统分析并没有明显的界限</mark>。
一个系统或模块不管如何都会进行系统分析，而当出现以下几个特征时，就开始考虑架构设计问题：</p>
<ul>
<li>当有超过 3 个团队在协作时，因为这时涉及到利益和边界的问题。</li>
<li>当开始主动或被动引入不确定性。</li>
<li>当开始平衡取舍，需要先做到什么程度，再做到什么程度。</li>
<li>当不系统过于复杂，太容易达成一致，开始有解释成本时。</li>
<li>当能够提供别人不了解的信息。</li>
</ul>
<h2 id="什么是架构">什么是架构</h2>
<p>在这里，我们讨论的是技术架构，不会涉及业务架构或产品架构等方面。
技术方面的讨论重点是<mark>如何更高效地利用技术能力和方法来解决特定类型的问题</mark>。</p>
<p>进一步地，技术架构可以分为两种：一种是<mark>从顶层向下</mark>看，包括业务、战略和框架划分；
另一种是<mark>关注工程实现（编码）</mark>层面需要解决的架构问题。</p>
<p>那些经验丰富的人常常有较宏观的视角，使用的常见名词有：全局、宏观、领域、战略、平衡、规划。我将这些词汇整理成了一个词云如下：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/word-cloud-arch-biz.png" alt="word-cloud-arch-biz"  />


</p>
<p><small>generted by <a href="https://tendcode.com/tool/word-cloud/">https://tendcode.com/tool/word-cloud/</a></small></p>
<p>以上这些概念在架构设计和系统分析中都非常重要，因为它们帮助我们在整体上考虑问题，甚至超越技术层面，
从业务价值、商业策略和业务战略的角度思考问题。</p>
<p>另一种架构偏重于工程设计和实现。常见的关键词有：领域建模、UML、GoF23，SOLID，高内聚低耦合等等。对应的词云如下：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/word-cloud-arch-impl.png" alt="word-cloud-arch-impl"  />


</p>
<p><small>generted by <a href="https://tendcode.com/tool/word-cloud/">https://tendcode.com/tool/word-cloud/</a></small></p>
<p>架构的话题非常广泛，本文选择从一个切入点出发：<mark>通过实践和方法论，使架构意识在日常工作中发挥作用，以满足 80%的工程设计开发场景</mark>。
我称之为「架构设计 the easy way」。</p>
<h2 id="极简架构设计---架构看问题">极简架构设计 - 架构看问题</h2>
<p>理解架构的第一步，也是最重要的一步，就是关注「问题」。也就是说，<mark>你遇到了什么问题，你将如何去解决它</mark>？</p>
<p>通常情况下，如果我们的业务和系统都稳定运行，没有遇到任何问题，我们就不太需要进行架构设计。但是，只要涉及到架构设计，
必定是因为我们遇到了问题。这些问题可能源自新的需求，也可能是外部环境的变化，
亦或是系统自身随着时间的发展而出现的。无论问题的来源如何，我们都遇到了问题。</p>
<p>遇到问题之后，我们该如何解决？就像将大象装进冰箱一样，需要分成几个步骤。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/elephant.png" alt="把大象装进冰箱"  />


</p>
<p><small>image via unkown</small></p>
<p>因此，解决问题也有三个步骤：第一步是将问题描述清楚，第二步是进行协商和决策达成一致，第三步则是着手解决问题。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/q-n-a.png" alt="问题-一致-行动"  />


</p>
<p>我还想问一个听上去很愚蠢的问题：为什么不能直接解决问题？</p>
<p>因为问题是复杂的，有许多解决路径，不同的解决方案各有优劣和成本。在架构设计中，我们需要完成这些决策。</p>
<p>那为什么不直接进行决策，甚至直接开始动手？</p>
<p>首先可能涉及到职权问题，架构师未必有最终决策权，需要有决策权的人来做最后的决定。
第二个原因是架构师未必是方方面面的专家，设计一个复杂系统时候需要协调多个部分和领域专家来一起评估决策。</p>
<h3 id="案例">案例</h3>
<p>我举 Prometheus 的架构设计来作为例子。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/prometheus-architecture.png" alt="Prometheus architecture"  />


</p>
<p><small>image via <a href="https://prometheus.io/docs/introduction/overview/">Prometheus</a></small></p>
<p>这个架构图回答了很多问题，我举几个例子：</p>
<ul>
<li>问题：数据采集使用 Push 还是 Pull？使用什么存储？如何设计告警链路？</li>
<li>决策：采用 Pull（少量情况下使用 Pushgateway）；使用自己实现的 TSDB；使用 Alertmanager 与外部系统对接</li>
<li>ROI：采用 Pull 降低 Target 观测成本，不需要使用 Push-based 的 Registry；
没有现成的外部实现（当时）；提供 Router / Sub 的告警机制以便灵活接入外部系统</li>
</ul>
<h3 id="小结">小结</h3>
<p>问题驱动架构变化，架构方案应对问题，架构评审统一解决方案。</p>
<p>关于决策拍板问题。我强烈推崇架构师根据自己具备的领域知识、对行业的判断以及对现状的了解，
做出自己的思考和独立判断。这些思考过程应该有因果关系的支持，<mark>一个优秀的架构师必定拥有自己的观点</mark>。</p>
<p>最后，我补充一个小问题：为什么这里没有提到架构分层、模块分层？</p>
<p>不是因为分层和框架不重要，而是在因为大家都很专业。分层和模块化已经是基本常识和技能，因此反而往往不会成为争论和决策的焦点。
如果分层和框架无法快速形成一致，有可能团队构成上存在问题，也可能问题过于复杂已经不是 80% case。</p>
<p>在本阶段，产出的成果包括架构图以及对问题、价值、成本、风险和分工达成一致的认识。</p>
<h2 id="极简架构设计---需求看用例">极简架构设计 - 需求看用例</h2>
<p>需求是对问题的解答。我个人喜欢用<mark>思维导图或白纸来画图</mark>，将需求讲清楚。
画什么内容呢？理清角色，并列出各种动作和行为。</p>
<p>那有什么技巧可以将事项都整理出来呢？我经常使用<mark>主谓宾状从</mark>的方法。
也就是说，明确哪些人，在什么场景（可选），以什么状态（可选）做着什么事情。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/gramma.jpg" alt="主谓宾"  />


</p>
<p><small>image via unkown</small></p>
<p>通过用例将需求清晰地拆解，并在这个过程中不断与需求提供方进行交流和沟通。</p>
<p><mark>Demo 稿是产品经理的武器，而需求用例则是工程师的武器。</mark></p>
<p>有些初入职场的研发人员会不自然地变成需求的执行者。我比较果断地判断，不了解业务的工程师和外包没什么区别。而需求分析环节是最重要的，
是对业务输入进行理解、梳理、重新设计的机会。通过用例的整理，我们可以将一些不切实际、不可靠的需求反馈给需求方。</p>
<p>这是少数可以推动（反馈）需求方的阶段，一定要珍惜。</p>
<h3 id="案例-1">案例</h3>
<p>这里有一个产品用例的范例：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/netease-music.png" alt="网易云音乐"  />


</p>
<p><small>image via <a href="https://www.woshipm.com/evaluating/3493594.html">网易云音乐产品分析报告</a></small></p>
<p>实际上，这个用例是敌对势力那边总结的 😄，但仍然能够体现用例的重要性。</p>
<h3 id="小结-1">小结</h3>
<p>除了使用主谓宾的方式来进行设计，还有一些其他技巧：</p>
<ul>
<li>使用动线（行动路线）：想象用户（或行动者）完成他们目标的行动路线</li>
<li>可以优先考虑解决核心路径中的 20%问题</li>
<li>通过分角色、正交拆分等方式将用例整理得更加清晰；将用例分类分到各个模块</li>
</ul>
<p>本阶段的产出物包括：Demo 稿、用例图。</p>
<h2 id="极简架构设计---设计看模型">极简架构设计 - 设计看模型</h2>
<p>在我看来，设计的核心在于模型：<mark>模型确定了数据的载体和边界</mark>。而<mark>数据确定了组成部分，边界则确定了归属和职责</mark>。
在 UML 中，大量的 Entity 和 Object 用于确定模型的边界。
随着业务系统复杂程度的增加，建模也会面临更加复杂的挑战。</p>
<p>我总结了一下我建模的几个要点：</p>
<ul>
<li>明确术语（中英文）、含义、备注。</li>
<li>确定核心模型（重点放在最关键的 20%）。</li>
<li>提炼和抽象模型。</li>
<li>明确模型之间的关联关系。</li>
<li>结合动态和静态：少量模型具有行为，关注其提供的功能（Functions）。</li>
<li>业务模型 &lt;-&gt; 数据模型转换。</li>
</ul>
<p>很多人对中英文术语表不屑一顾，但我却很在意这点。有一个效应叫做「外语陌生感」（Foreign Language Effect），
就像博物学使用拉丁语 / 希腊语来描述物种一样。我们非英语母语的工程师，使用英文描述术语可以快速地聚焦问题。</p>
<p>始终牢记 80/20 原则的存在，特别是在设计阶段，一定要关注核心对象，将其放大而非过度关注细节。
一般来说，关注最核心的 20%模型就可以满足大部分场景。</p>
<p>在模型的提炼和抽象过程中要反复斟酌，并且可以将这个过程联动到前期的用例定义和后期的时序设计，
这需要大量领域知识的支持。我个人喜欢在这个阶段参考外部的代码和设计。</p>
<p>模型之间的关联关系主要是 1:1 / 1:N / M:N 关系，需要使用箭头清楚地标记主从关系。主从关系意味着从属关系，
这会影响后续一系列细节设计（如 URL、数据库、生命周期管理等）。
我个人推荐避免使用 M:N 关系，这种形式通常表明中间会有一个凭证（Credential）或关系（Relationship / Binding）。</p>
<p>除了关注静态的数据，还要关注模型的行为（极少量模型才有）。这个阶段可以进一步做一些识别，方便下一步的细节设计。</p>
<p>完成业务模型设计之后，同时要考虑数据模型。对于普通业务系统，这个转换会非常直观简单。业务系统通常是无状态系统，
完全依赖数据库进行存储。如果面临 DIA（Data Intensive Application）系统，就要考虑运行时数据的管理，
以及一系列复杂的生命周期管理和可用性管理（我估计有这个需求的朋友，不会看到这里了）。</p>
<h3 id="案例-2">案例</h3>
<p>我举例一个 Kubernetes 的 RBAC（Role-Based Access Control）系统，这是常见的 AuthZ 授权鉴权系统（注意，不是 AuthN 认证系统）。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/rbac.png" alt="Kubernetes RBAC"  />


</p>
<p><small>image via <a href="https://dev.to/alcide/kubernetes-rbac-moving-from-it-s-complicated-to-in-a-relationship-1bbm">Kubernetes RBAC - DEV Community</a></small></p>
<p>这里我抛几个问题：</p>
<ul>
<li>为什么需要使用 Role / ClusterRole 两种？它们的结构如何？</li>
<li>为什么不使用 ACL？使用 ACL 和使用 RBAC 有什么差异？</li>
<li>为什么不用 Policy？为什么不使用 Policy？</li>
</ul>
<p>这些答案都需要建模来回答的。</p>
<h3 id="非业务系统的模型">非业务系统的模型</h3>
<p>在我们的讨论中，更多关注的是业务模型，即用户能感知并产品能理解的模型，通常需要存储在数据库中。</p>
<p>但在基础设施领域，也是有模型的，有时候称之为&quot;概念&quot;（Concept）。基础设施领域的模型通常会简单得多，
而业务模型可能会非常复杂，因为世界本身就很复杂，而基础设施则专注于解决非常垂直领域的问题，因此相对简单。</p>
<p>此外，基础设施领域的特殊性会导致有很多抽象的建模，例如最简单到我们常常忽略的（Manager / Service）类别。
一些带有数据和状态的模型，比如 Executor，是常见的概念，而 Registry / Queue 也是常见的概念。</p>
<p>这是 Kubernetes的 <a href="https://kubernetes.io/docs/concepts/">Concepts</a>，十几个子类，上百个概念更显这个系统的复杂性。</p>
<h3 id="小结-2">小结</h3>
<p>模型不仅仅是数据，还涉及边界，边界决定了其归属和职责。</p>
<p>模型的设计需要动静结合来看，静态方面关注其持有的内容，动态方面则关注其提供的功能。</p>
<p>在基础设施领域，模型的产出可能包括 UML Model 图、ER 图、数据库 DML、类文件、OpenAPI Swagger（部分）等。</p>
<h2 id="极简架构设计---细节看时序">极简架构设计 - 细节看时序</h2>
<blockquote>
<p>程序设计 = 数据结构 + 算法 + 流程控制</p></blockquote>
<p>在将设计转换为模型之前，最后一个重要的步骤是控制细节。对于需求方和决策者来说，这一步可能并不重要，
但对于实施方（开发团队）来说，这个步骤直接影响交付结果的质量和时间。</p>
<p>我认为细节应该在时序图上进行呈现。</p>
<p>通常我们有两种常用的图形来展示细节：<mark>流程图和时序图</mark>。两者实际上有很多相似之处，
但我个人更喜欢时序图，因为它不仅包含顺序的概念，还清晰地展示了流程和系统之间的交互边界。</p>
<p>我的技巧是，一般每个用例都会对应一个时序图。</p>
<h3 id="案例-3">案例</h3>
<p>这里以 AWS 一个官方博客作为范例：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202307/aws-seq.png" alt="Header-based API Gateway versioning with CloudFront"  />


</p>
<p><small>via <a href="https://aws.amazon.com/blogs/architecture/sequence-diagrams-enrich-your-understanding-of-distributed-architectures/">AWS Architecture Blog</a></small></p>
<p>在上图中，展示了 AWS 中使用 CloudFront 的一个时序图，从时序图中可以清晰地看到多个系统之间请求的流转以及多种异常状态的处理。</p>
<h3 id="小结-3">小结</h3>
<p>这里我总结一下时序图的小技巧：</p>
<ul>
<li>用户动作是发起</li>
<li>系统边界要清晰</li>
<li>有去有回是同步</li>
<li>有去无回是异步</li>
</ul>
<p>一般来说，时序图画好了，就可以放心地交给项目团队开始实施，不会有大的错误。如果没有时序图，依赖的就完全是彼此之间的合作经验和信任度了。</p>
<p>产出：时序图、API 文档（Open API Swagger）、前端 service 生成（如果有）。</p>
<h2 id="极简架构设计---小结">极简架构设计 - 小结</h2>
<p>在这个阶段，尽管我们还没有开始编写代码，但已经清楚了需要做什么，以及实现的样子。
我们也有了类结构、API 定义、前端服务生成等产出。多个团队可以同时开始协作，没有明显的瓶颈。</p>
<ul>
<li>✅ 问题定义</li>
<li>✅ 解决方法</li>
<li>✅ 类结构、API 定义</li>
<li>✅ 服务端代码生成</li>
<li>✅ 流程确定</li>
<li>✅ 汇报材料 1/3</li>
<li>✅ 技术分享材料 1/2</li>
</ul>
<p>如果未来需要汇报，汇报材料已经有了 1/3 的内容。如果需要撰写技术分享文档，也已经具备了 1/2 的内容。</p>
<p>如果这个项目是一个简单的 CRUD 应用系统，那么基本不会有什么难点。</p>
<p>如果是一个 DIA 系统（Data Intensive Application），则需要开始设计和实施数据存储部分，并考虑数据一致性和并发相关的问题。对于一个复杂的系统，
还需要继续实施多个系统连接处是否存在不确定性。如果在工程上面临同步方面的挑战，例如应用框架改造、通讯系统改造等，
也要提前进行风险排除。（我认为同时进行技术升级和业务开发并不明智）。</p>
<h2 id="番外---画图工具">番外 - 画图工具</h2>
<p>我有一套自己的画图工具套件，涵盖了系统架构图、流程图等绘制。
PS：我甚至还给自己的产品设计 Logo，或许这与我内心渴望成为一名设计师有关吧~</p>
<p>作为一名工程师，必须积累自己的画图 UI Kit，熟练掌握其技巧，构建一套属于自己的工具包，
从而能够将脑海中的构思快速还原到文档中。</p>
<p>我的画图工具组合相当丰富。用于绘制架构图的工具包括：</p>
<ul>
<li>框图
<ul>
<li>OmniGraffle（收费，复杂、美观）</li>
<li>Excalidraw（简单、随性）</li>
</ul>
</li>
<li>部署图
<ul>
<li>Excalidraw</li>
</ul>
</li>
<li>脑图 MindMap
<ul>
<li>SimpleMind（收费）</li>
<li>XMind（收费）</li>
</ul>
</li>
</ul>
<p>用来做工程设计（UML）的工具如下：</p>
<ul>
<li>use case 用例
<ul>
<li>语雀画图</li>
<li>plantuml（语雀支持渲染）</li>
</ul>
</li>
<li>sequence 时序图
<ul>
<li>plantuml</li>
</ul>
</li>
<li>state 状态图
<ul>
<li>语雀</li>
</ul>
</li>
<li>ER 图
<ul>
<li>Excalidraw</li>
</ul>
</li>
<li>Gantt 甘特图
<ul>
<li>plantuml</li>
</ul>
</li>
</ul>
<p>这里我再软广一下我维护的 <a href="https://excalidraw.alswl.com/">Excalidraw（Fork）</a>，支持中文手写字体，保持风格的统一。</p>
<h2 id="番外---the-hard-way">番外 - the Hard Way</h2>
<p>回到本次分享的出发点，给大家一份简单可行的架构设计方案。
但是对于你这样好学的人来说，肯定不会满足于如此简单的流程，
毕竟还有那 20% 的复杂场景无法完全涵盖。
我给你一个关键词列表和一些建议的书单，帮助你进一步加深学习：</p>
<ul>
<li>原则</li>
<li>理念</li>
<li>思想</li>
<li>规律</li>
<li>方法论</li>
<li>案例</li>
</ul>
<p>以下是一些书单，可以帮助你深入学习：</p>
<ul>
<li>业务架构
<ul>
<li><a href="https://book.douban.com/subject/1792387/">UML 和模式应用 - Craig Larman</a></li>
<li><a href="https://book.douban.com/subject/5344973/">领域驱动设计 - Eric Evans</a></li>
</ul>
</li>
<li>技术架构
<ul>
<li><a href="https://book.douban.com/subject/30468597/">重构 - Martin Fowler</a></li>
<li><a href="https://book.douban.com/subject/4199741/">代码整洁之道 - Robert C. Martin</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>
