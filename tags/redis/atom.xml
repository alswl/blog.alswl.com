<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>redis on Log4D</title><link>https://blog.alswl.com/tags/redis/</link><description>Recent content in redis on Log4D</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 26 Jul 2015 15:33:49 +0800</lastBuildDate><atom:link href="https://blog.alswl.com/tags/redis/atom.xml" rel="self" type="application/rss+xml"/><item><title>Redis 集群扩容</title><link>https://blog.alswl.com/2015/07/redis-migration/</link><pubDate>Sun, 26 Jul 2015 15:33:49 +0800</pubDate><guid>https://blog.alswl.com/2015/07/redis-migration/</guid><description>几乎每一个网站都需要用户登录状态系统，其中核心是存储 Session 的用户登录状态存储系统。 主流的实现之一是使用 Redis 存储用户登录信息，Redis 特点是功能简单、无依赖、 存储结构丰富、有持久化功能。 我大堆糖的 Session 存储系统也正是基于 Redis。
可是 Redis 也存在一些问题，比如 Redis 自身没有 Sharding 功能，Replication 也是在逐步完善完善过程中 （2.4 支持 Replication，2.8 加入 Replication partial resynchronization 功能）。 纵观当下流行的 DB 系统，哪个不是自带这两个特性，这两个分布式特性应该成为新出产的 DB 系统的标配。 而且作者还经常发布延期，放烟雾弹，不知道 Redis 自带 Sharding 特性要等到何年马月。
随着业务规模的扩大，单台 Redis 实例不能满足需求。 考虑到 Redis 也是久经考验的战士，替换掉他成本比较高，那就对 Redis 进行扩容。
扩容的基本要求是：
扩大系统容量，成为分布式系统，未来有横向扩展 业务不中断 保证原始数据的可用性 Google 了一下，有两个项目可以参考： https://github.com/idning/redis-mgr 和豌豆荚的 Codis。
研究了这两项目的代码之后，发现前者存在几个问题： 需要停机进行操作。 后者提供了完整一套解决方案，Server/Proxy/Config Manage，对我这次迁移来说，太重了， 而且项目比较新，风险高，只能用来参考实现方法。
最后我决定参考 redis-mgr 的方案，然后使用两种方式同步数据： 系统运行中打上 patch 完成数据的动态迁移；后台跑迁移数据脚本。
方案的关键词 dump / restore / pttl 核心的操作流程是： 使用 dump 命令导出数据，restore 命令恢复数据，pttl 命令获取设置 TTL。</description></item><item><title>hiredis 源码学习</title><link>https://blog.alswl.com/2014/03/hiredis/</link><pubDate>Sun, 30 Mar 2014 15:41:43 +0800</pubDate><guid>https://blog.alswl.com/2014/03/hiredis/</guid><description>前段时间学习 Redis 时候，听到 hiredis 的大名，正好也在做异步的学习，就找来代码学习一下。 我几乎不太会 C，仅限于最简单的语法，完全没有在生产环境中写过， 所以先看个 Client 简单代码，下次看 Memcached 代码应该会更顺畅一些。
Hiredis 是用 C 写的 Redis 客户端，对 Redis 协议进行了简单的封装， 同时提供了同步和异步的两种 API。Hiredis 的代码位于 https://github.com/redis/hiredis。
一分钟使用入门 同步 API 的调用方法：
redisContext *context = redisConnect(&amp;#34;127.0.0.1&amp;#34;, 6379); reply = redisCommand(context, &amp;#34;SET foo %s&amp;#34;, value); printf(&amp;#34;PING: %s\n&amp;#34;, reply-&amp;gt;str); freeReplyObject(reply) redisFree(context); Redis ae 异步 API 的调用方法，使用 Redis 自己的 ae 事件库， 至于为什么 Redis 没有使用 libevent 或者 libev，可以参考 Reason， 中文翻译：
void connectCallback(const redisAsyncContext *c, int status) { printf(&amp;#34;Connected...\n&amp;#34;); } void disconnectCallback(const redisAsyncContext *c, int status) { printf(&amp;#34;Disconnected.</description></item><item><title>Redis 到底有多快[译文]</title><link>https://blog.alswl.com/2014/02/redis-benchmarks/</link><pubDate>Sun, 23 Feb 2014 22:38:00 +0800</pubDate><guid>https://blog.alswl.com/2014/02/redis-benchmarks/</guid><description>原文地址 http://redis.io/topics/benchmarks。
拖了一个半月的稿子~
Redis 自带了一个叫 redis-benchmark 的工具来模拟 N 个客户端同时发出 M 个请求。 （类似于 Apache ab 程序）。你可以使用 redis-benchmark -h 来查看基准参数。
以下参数被支持： Usage: redis-benchmark [-h &amp;lt;host&amp;gt;] [-p &amp;lt;port&amp;gt;] [-c &amp;lt;clients&amp;gt;] [-n &amp;lt;requests]&amp;gt; [-k &amp;lt;boolean&amp;gt;] -h &amp;lt;hostname&amp;gt; Server hostname (default 127.0.0.1) -p &amp;lt;port&amp;gt; Server port (default 6379) -s &amp;lt;socket&amp;gt; Server socket (overrides host and port) -c &amp;lt;clients&amp;gt; Number of parallel connections (default 50) -n &amp;lt;requests&amp;gt; Total number of requests (default 10000) -d &amp;lt;size&amp;gt; Data size of SET/GET value in bytes (default 2) -k &amp;lt;boolean&amp;gt; 1=keep alive 0=reconnect (default 1) -r &amp;lt;keyspacelen&amp;gt; Use random keys for SET/GET/INCR, random values for SADD Using this option the benchmark will get/set keys in the form mykey_rand:000000012456 instead of constant keys, the &amp;lt;keyspacelen&amp;gt; argument determines the max number of values for the random number.</description></item></channel></rss>