<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>gae on Log4D</title>
    <link>https://blog.alswl.com/tags/gae/</link>
    <description>Recent content in gae on Log4D</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 24 Mar 2012 00:00:00 +0800</lastBuildDate><atom:link href="https://blog.alswl.com/tags/gae/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GAE 编程指南读书笔记</title>
      <link>https://blog.alswl.com/2012/03/gae/</link>
      <pubDate>Sat, 24 Mar 2012 00:00:00 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2012/03/gae/</guid>
      <description>GAE 和我蛮有缘分，我初学 Python 的其中一个原因就是当时 GAE 刚推出， 当时想法是免费的应用要用起来，要不然就浪费了。随后也假模假样的看文档， 就是没有什么产出。 去年写了一个小应用 dbevent2gc ， 期间发现 GAE 和普通程序开发的诸多不同，又遭遇 GAE 配额大幅缩水， 写出来的应用运转的不太稳定。在南京图书馆的架上看见这本《GAE 编程指南读书笔记》， 立即借回家仔细阅读。 GAE 的简介 运行时环境 Python / Java 数据存储 Datastore（实体 / 查询 / 索引 / 事务</description>
      <content:encoded><![CDATA[<p>GAE 和我蛮有缘分，我初学 Python 的其中一个原因就是当时 GAE 刚推出， 当时想法是免费的应用要用起来，要不然就浪费了。随后也假模假样的看文档，
就是没有什么产出。</p>
<p>去年写了一个小应用 <a href="https://github.com/alswl/dbevent2gc">dbevent2gc</a> ， 期间发现 GAE
和普通程序开发的诸多不同，又遭遇 GAE 配额大幅缩水， 写出来的应用运转的不太稳定。在南京图书馆的架上看见这本《GAE 编程指南读书笔记》，
立即借回家仔细阅读。</p>
<ul>
<li>
<p>GAE 的简介</p>
<ul>
<li>运行时环境 Python / Java</li>
<li>数据存储 Datastore（实体 / 查询 / 索引 / 事务）</li>
<li>服务（Memcache / GAccount / 任务队列 / 计划任务）</li>
<li>工具（SDK / appcfg / dev_appserver / 控制台）</li>
</ul>
</li>
<li>
<p>入门（安装 / GAccount / webapp / app.yaml / /_ah/admin / 注册部署 / login:required）</p>
</li>
<li>
<p>处理流程：请求 - 前端 - 引用服务器 / 静态文件服务器 - 服务</p>
<ul>
<li>配额限制：请求限制 / CPU 限制 / 服务限制 / 部署限制 （最新配额：http://code.google.com/intl/zh-CN/appengine/docs/quotas.html）</li>
</ul>
</li>
<li>
<p>数据存储</p>
<ul>
<li>
<p>GAE 的数据存储方式和传统的 RDBMS 差异比较大，更类似于对象数据库。</p>
</li>
<li>
<p>类别 kind / 键 / 键名 key name</p>
</li>
<li>
<p>可以通过键来获取和操作对象</p>
<ul>
<li><code>e = db.get(db.Key('Entity', 'alphabeta'))</code> / <code>e = Entity.get(k)</code></li>
<li><code>e = db.get(k)</code></li>
<li><code>e.delete()</code> / <code>db.delete(e1, e2)</code> / <code>db.delete(k)</code></li>
</ul>
</li>
<li>
<p>Expando 基类可以任意扩展属性，Model 基类则不可。</p>
</li>
<li>
<p>GAE 中基本类型与 Python / Java 中基本类型的差异</p>
</li>
<li>
<p>多值属性</p>
</li>
</ul>
</li>
<li>
<p>数据查询</p>
<ul>
<li>查询和类别 <code>db.query()</code> <code>query.filter()</code> <code>query.order()</code></li>
<li>查询和键：查询结果要么返回实体，要么返回键（ <code>key_only=True</code> ）</li>
<li>可以用 GQL 写查询语句，不能写 CUD</li>
<li>获取结果： <code>fetch()</code></li>
</ul>
</li>
<li>
<p>索引</p>
<ul>
<li>每条查询都需要维护一条索引，在 <code>index.yaml</code> 中可以配置</li>
<li>排序之后的索引查询很快，查询效率和返回结果集有关</li>
<li>实体的每个属性会自动维护两条索引：升序和降序</li>
<li>查询时候选取对应的索引进行查询，条件语句可能和排序语句相冲突</li>
<li>不等于 / IN 操作符将引发一系列变换出的查询</li>
<li>多值字段的索引：每个值会成为索引中一行 / 实体会因此分散 / 取第一次成功扫描到的行</li>
<li>多值会引入爆炸索引问题</li>
</ul>
</li>
<li>
<p>事务</p>
<ul>
<li>通过实体组来控制事务，实体组会在同一块存储区</li>
<li>GAE 使用乐观锁</li>
<li>使用 <code>AModel(parent=p)</code> 构造祖先，然后通过 <code>run_in_transation()</code> 回调事务处理函数</li>
<li>BigTable 中使用日志+时间戳来跟踪实体的修改，保证数据并发和一致性</li>
<li>事务更新和索引更新：可能返回的索引结果和实体不一致</li>
</ul>
</li>
<li>
<p>Python 数据建模</p>
<ul>
<li>
<p>声明 / 类型 / 验证（ <code>validate()</code> ）</p>
</li>
<li>
<p>不编入索引的属性 <code>indexed=False</code></p>
</li>
<li>
<p>时间类型的自动值</p>
</li>
<li>
<p>模型变化带来的维护问题：修改属性类型 / 添加一个必要属性是不向后兼容的。</p>
</li>
<li>
<p>关系建模</p>
<ul>
<li>db.ReferenceProperty</li>
<li>collection_name</li>
</ul>
</li>
<li>
<p>多对多关系的处理</p>
<ul>
<li>键列表方法：使用多值属性</li>
<li>链接模型方法：相当于中间表概念</li>
</ul>
</li>
<li>
<p>模型的继承：通过 <code>db.PolyModel</code> 实现多态查询</p>
</li>
</ul>
</li>
<li>
<p>Memcache</p>
<ul>
<li>CRUD</li>
</ul>
</li>
<li>
<p>获取 URL 资源</p>
<ul>
<li><code>urlfetch()</code></li>
</ul>
</li>
<li>
<p>RPC 异步请求调用，闭包调用</p>
</li>
<li>
<p>邮件和 XMPP</p>
<ul>
<li>额，亲用到时候看 Google 官方文档吧～</li>
</ul>
</li>
<li>
<p>大批量数据操作和远程访问</p>
<ul>
<li><code>/remote_api</code></li>
<li>Bulk Loader 大量数据操作</li>
<li>远程 shell <code>remote_api_shell.py app-id</code></li>
</ul>
</li>
<li>
<p>任务队列和计划任务</p>
<ul>
<li>队列： <code>queue.yaml</code> / 令牌桶</li>
<li>计划任务： <code>cron.yaml</code></li>
<li>都是通过设定主动触发某个 url</li>
</ul>
</li>
<li>
<p>Django</p>
<ul>
<li>看 Django 文档吧，亲～</li>
</ul>
</li>
<li>
<p>部署</p>
<ul>
<li>上传 <code>appcfg.py update ./clock</code></li>
<li>通过 url 使用特定版本： <code>version-id.latest.app-id.appspot.com</code></li>
<li>版本只维护代码，数据库还是同一份</li>
<li>下载日志 <code>appcfg.py request_logs clock logs.txt</code></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>dbevent2gc v0.1发布</title>
      <link>https://blog.alswl.com/2011/11/dbevent2gc-v0-1-released/</link>
      <pubDate>Fri, 25 Nov 2011 00:00:00 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2011/11/dbevent2gc-v0-1-released/</guid>
      <description>重要通知：Log4D的域名由 http://dddspace.com 迁移到 http://log4d.com 。 订阅地址现在改为 http://log4d.com/feed 和 http://feeds.feedburner.com/dddspace 。（FeedBurner的地址未发生变化） http://feed.dddspace.com 弃用 请订阅我博客的朋友更新一下订阅地址。 关于dbevent2gc A application to sync douban.com events to Google Calendar. dbevent2gc是一个GAE应用，它将豆瓣同城的活动同步到Google Calendar的日历， 允许用户订阅活动而知道最近几周周边将发生活动。 dbevent2gc是基于Python/web.py/mako/iC</description>
      <content:encoded><![CDATA[<p>重要通知：Log4D的域名由 <a href="http://dddspace.com">http://dddspace.com</a> 迁移到
<a href="http://log4d.com">http://log4d.com</a> 。</p>
<p>订阅地址现在改为 <a href="http://log4d.com/feed">http://log4d.com/feed</a> 和
<a href="http://feeds.feedburner.com/dddspace">http://feeds.feedburner.com/dddspace</a>
。（FeedBurner的地址未发生变化）</p>
<p><strike><a href="http://feed.dddspace.com">http://feed.dddspace.com</a></strike> 弃用</p>
<p>请订阅我博客的朋友更新一下订阅地址。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/images/upload_dropbox/201111/dbevent2gc.png" alt="dbevent2gc"  />


</p>
<h2 id="关于dbevent2gc">关于dbevent2gc</h2>
<p>A application to sync douban.com events to Google Calendar.</p>
<p>dbevent2gc是一个GAE应用，它将豆瓣同城的活动同步到Google Calendar的日历， 允许用户订阅活动而知道最近几周周边将发生活动。</p>
<p>dbevent2gc是基于Python/web.py/mako/iCalendar的，源代码地址在
<a href="https://github.com/alswl/dbevent2gc">https://github.com/alswl/dbevent2gc</a></p>
<h2 id="使用方法">使用方法</h2>
<p>目前dbevent2gc运行在GAE上面，地址是 <a href="http://dbevent2gc.appspot.com">http://dbevent2gc.appspot.com</a> （墙外）
<a href="http://dbevent2gc.log4d.com/">http://dbevent2gc.log4d.com/</a> （我做的本地反向代理）
登录这个地址可以选择需要订阅的城市和活动类型，然后会生成一个按钮， 点击这个按钮可以直接将选择的活动订阅到Google日历。</p>
<p>如果你无法翻墙，可以使用 [http://dbevent2gc.appspot.com/event/location/beijing?type=all](h
ttp://dbevent2gc.appspot.com/event/location/beijing?type=all) 这样的地址添加到你的Google
Calender里面。</p>
<p>接受的参数：</p>
<ul>
<li>城市（把最后的beijing替换成你想要的城市拼音， 更多城市拼音查看<a href="http://www.douban.com/location/world/?others=true">这里</a></li>
<li>活动类型 type，支持all, commonweal, drama, exhibition, film, music, others, party, salon, sports, travel. 可选参数,默认为all</li>
</ul>
<h2 id="安装方法">安装方法</h2>
<p>如果想自己搭建GAE应用，也很简单，直接使用 <code>git://github.com/alswl/dbevent2gc.git</code> 就可以获取最新代码，
然后嘛去GAE注册一个应用，上传即可运行了。</p>
<p>dbevent2gc看上去可以用了，我昨晚发布了v0.1版本。</p>
<p>感兴趣的同学可以试试，现在的问题是获取的活动可能太多了，<strike>我后期会加上过滤功能</strike>（update
2011-11-26，我已经添加了活动类型选择功能）。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>最简陋的GAE代理</title>
      <link>https://blog.alswl.com/2011/01/a-simple-gae-proxy/</link>
      <pubDate>Tue, 11 Jan 2011 00:00:00 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2011/01/a-simple-gae-proxy/</guid>
      <description>年前换了一次服务器，之后发现Lifestream的Errors飙升到1000+错误，检查一下，发现是获 取不了豆瓣的rss链接。正好这台主机支持SSH，连入之后CURL了一下豆瓣服务器，发现Time out。 紧接着发现中国内的所有域名都无法使用CURL获取，联系小张之后，得知该主机曾经被入侵过，于是屏蔽了中国大陆的ip段（囧~入侵和中国ip有毛关系） 遂想用GAE做个代理服务器，反正获取RSS也只要Ge</description>
      <content:encoded><![CDATA[<p>年前换了一次服务器，之后发现<a href="http://log4d.com/stream">Lifestream</a>的Errors飙升到1000+错误，检查一下，发现是获
取不了豆瓣的rss链接。正好这台主机支持SSH，连入之后CURL了一下豆瓣服务器，发现Time out。</p>
<p>紧接着发现中国内的所有域名都无法使用CURL获取，联系小张之后，得知该主机曾经被入侵过，于是屏蔽了中国大陆的ip段（囧~入侵和中国ip有毛关系）</p>
<p>遂想用GAE做个代理服务器，反正获取RSS也只要Get一下，代码没几句。把这项任务放入Toodledo之后，就一直没去弄，今天发现GAE
Laucher升级了，就部署到自己GAE上了。</p>
<p>地址格式如<a href="http://jasontiproxy.appspot.com/proxy?url=www.douban.com/feed/people/alswl/interests">http://jasontiproxy.appspot.com/proxy?url=www.douban. com/feed/people/alswl/interests</a>，url参数名后面跟着具体的url。</p>
<p>代码其实就是用urllib2获取一下html，核心如下。</p>
<pre><code>#!/usr/bin/env python
</code></pre>
<p>from google.appengine.ext import webapp</p>
<p>from google.appengine.ext.webapp import util</p>
<p>import urllib2</p>
<p>class MainHandler(webapp.RequestHandler):</p>
<p>def get(self):</p>
<p>url = self.request.get(&lsquo;url&rsquo;)</p>
<p>if url.find(&lsquo;http://&rsquo;) &lt; 0:</p>
<p>url = &lsquo;http://&rsquo; + url</p>
<p>conn = urllib2.urlopen(url)</p>
<p>html = conn.read()</p>
<p>encoding = conn.headers[&lsquo;content-type&rsquo;].split(&lsquo;charset=&rsquo;)[-1]</p>
<p>html = html.decode(encoding).encode(&lsquo;utf-8&rsquo;)</p>
<p>self.response.out.write(html)</p>
<p>def main():</p>
<p>application = webapp.WSGIApplication([(&rsquo;/proxy&rsquo;, MainHandler)],</p>
<p>debug=True)</p>
<p>util.run_wsgi_app(application)</p>
<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>
<p>main()</p>
<p>申请一个空间，部署上去就行了，这个小应用可以临时获取一下网页内容，不支持Post和替换url，所以称之为&quot;最简陋的GAE代理&quot;。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>PylexChat可行性分析</title>
      <link>https://blog.alswl.com/2009/11/pylexchat-feasibility-analysis/</link>
      <pubDate>Mon, 23 Nov 2009 00:00:00 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2009/11/pylexchat-feasibility-analysis/</guid>
      <description>PylexChat介绍 PylexChat取名自Python+Flex+Chat部 分缩写，这就意味着这个系统是基于Python+Flex的聊天系统。之所以做这个系统，源自我大学的最后一次课程设计，我不想浪费这最后一次可以供我发 挥自己想象力的机会。年后估计要参加工作了，毕业设计也不敢做这么有想法的课程设计。那就最后一次潇洒一下，做一个我完全没有接触过的东西。 我几乎不会Python，是最近一个月迷上这门</description>
      <content:encoded><![CDATA[<h2 id="pylexchat介绍">PylexChat介绍</h2>
<p>PylexChat取名自<strong>Python</strong>+<strong>Flex</strong>+<strong>Chat</strong>部
分缩写，这就意味着这个系统是基于Python+Flex的聊天系统。之所以做这个系统，源自我大学的最后一次课程设计，我不想浪费这最后一次可以供我发
挥自己想象力的机会。年后估计要参加工作了，毕业设计也不敢做这么有想法的课程设计。那就最后一次潇洒一下，做一个我完全没有接触过的东西。</p>
<p>我几乎不会Python，是最近一个月迷上这门强悍而简单的语言，我完全不会Flex，是最近1周时间才开始接触Flex。这意味着这次课程设计的
风险挺大。我花了几天的时间做了详细的可行性分析，分析了系统框架和GAE能够提供的服务和限制以及Flex/AIR能做的内容，否决了几个方案，最后总
结了一篇简单可行性分析（本文是一周时间慢慢形成的，并没有遵循正规的开发文档风格）。</p>
<h2 id="几个基本的概念">几个基本的概念</h2>
<p>内容出自<a href="http://zh.wikipedia.org/">维基百科</a></p>
<h3 id="python">Python</h3>
<p>Python，是一种面向对象、直译式计算机程序设计语言，也是一种功能强大而完善的通用型语言，已经具有十多年的发展历史，成熟且稳定。</p>
<p>这种语言具有非常简捷而清晰的语法特点，适合完成各种高层任务，几乎可以在所有的操作系统中运行。</p>
<p>目前，基于这种语言的相关技术正在飞速的发展，用户数量急剧扩大，相关的资源非常多。</p>
<h3 id="flex">Flex</h3>
<p>Adobe Flex是最初由Macromedia公司在2004年3月发布的，基于其专有的Macromedia Flash平台，它是涵盖了支持RIA（Rich
Internet Applications）的开发和部署的一系列技术组合。</p>
<p>FLEX支持创建静态文件，该文件使用解释编译方式并且不需要购买服务器许可证就可以在线部署。</p>
<p>Flex的目标是让程序员更快更简单地开发RIA应用。在多层式开发模型中，Flex应用属于表现层。</p>
<p>Flex 采用GUI界面开发，使用基于XML的MXML语言。Flex 具有多种组件，可实现Web Services，远程对象，drag and
drop，列排序，图表等功能；FLEX内建动画效果和其它简单互动界面等。相对于基于HTML的应用（如PHP、ASP、JSP、ColdFusion
及CFMX等）在每个请求时都需要执行服务器端的模板，由于客户端只需要载入一次，FLEX应用程序的工作流被大大改善。FLEX的语言和文件结构也试图
把应用程序的逻辑从设计中分离出来。</p>
<p>Flex 服务器也是客户端和XML Web Services及远程对象（Coldfusion CFCs，或Java类，等支持Action Message
Format的其他对象）之间通讯的通路。</p>
<h3 id="air">AIR</h3>
<p>dobe AIR（AIR＝Adobe Integrated Runtime），开发代号为Apollo，是一个跨操作系统runtime
environment用来建造RIA，使用Flash、Flex、HTML与AJAX，可能部署为桌面应用程式。</p>
<p>AIR是Adobe针对网络与桌面应用的结合所开发出来的技术，可以不必经由浏览器而对网络上的云端程式做控制，也由于这是Adobe所开发的技术，因此能很顺利的与
Adobe旗下的Photoshop、Flash、Firework等应用程式来进行开发。</p>
<h3 id="google-app-engine">Google App Engine</h3>
<p>Google App Engine是一个开发、托管网络应用程序的平台，使用Google管理的数据中心。它在2008年4月发布了第一个beta版本。</p>
<p>Google App Engine使用了云计算技术。它跨越多个服务器和数据中心来虚拟化应用程序。 其他基于云的平台还有Amazon Web
Services和微软的Azure服务平台等。</p>
<p>Google App Engine在用户使用一定的资源时是免费的。支付额外的费用可以获得应用程序所需的更多的存储空间、带宽或是CPU负载。</p>
<h2 id="系统需要实现的功能">系统需要实现的功能</h2>
<p>我简单罗列一下：登录、群聊、私聊、注册（功能实现优先级由高到低排列）。</p>
<p>功能着实有点简单，不过这个系统的亮点在于跨平台，而不是功能的强大。我在设计时候会尽量考虑多些东西，方便以后扩展。</p>
<h2 id="数据交互实现方案">数据交互实现方案</h2>
<p>系统最主要也最难实现的部分是数据交互如何进行有效的交互。我总结了一下几种方法。</p>
<h3 id="1tcpip通信">1.TCP/IP通信</h3>
<p>一般的C/S模式程序都会考虑套接字连接方式，这是性能最高的交互方式。使用TCP/IP协议，能够有效的避免Python/Flex语言带来的数据交换问题。我查阅
了Flex文档，在<code>flash.net.Socket</code>下有套接字使用的API，这说明Flex在套接字支持上没有问题。接下来我查阅了GAE的文档，资料比较难找
，最后我查阅了[沙盒](<a href="http://code.google.com/intl/zh-CN/appengine/docs/java/runtime.html">http://code.google.com/intl/zh-CN/appengine/docs/java/runtime.html</a>
#The_Sandbox)的定义、Python/Java在GAE的限制（参考文献-[Will it play in AppEngine](<a href="http://groups.google.com/group/google-appengine-java/web/will-it-play-">http://groups.google.com/group/google-appengine-java/web/will-it-play-</a>
in-app-engine)），确定GAE不支持套接字和多线程。引用文字如下：<a href="http://groups.google.com/group/google-appengine-java/web/will-it-play-in-app-engine">via</a></p>
<blockquote>
<h4 id="沙盒">沙盒</h4>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>为了使得 App Engine
能够跨多个网络服务器分配对于应用程序的请求，并且防止应用程序彼此干扰，请在受限制的&quot;沙盒&quot;环境中运行应用程序。在这种环境中，该应用程序可执行代
码；可存储和查询 App Engine 数据存储区中的数据；可使用 App Engine 邮件、网址抓取和用户服务；可检查用户的网络请求以及准备响应。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>App Engine 应用程序无法：</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ul>
<li>向文件系统写入。应用程序必须使用 [App Engine 数据存储区](<a href="http://code.google.com/appengine/doc">http://code.google.com/appengine/doc</a>
s/java/datastore/)存储永久数据。允许从文件系统中读取，并且可使用与该应用程序一起上传的所有应用程序文件。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>打开套接字或直接访问另一主机。应用程序可使用 <a href="http://code.google.com/appengine/docs/java/urlfetch/">App Engine
网址抓取服务</a>分别向端口 80 和 443
上的其他主机发出 HTTP 和 HTTPS 请求。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>产生子进程或线程。必须在几秒钟内于单个进程中处理对应用程序的网络请求。响应时间很长的进程会被终止，以避免使网络服务器负载过重。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>进行其他类型的系统调用。</li>
</ul>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<h5 id="线程">线程</h5>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>Java 应用程序无法新建 <code>java.lang.ThreadGroup</code> 或 <code>java.lang.Thread</code>。这些限制也适用于利用线程的 JRE
类。例如，应用程序无法新建 <code>java.util.concurrent.ThreadPoolExecutor</code> 或
<code>java.util.Timer</code>。应用程序可以对当前线程执行操作，如 <code>Thread.currentThread().dumpStack()</code>。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<h5 id="文件系统">文件系统</h5>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>Java 应用程序无法使用任何用来写入文件系统的类，如 <code>java.io.FileWriter</code>。应用程序可以使用诸如
<code>java.io.FileReader</code> 的类从文件系统中读取自己的文件。应用程序也可以通过例如 <code>Class.getResource()</code> 或
<code>ServletContext.getResource()</code> 来访问作为&quot;资源&quot;的自身文件。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>只有视为&quot;资源文件&quot;的文件才可以由应用程序通过文件系统访问。默认情况下，WAR 中的所有文件都是&quot;资源文件&quot;。您可以使用 [appengine-
web.xml](<a href="http://code.google.com/intl/zh-">http://code.google.com/intl/zh-</a>
CN/appengine/docs/java/config/appconfig.html) 文件将文件从该组中排除出去。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<h5 id="javalangsystem">java.lang.System</h5>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>禁用不适用于 App Engine 的 <code>java.lang.System</code> 类的功能。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>以下 <code>System</code> 方法在 App Engine
中不起作用：<code>exit()</code>、<code>gc()</code>、<code>runFinalization()</code>、<code>runFinalizersOnExit()</code></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>以下 <code>System</code> 方法返回 <code>null</code>：<code>inheritedChannel()</code>、<code>console()</code></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应用程序无法提供或直接调用任何本机 JNI 代码。以下 <code>System</code> 方法引发
<code>java.lang.SecurityException</code>：<code>load()</code>、<code>loadLibrary()</code>、<code>setSecurityManager()</code></p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<h5 id="反射">反射</h5>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>允许应用程序对自己的类进行完全、无限制的反射访问。它可以查询任何私有成员，使用
<code>java.lang.reflect.AccessibleObject.setAccessible()</code>，以及读取/设置私有成员。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应用程序还可以对 JRE 和 API 类（如 <code>java.lang.String</code> 和 <code>javax.servlet.http.HttpServletR equest</code>）进行反射。但是，它只可以访问这些类的公共成员，而不可以访问受保护成员或私有成员。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>应用程序无法对不属于自己的任何其他类进行反射，也无法使用 <code>setAccessible()</code> 方法来避开这些限制。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<h5 id="自定义类载入">自定义类载入</h5>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>App Engine 完全支持自定义类载入。但是请注意，App Engine 将覆盖所有的
ClassLoader，以将相同的权限分配给所有由应用程序载入的类。如果执行自定义类载入，在载入不信任的第三方代码时要小心。</p>
</blockquote>
<blockquote>
<h4 id="有没有-google-app-engine-不支持的-python-库">有没有 Google App Engine 不支持的 Python 库？</h4>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>只有很少一部分本机 C python 模块以及本机 C python 模块的子集不受 Google App Engine 支持。详述了本机 C
Python 模块支持的完整列表可在[此处](<a href="http://code.google.com/intl/zh-">http://code.google.com/intl/zh-</a>
CN/appengine/kb/libraries.html)找到。被禁用的模块属于以下类别：</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ul>
<li>用于维护磁盘上数据存储区的库未在 Google App Engine 的 Python 中启用</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Google App Engine 禁用套接字</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>系统不允许您调用子进程，结果某些操作系统模块方法被禁用</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>线程不可用</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>由于安全方面的原因，大多数基于 C 的模块都被禁用</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>其他受限制的功能：</li>
</ul>
</blockquote>
<blockquote>
<pre><code>* 封送已禁用
</code></pre>
</blockquote>
<blockquote>
<pre><code>* cPickle 又名 pickle
</code></pre>
</blockquote>
<blockquote>
<pre><code>* 系统调用已禁用
</code></pre>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>请记住，使用以上任意一种功能的第三方包（如 mysql、postgresql 等）都将无法在 Google App Engine 上运行。</p>
</blockquote>
<p>根据Google App Engine的文档描述，在云计算提供的服务器集群中，无法提供套接字和多线程的使用，这也是可以
遇见的，毕竟这么多服务器集群如果要实现套接字和多线程的同步，几乎是不可能完成的任务。</p>
<h3 id="使用web-servicexml通信">使用Web Service/XML通信</h3>
<p>Flex对Web Service/XML提供了原生的支持，也支持RPC协议（[什么是RPC](<a href="http://zh.wikipedia.org/zh-">http://zh.wikipedia.org/zh-</a>
cn/RPC)），也可以使用一种AMF(Action Message Format)的一种二进制协议来交换数据。我查看了《Flex
3权威指南》的一些范例代码，实现这些协议需要的操作步骤略多，但是能支持复杂的对象传送。</p>
<p>考虑到我接触Python/Flex的时间和经验，这种方式显然风险很大，我只能略过这个方案。</p>
<h3 id="使用ajax-poiling方式通信">使用Ajax Poiling方式通信</h3>
<p>如果写过Ajax聊天室的童鞋们应该很轻松理解这种Poiling方式，即频繁的向服务器发送post请求（通常是1s），然后读取返回数据来进行数据交换。这种方式
适合数据格式简单的通信，不适宜大文件的传送。</p>
<p>这个方案简单易操作，加上我之前对Web前段也有一些学习，在技术上只要攻克Python/Flex难关，就有一定可行性了。</p>
<p>采用Ajax
Poiling方式完全是基于Http协议，这个GAE能够完美支持，Flex在<code>flash.net.*</code>下也有很多对应的方法进行操作，实现应该没有问题。</p>
<h2 id="数据库的实现">数据库的实现</h2>
<p>在系统的后期，如果时间充裕，会考虑加入数据库的支持，实现简单的注册/登录和聊天记录存储。</p>
<p>GAE支持的数据库是BigTable，使用一种GQL的操作语言，与普通的关系型数据库还是有一些区别。下面是wiki的介绍</p>
<blockquote>
<p>BigTable is a compressed, high performance, and proprietary database system
built on Google File System (GFS), Chubby Lock Service, and a few other Google
programs; it is currently not distributed or used outside of Google, although
Google offers access to it as part of their Google App Engine.</p>
</blockquote>
<p>直接加入BigTable支持我怕会导致整个项目拖延，所以如果顺利则加入数据库支持，如果不顺利则放到以后再实现。</p>
<h2 id="相关链接">相关链接</h2>
<p>PylexChat in Google Project Host:
<a href="http://code.google.com/p/pylexchat/">http://code.google.com/p/pylexchat/</a></p>
<p>PylexChat in GAE:
<a href="http://pylexchat.appspot.com/">http://pylexchat.appspot.com/</a></p>
<p>先给出上面的网址，还没彻底部署好。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Google App Engine搭建Twitter API Proxy教程</title>
      <link>https://blog.alswl.com/2009/10/google-app-engine-to-build-twitter-api-proxy-tutorial/</link>
      <pubDate>Wed, 14 Oct 2009 00:00:00 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2009/10/google-app-engine-to-build-twitter-api-proxy-tutorial/</guid>
      <description>来源：Google App Engine搭建Twitter API Proxy教程 alswl:今天我本来想使用GAppProxy搭建自己的[服务器](http://j asontiproxy.appspot.com/fetch)，不过失败了，似乎客户端有些问题，也可能是我配置的问题。之后就正好看到月光大大的这篇文章，欣喜之 极，搭建了自己的Twitter birdnest服务器，并转载之。 本文将介绍如何通过Google</description>
      <content:encoded><![CDATA[<p>来源：<a href="http://www.williamlong.info/archives/1956.html">Google App Engine搭建Twitter API Proxy教程</a></p>
<p>alswl:今天我本来想使用<a href="http://gappproxy.googlecode.com/">GAppProxy</a>搭建自己的[服务器](http://j
asontiproxy.appspot.com/fetch)，不过失败了，似乎客户端有些问题，也可能是我配置的问题。之后就正好看到月光大大的这篇文章，欣喜之
极，搭建了<a href="http://jasontitwitter.appspot.com/api/">自己的Twitter birdnest服务器</a>，并转载之。</p>
<p>本文将介绍如何通过Google App Engine搭建基于Python
2.5的BirdNest环境，建好的BirdNest可以在TwitterFox或twhirl中使用。</p>
<h3 id="环境准备google-app-engine">环境准备：Google App Engine</h3>
<p>先要<a href="http://www.williamlong.info/archives/1357.html">注册Google App Engine</a>，注册地址
<a href="http://appengine.google.com/">http://appengine.google.com/</a> ，然后建立一个applicatio
n，目前第一次使用需要验证用户手机，输入手机号码就收验证码即可，之后，就可以用yourid.appspot.com来访问你的app应用。</p>
<p>此外，还需要下载安装Google APP Engine的开发环境，注意Python的版本，需要是2.5系列的，不能使用2.6或更高的版本，否则运行会出错。</p>
<p>Google App Engine SDK 下载地址 [http://code.google.com/intl/zh-CN/appengine/downloads.html](<a href="http://code.google.com/intl/zh-">http://code.google.com/intl/zh-</a>
CN/appengine/downloads.html)</p>
<p>Python 2.5.4 下载地址 [http://www.python.org/download/releases/2.5.4/](http://www.
python.org/download/releases/2.5.4/)</p>
<p>关于Google App Engine的详细使用说明请参见[这个地址](<a href="http://www.williamlong.info/archives/1880">http://www.williamlong.info/archives/1880</a>.
html)，这里我就不再累赘。</p>
<h3 id="环境准备birdnest">环境准备：BirdNest</h3>
<p>下载birdnest要注意是下载[分支branches/gae](<a href="http://birdnest.googlecode.com/svn/branches/g">http://birdnest.googlecode.com/svn/branches/g</a>
ae)，别下载主干trunk，否则更新到GAE上也不能用，会报错。可以使用一个SVN工具下载。例如[TortoiseSVN](<a href="http://www.will">http://www.will</a>
iamlong.info/archives/1878.html)等。将其放到一个目录中，进入目录，编辑app.yaml文件，将第一行的application
里的参数修改为自己的应用名。（alswl:我使用Eclipse获取了SVN的内容）</p>
<h3 id="发布应用到gae">发布应用到GAE</h3>
<p>准备好了上面的一切后，就可以发布这个应用到自己的Appspot上了，执行 appcfg.py update
目录名，中间会要求输入Gmail的用户名和密码，之后就可以使用了。你创建的API地址应该是yourid.appspot.com/api/ 。</p>
<h3 id="使用birdnest">使用BirdNest</h3>
<p>在twhirl里的使用方法是，打开账号管理Accounts manager，选择laconi.ca账户类型，输入：[你的twitter帐号名]@yourid
.appspot.com，密码为Twitter密码，即可使用。（alswl:我使用的是twhirl，需要安装Adobe AIR环境）</p>
<p>在twitterfox里的使用方法是，打开 C:Documents and SettingsAdministratorApplication
DataMozillaFirefoxProfiles 随机信息
.defaultextensionstwitternotifier@naan.netcomponents目录，编辑
nsTwitterFox.js文件，找不到的话直接在Documents and
Settings中搜索nsTwitterFox.js文件，编辑该文件的38行，将其修改为 var TWITTER_API_URL =
<a href="http://yourid.appspot.com/api/">http://yourid.appspot.com/api/</a> 即可。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>GAE&#43;校内App初接触</title>
      <link>https://blog.alswl.com/2009/09/gae-initial-contact-with-the-school-app/</link>
      <pubDate>Mon, 28 Sep 2009 00:00:00 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2009/09/gae-initial-contact-with-the-school-app/</guid>
      <description>下午刚有了在Google App Engine上写校内（人人网）App的想法，下午就迫不及待的开始动手。下面我以一个简单的Hello World来介绍一个开发步骤。 1.创建GAE应用 建立一个Google App Engine空间，需要一个Google帐号，仅此而已。拥有帐号，进入 App Engine ，激活这个服务，就可以创建新的应用。如何创建不是我这里要讲的重点，现在GAE支持简体中文版本，应该没有任何问题。 一个简单的App控制台</description>
      <content:encoded><![CDATA[<p>下午刚有了在Google App Engine上写校内（人人网）App的想法，下午就迫不及待的开始动手。下面我以一个简单的Hello
World来介绍一个开发步骤。</p>
<h2 id="1创建gae应用">1.创建GAE应用</h2>
<p>建立一个Google App Engine空间，需要一个Google帐号，仅此而已。拥有帐号，进入 


<img loading="lazy" src="https://www.google.com/accounts/ah/ah20x20.gif" alt="App Engine"  />



 <a href="http://code.google.com/appengine/">App Engine</a> ，激活这个服务，就可以<a href="https://appengine.google.com/">创建新的应用</a>。如何创建不是我这里要讲的重点，现在GAE支持简体中文版本，应该没有任何问题。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/images/upload_dropbox/200909/image3.png" alt="image"  />


 一个简单的App控制台</p>
<h2 id="2部署gae-app">2.部署GAE App</h2>
<p>刚才建立的GAE App其实还是空的，如果访问xxx.appspot.com时候，你会发现什么都出不来（按理应该是404页面，但是由于连404页面都没有设置
，所以Nothing,检查http状态会发现返回的是404状态）。</p>
<p>这时候我们就要开始部署这个GAE App了：1.下载一个<a href="http://googleappengine.googlecode.com/files/GoogleAppEngine_1.2.5.msi">Google App Engine SDK for Python-Win</a>，这样就可以在本地测试项目，然后发布到
GAE。</p>
<p>用这个GAE Launcher在本地创建了一个Application，注意标识符和你网上申请的要一致。然后会自动生成一个包含&quot;」Hello
Word!「的main.py和app.yaml的文件夹。其中app.yaml的内容是用来配置项目的。</p>
<p>相关链接：<a href="http://code.google.com/intl/zh-CN/appengine/docs/python/config/appconfig.html">app.yaml的具体设置</a></p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/images/upload_dropbox/200909/xnapp_gae_launcher2.jpg" alt="xnapp_gae_launcher"  />



我创建了一个名为jasontidemo的App，并且启动服务器，可以进行浏览。</p>
<p>在一切没有问题之后，我们就可以惦记Deploy部署这个项目了，这时候要输入帐号和密码，然后出现console控制台等待信息。出现下面提示时候，就说明上传成功
了。</p>
<pre><code>Closing update: new version is ready to start serving.
Uploading index definitions.
Password for alswlwangzi@gmail.com: 2009-09-27 16:00:36 (Process exited with code 0)
</code></pre>
<p>这时候我们就可以打开xxx.appspot.com查看刚才部署的网站。</p>
<h2 id="3校内应用">3.校内应用</h2>
<p>拥有校内帐号，就可以创建校内应用。第一步是需要安装一个名为「<a href="http://app.renren.com/developers/home.do">开发者</a>」
的应用。通过这个应用，可以链接到其他一些有帮助的内容：<a href="http://wiki.dev.renren.com/wiki/">开放平台文档</a>、<a href="http://dev.renren.com/center/tools.do">测试工具</a>、<a href="http://group.renren.com/GetTribe.do?id=237768885">讨论区</a>。</p>
<p>第二步是创建一个新的应用，按部就班的填上相关资料。</p>
<p><a href="../../static/images/upload_dropbox/200909/image51.png">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/images/upload_dropbox/200909/image5.png" alt="image"  />


</a></p>
<p>校内开发者，右上角可以申请开发应用（看讨论区貌似童鞋们都不满意这个开发平台呢）</p>
<p><a href="../../static/images/upload_dropbox/200909/xnapp_main2.jpg">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/images/upload_dropbox/200909/xnapp_main.jpg" alt="xnapp_main"  />


</a></p>
<p>我的应用程序，在这里可以编辑应用的属性</p>
<p>创建之后，就可以填上Canvas的基本选项中的「应用展示地址」和「Canvas Callback
URL」，后者就是实际的地址，我们将填上刚才的xxx.appspot.com这种形式的网址。</p>
<p><a href="../../static/images/upload_dropbox/200909/xnapp_config2.jpg">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/images/upload_dropbox/200909/xnapp_config.jpg" alt="xnapp_config"  />


</a></p>
<p>最后测试自己的应用，也就是刚才「应用展示地址」，形式类似于apps.renren.com/xxx/，就可以看到我们的应用了，这时候基本框架就差不多了。</p>
<h2 id="4噩耗">4.噩耗</h2>
<p>此时当满天欢喜时候打开刚才的「应用展示地址」，你会惊奇的发现校内居然报错了，直接报了405错误。什么是405错误，就是服务器没有权限访问。</p>
<p>我花了一下午时间才解决这个问题，因为问题可能出在校内，也可能是GAE的功能限制上。</p>
<p>在appspot上测试这个应用是没有任何问题的</p>
<p><a href="../../static/images/upload_dropbox/200909/xnapp_show_ori1.jpg">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/images/upload_dropbox/200909/xnapp_show_ori.jpg" alt="xnapp_show_ori"  />


</a></p>
<p>显示的源码，其中的xnml校内服务器自己可以解析出来的，这段代码在校内测试工具也能通过</p>
<p>调试之后，终于把问题锁定在get
和post上，具体原因是因为校内发起请求GAE服务器用的是Post方法，而我们的main.py中目前只相应get方法，导致了校内请求GAE
Post方法，服务器没有这个方法调用，就返回了405错误。</p>
<p>修复这个问题只给main.py的MainHandler这个类加上post方法</p>
<pre><code>class MainHandler(webapp.RequestHandler):
</code></pre>
<p>def head(self, *args):</p>
<p>return self.get(*args)</p>
<p>def post(self):</p>
<p>self.response.out.write&rsquo;Hello world!')</p>
<h2 id="5结合">5.结合</h2>
<p>最后我加上一个简单的&lt;xn:profile-pic /&gt;来展示一下整个App</p>
<p>下面我发布我的这个简单的Hello World!（其实因为要使用XNML，所以已经不是单纯的打出Hello World了）</p>
<p>app.yaml：定义了main.py和404页面</p>
<pre><code>application: jasontidemo
version: 1
runtime: python
api_version: 1
</code></pre>
<p>handlers:</p>
<ul>
<li>
<p>url: /<br />
script: main.py</p>
</li>
<li>
<p>url: /index.html<br />
script: main.py</p>
</li>
<li>
<p>url: /.*<br />
script: not_found.py main.py：我把post 和get写的比较Dirty，其实可以封装在一个函数里的。</p>
<p>import wsgiref.handlers
from google.appengine.ext import webapp</p>
</li>
</ul>
<p>class MainHandler(webapp.RequestHandler):</p>
<p>def head(self, *args):</p>
<p>return self.get(*args)</p>
<p>def post(self):</p>
<p>self.response.out.write(&rsquo;&rsquo;&rsquo;<b>使用者的名称及其大中小三种头像：</b></p>
<div style="text-align: center;">
<p>图片：</p>
<p>&lt;xn:profile-pic uid=&ldquo;loggedinuser&rdquo; linked=&ldquo;true&rdquo; size=&ldquo;tiny&rdquo;/&gt;</p>
<p>&lt;xn:profile-pic uid=&ldquo;loggedinuser&rdquo; linked=&ldquo;true&rdquo; size=&ldquo;normal&rdquo;/&gt;</p>
<p>&lt;xn:profile-pic uid=&ldquo;loggedinuser&rdquo; linked=&ldquo;true&rdquo; size=&ldquo;main&rdquo;/&gt;</p>
<br />
<p>姓名：</p>
<p>&lt;xn:name uid=&ldquo;loggedinuser&rdquo; linked=&ldquo;true&rdquo; shownetwork=&ldquo;true&rdquo; /&gt;</p>
</div>''')
<p>def get(self):</p>
<p>self.response.out.write(&rsquo;&rsquo;&rsquo;<b>使用者的名称及其大中小三种头像：</b></p>
<div style="text-align: center;">
<p>图片：</p>
<p>&lt;xn:profile-pic uid=&ldquo;loggedinuser&rdquo; linked=&ldquo;true&rdquo; size=&ldquo;tiny&rdquo;/&gt;</p>
<p>&lt;xn:profile-pic uid=&ldquo;loggedinuser&rdquo; linked=&ldquo;true&rdquo; size=&ldquo;normal&rdquo;/&gt;</p>
<p>&lt;xn:profile-pic uid=&ldquo;loggedinuser&rdquo; linked=&ldquo;true&rdquo; size=&ldquo;main&rdquo;/&gt;</p>
<br />
<p>姓名：</p>
<p>&lt;xn:name uid=&ldquo;loggedinuser&rdquo; linked=&ldquo;true&rdquo; shownetwork=&ldquo;true&rdquo; /&gt;</p>
</div>''')
<p>def main():</p>
<p>application = webapp.WSGIApplication([(&rsquo;/.*&rsquo;, MainHandler)], debug=True)</p>
<p>wsgiref.handlers.CGIHandler().run(application)</p>
<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>
<p>main() not_found.py：自定义的404页面，其实就是简单的在MainHandler里面的get加入简单的文本。</p>
<pre><code>  def get(self):
    self.response.out.write('404 Not Found')
</code></pre>
<p>把这个GAE App部署，然后就可以在校内的apps.renren.com/xxx/使用这个应用了。</p>
<p><a href="../../static/images/upload_dropbox/200909/xnapp_show1.jpg">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/images/upload_dropbox/200909/xnapp_show.jpg" alt="xnapp_show"  />


</a></p>
<p>我的头像，按理应该有三个，我怀疑是校内的一个服务器出问题了，只刷出来两张。</p>
<p><a href="../../static/images/upload_dropbox/200909/xnapp_sidebar1.jpg">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/images/upload_dropbox/200909/xnapp_sidebar.jpg" alt="xnapp_sidebar"  />


</a></p>
<p>可以收藏这个应用，看到侧边栏的海绵宝宝了么？呵呵</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>当Google APP Engine遇上校内</title>
      <link>https://blog.alswl.com/2009/09/when-google-app-engine-encounter-campus/</link>
      <pubDate>Sun, 27 Sep 2009 00:00:00 +0800</pubDate>
      
      <guid>https://blog.alswl.com/2009/09/when-google-app-engine-encounter-campus/</guid>
      <description>昨天看《程序员》时候看到一篇讲开放接口的文章，是FaceBook的一个开发人员写的，讲了很多关于开放平台的东西 。其中提到Google App Engine的云计算支持，FaceBook的FBML（校内的称为XNML，一种标记性语言）。 Google App Engine(GAE) Google App Engine让用户可以在 Google 的基础架构上运行的网络应用程序。Google App Engine 应用程序易于构建和维护，并可根据用户的访问量和数据存储需要的增长轻松扩展。使用 Google App Engi</description>
      <content:encoded><![CDATA[<p>昨天看《<a href="http://www.csdn.net">程序员</a>》时候看到一篇讲开放接口的文章，是FaceBook的一个开发人员写的，讲了很多关于开放平台的东西
。其中提到Google App Engine的云计算支持，FaceBook的FBML（校内的称为XNML，一种标记性语言）。</p>
<h2 id="google-app-enginegae">Google App Engine(GAE)</h2>
<p>Google App Engine让用户可以在 Google 的基础架构上运行的网络应用程序。Google App Engine
应用程序易于构建和维护，并可根据用户的访问量和数据存储需要的增长轻松扩展。使用 Google App
Engine，将不再需要维护服务器：用户只需上传用户的应用程序，它便可立即为用户的用户提供服务。</p>
<p>通俗的说，App Engine就像是免费提供的一个500M高性能的空间，和一个appspot.com二级域名。在Google强大的云计算能力下，服务器的速度
和质量毋容置疑。现在App Engine支持Python和Java（似乎Java有些限制，具体的细节我没有看）。</p>
<h2 id="xnml">XNML</h2>
<p>XNML（xiao nei market
language）是以种标记性语言，如果学过JavaEE，就会发现它和OGNL语言很像。XNML大概的形式是&lt;xnml:iframe
….&gt;这种形式，校内服务器会负责解析这种格式的语法生成相应的内容。其实这是把一些功能性内容封装成接口，为了安全和方便。</p>
<p>在校内提供的开发平台写应用需要自己的一个地址，肯定不能是192.168.0.X这种本机地址了。这时候Google App
Engine就派上了大用场，把应用的文件和数据存储在GAE里，那是相当的爽，可以放心的开发自己的第三方应用了。</p>
<p>我一直对开放平台的开发有兴趣，现在有了GAE这个利器，正好写一个自己的小应用玩玩，顺便练习练习自己的Python。</p>
<h2 id="相关链接">相关链接：</h2>
<p>校内开发者（校内开发人员必须安装的应用）：<a href="http://app.renren.com/developers/home.do">http://app.renren.com/developers/home.do</a></p>
<p>校内开放平台文档：<a href="http://wiki.dev.renren.com/wiki/%E9%A6%96%E9%A1%B5">http://wiki.dev.renren.com/wiki/%E9%A6%96%E9%A1%B5</a></p>
<p>Google App Engine相关下载：<a href="http://code.google.com/appengine/downloads.html">http://code.google.com/appengine/downloads.html</a></p>
<p>Google App Engine SDK for Python-Win：<a href="http://googleappengine.googlecode.com/files/GoogleAppEngine_1.2.5.msi">GoogleAppEngine_1.2.5.msi</a></p>
<p>Google App Engine SDK for Java：<a href="http://googleappengine.googlecode.com/files/appengine-java-sdk-1.2.5.zip">appengine-java- sdk-1.2.5.zip</a></p>
<p>Google App Engine Documentation：<a href="http://googleappengine.googlecode.com/files/google-appengine-docs-20090921.zip">google-appengine-docs-20090921.zip</a></p>
<p>最后一个小图标：


<img loading="lazy" src="http://code.google.com/appengine/images/appengine-silver-120x30.gif" alt="Powered by Google App Engine"  />



，呵呵，Google的图标都那么帅</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
