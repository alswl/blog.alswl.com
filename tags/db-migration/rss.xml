<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Db-Migration on Log4D</title>
    <link>https://blog.alswl.com/tags/db-migration/</link>
    <description>Recent content in Db-Migration on Log4D</description>
    <generator>Hugo -- 0.125.3</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 20 Jun 2018 20:18:52 +0800</lastBuildDate>
    <atom:link href="https://blog.alswl.com/tags/db-migration/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量</title>
      <link>https://blog.alswl.com/2018/06/sql-server-migration-3/</link>
      <pubDate>Wed, 20 Jun 2018 20:18:52 +0800</pubDate>
      <guid>https://blog.alswl.com/2018/06/sql-server-migration-3/</guid>
      <description>该系列三篇文章已经全部完成： 从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D 从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D 我们用了两章文章 从 SQL Server 到 MySQL（一）：异构数据库迁移 / 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 介绍我们遇到问题和解决方案。 不管是离线全量迁移还是在线无缝迁移， 核心 ETL 工具就是 yugong。 Yugong 是一个成熟工具， 在阿里巴巴去</description>
      <content:encoded><![CDATA[<p>该系列三篇文章已经全部完成：</p>
<ul>
<li><a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/06/sql-server-migration-3/">从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D</a></li>
</ul>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/refactor.png" alt="201806/refactor.png"  />


</p>
<p>我们用了两章文章
<a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL（一）：异构数据库迁移</a>
/
<a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机</a>
介绍我们遇到问题和解决方案。
不管是离线全量迁移还是在线无缝迁移，
核心 ETL 工具就是 yugong。</p>
<p>Yugong 是一个成熟工具， 在阿里巴巴去 IOE 行动中起了重要作用，
它与 Otter / Canal 都是阿里中间件团队出品。
它们三者各有分工：
Yugong 设计目标是异构数据库迁移；
Canal 设计用来解决 MySQL binlog 订阅和消费问题；
Otter 则是在 Canal 之上，以准实时标准解决数据库同步问题。
Otter 配备了相对 yugong 更健壮管理工具、分布式协调工具，
从而长期稳定运行。Yugong 设计目标则是一次性迁移工作，偏 Job 类型。
当然 yugong 本身质量不错，长期运行也没问题。
我们有个产线小伙伴使用我们魔改后 yugong，
用来将数据从管理平台同步数据到用户前台，已经稳定跑了半年多了。</p>
<!-- more -->
<h2 id="yugong-系统结构">yugong 系统结构</h2>
<p>这里我不赘述如何使用 yugong，有需求同学直接去
<a href="https://github.com/alibaba/yugong">官方文档</a> 查看使用文档。</p>
<p>我直接进入关键环节：解剖 yugong 核心模块。
Yugong 数据流是标准 ETL 流程，分别有 Extractor / Translator / Applier
这三个大类来实现 ETL 过程:</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/etl.png" alt="ETL &amp;amp; Java Class"  />


</p>
<p>我们依次来看看这三大类具体设计。</p>
<h3 id="extractor">Extractor</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/extractor.png" alt="Extractor Class"  />


</p>
<ul>
<li><code>YuGongLifeCycle</code>：Yugong 组件生命周期声明</li>
<li><code>AbstractYuGongLifeCycle</code>：Yugong 组件生命周期一些实现</li>
<li><code>RecordExtractor</code>：基础 Extractor Interface</li>
<li><code>AbstractRecordExtractor</code>：基础 Extractor 虚拟类，做了一部分实现</li>
<li><code>AbstractOracleRecordExtractor</code>：Oracle Extractor 虚拟类，做了一部分 Oracle 相关实现</li>
<li><code>OracleOnceFullRecordExtractor</code>：Oracle 基于特定 SQL 一次性 Extractor</li>
<li><code>OracleFullRecordExtractor</code>：Oracle 全量 Extractor</li>
<li><code>OracleRecRecordExtractor</code>：Oracle 记录 Extractor，用来创建物化视图</li>
<li><code>OracleMaterializedIncRecordExtractor</code>：基于（已有）物化视图 Oracle 增量 Extrator</li>
<li><code>OracleAllRecordExtractor</code>：Oracle 自动化 Extractor，先 Mark 再 Full，再 Inc</li>
</ul>
<p>Exctractor 从 Source DB 读取数据写入内存，
Yugong 官方提供 Extractor 抽象出 <code>AbstractRecordExtractor</code> 类，
其余类都是围绕 Oracle 实现。
另外 Yugong 设计了 <code>YuGongLifeCycle</code> 类实现了组件生命周期管理。</p>
<h3 id="translator">Translator</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/translator.png" alt="Translator Class"  />


</p>
<ul>
<li><code>DataTranslator</code>：Translator 基类，为 Row 级别数据处理</li>
<li><code>TableTranslator</code>：Translator 基类，为 Table 级别提供处理（官方代码中没有使用）</li>
<li><code>AbstractDataTranslator</code>：Data Translator 虚拟类，做了部分实现</li>
<li><code>EncodeDataTranslator</code>：转换编码格式 Translator</li>
<li><code>OracleIncreamentDataTranslator</code>：为 Oracle 增量数据准备 Translator，会调整一些数据状态</li>
<li><code>BackTableDataTranslator</code>：Demo，允许在 Translator 中做回写数据操作</li>
<li><code>BillOutDataTranslator</code>：Demo，包含一些阿里业务逻辑 Translator</li>
<li><code>MidBillOutDetailDataTranslator</code>：Demo，包含一些阿里业务逻辑 Translator</li>
</ul>
<p>Translator 读取内存中 RowData 然后变换，
大部分 Translator 做一些无状态操作，比如编码转换。
另外还有一小部分 Translator 做了业务逻辑操作，比如做一些数据回写。</p>
<h3 id="applier">Applier</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/applier.png" alt="Applier Class"  />


</p>
<ul>
<li><code>RecordApplier</code>：基础 Applier Interface</li>
<li><code>AbstractRecordApplier</code>：基础 Applier 虚拟类，做了一部分实现</li>
<li><code>CheckRecordRecordApplier</code>：检查数据一致性 Applier，不做数据写入</li>
<li><code>FullRecordRecordApplier</code>：全量数据 Applier，使用 UPSERT 做数据更新</li>
<li><code>IncreamentRecordApplier</code>：增量 Applier，使用 Oracle 物化视图为数据源</li>
<li><code>AllRecordRecordApplier</code>：自动化 Applier，先使用全量数据 Applier，然后使用增量数据 Applier</li>
</ul>
<p>Applier 将经过 Translator 处理过的数据写入 Target DB。
Yugong 提供了一致性检查、全量、增量 Applier。
比较特殊是 <code>AllRecordRecordApplier</code> 提供了全套自动化操作。</p>
<h3 id="others">Others</h3>
<p>除了 ETL 三个要素，yugong 还有一些重要类：控制类和工具类。</p>
<ul>
<li><code>SqlTemplate</code>：提供 CRUD / UPSERT 等操作的基类 SQL 模板</li>
<li><code>OracleSqlTemplate</code>：基于 SqlTemplate 实现的 Oracle SQL 模板</li>
<li><code>RecordDiffer</code>：一致性检查 differ</li>
<li><code>YugongController</code>：应用控制器，控制整个应用数据流向</li>
<li><code>YugongInstance</code>：控制单个迁移任务实例，一张表对应一个 YugongInstance</li>
</ul>
<h2 id="老战士的问题">老战士的问题</h2>
<p>说 yugong 有问题会有些标题党，毕竟它是久经考验老战士了。
但对我们来说，开源版本 yugong 还有一些不足：</p>
<ul>
<li>不支持 SQL Server 读取</li>
<li>不支持 SQL Server 写入（Rollback 需要写入 SQL Server）</li>
<li>不支持 MySQL 读取</li>
</ul>
<p>除了数据库支持，Yugong 在工程上面倒是也有一些改善空间。
我们最后花费了不少时间，做了工程上改进。</p>
<ul>
<li>抛弃默认打包方式（基于 maven-assembly-plugin 生成类似 LFS 结构 tar.gz 文件），
改为使用 fat jar 模式打包，仅生成单文件可执行 jar 包</li>
<li>抛弃 ini 配置文件，使用 YAML 配置文件格式（已有老配置仍然使用 ini 文件，YAML 主要管理表结构变更）</li>
<li>改造 Plugin 模式，将 Java 运行时编译改为反射获取 Java 类</li>
<li>拆分 Unit Test / Integration Test，降低重构成本</li>
<li>重构 Oracle 继承结构，使其开放 SQL Server / MySQL 接口</li>
<li>支持 Canal Redis 格式数据作为 MySQL 在线增量数据源</li>
</ul>
<h2 id="改造之后结构">改造之后结构</h2>
<h3 id="extractor-1">Extractor</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/extractor-new.png" alt="Extractor New Class"  />


</p>
<ul>
<li><code>AbstractSqlServerExtractor</code>：新增抽象 SqlServer Extractor</li>
<li><code>AbstractMysqlExtractor</code>：新增抽象 MySQL Extractor</li>
<li><code>AbstractFullRecordExtractor</code>：新增抽象 Full 模式 Extractor</li>
<li><code>SqlServerCdcExtractor</code>：新增 SQL Server CDC 增量模式 Extractor</li>
<li><code>MysqlCanalExtractor</code>：新增 MySQL Canal 格式增量消费 Extractor</li>
<li><code>MysqlCanalRedisExtractor</code>：新增 MySQL Canal 格式增量消费 Extractor，使用 Redis 做回溯</li>
<li><code>MysqlFullExtractor</code>：新增 MySQL 全量 Extractor</li>
<li><code>SqlServerFullExtractor</code>：新增 SQL Server 全量 Extractor</li>
</ul>
<p>在抽象出三个抽象类之后，整体逻辑更为清晰，如果未来要增加新数据库格式支持，也更为简单。</p>
<h3 id="translator-1">Translator</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/translator-new.png" alt="Translator New Class"  />


</p>
<ul>
<li><code>Sha1ShardingTranslator</code>：根据 Sha1 Sharding Translator</li>
<li><code>ModShardingTranslator</code>：根据 Value Mode Sharding Translator</li>
<li><code>RangeShardingTranslator</code>：根据范围 Sharding Translator</li>
<li><code>UserRouterMapShardingTranslator</code>：特定业务使用， 用户分表 Sharding Translator</li>
<li><code>UserRouterMapMobileShardingTranslator</code>：特定业务使用， 用户分表 Sharding Translator</li>
<li><code>ClassLearningNoteInfoShardingTranslator</code>：特定业务使用自定义 Translator</li>
<li><code>ClassLearningIsActiveReverseShardingTranslator</code>：特定业务使用自定义 Translator</li>
<li><code>ColumnFixDataTranslator</code>：调整表结构 Translator</li>
<li><code>NameStyleDataTranslator</code>：调整表字段名 Translator，支持按风格对整个表自动转换</li>
<li><code>CompositeIndexesDataTranslator</code>：解决复合主键下唯一 PK 确定问题的 Translator</li>
</ul>
<p>新增了一系列 Translator。</p>
<h3 id="applier-1">Applier</h3>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201806/applier-new.png" alt="Applier New Class"  />


</p>
<ul>
<li><code>SqlServerIncreamentRecordApplier</code>：新增 SQL Server 增量消费 Applier</li>
</ul>
<p>Applier 结构调整挺小，主要是增加了 SQL Server 的支持。</p>
<h2 id="二次开发心得">二次开发心得</h2>
<p>如何快速了解一个开源项目？很多同学第一反应就是阅读源码。
看源码固然是有效果，但是性价比太低。
如果项目设计不合理，很快会迷失在代码细节之中。
我的经验是先阅读官方出品的一些 Slide 分享，然后阅读官方核心文档。
Slide 含金量高，在讲述核心中核心。</p>
<p>如果真要去了解细节去阅读源码，那我建议要善用工具，
比如使用 IntelliJ 的 Diagram 功能，抽象出核心类。
还有一些插件比如 SequencePluginReload 方便地生成函数之间调用，实为查看数据流利器。
我在这次开发过程中，也根据生成类图发现了一些问题，
从而在进入 Coding 之前，先对框架继承结构重构。提高了整体开发效率</p>
<p>根据代码风格判断，Yugong 并非是出自一个人之手。这多少会导致代码风格和设计上面不一致。
我自己也常年在业务线里面摸爬滚打，能想象到在快速推进项目中需要糙快猛。
但后人接受开发，多少会有些头疼。
于是我在进入开发之前，引入标准化 CheckStyle，用 Google Style 全局格式化，
使用 Sonar 扫描保证一个代码质量基线。
同时这也是一把双刃剑，格式化项目会导致大量 diff，
这也给我自己埋下了一个苦果，在后期给上游提交 PR 引入无尽问题。</p>
<p>开发过程中我也犯了一些错误。最为头疼是没有在早期考虑到向开源社区贡献，
导致未来向上游合并困难重重，现在还在头疼合并代码中。
另外，由于整体项目时间紧，我贪图实现速度，没有做更详尽单元测试覆盖。
这里没有遵循开源软件的最佳实践。</p>
<p>经过我改造的 Yugong 版本开源地址是：https://github.com/alswl/yugong 。
我也提交了 Pull Request <a href="https://github.com/alibaba/yugong/pull/66">https://github.com/alibaba/yugong/pull/66</a> ，
正在与官方沟通如何将这部分提交并入上游。</p>
]]></content:encoded>
    </item>
    <item>
      <title>从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机</title>
      <link>https://blog.alswl.com/2018/05/sql-server-migration-2/</link>
      <pubDate>Mon, 21 May 2018 11:24:36 +0800</pubDate>
      <guid>https://blog.alswl.com/2018/05/sql-server-migration-2/</guid>
      <description>该系列三篇文章已经全部完成： 从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D 从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D （image via https://pixabay.com/en/military-stealth-bomber-refueling-602729/ ） 在上篇文章 从 SQL Server 到 MySQL （一）：异构数据库迁移 - Log4D 中，我们给大家介绍了从 SQL Server 到 MySQL 异构数据库迁移的基本问题和全量解决方案。 全量方案可以满足一部分场景的需求，但是这个方案仍然是有缺陷的： 迁移过程中需要停机，停机的时长和</description>
      <content:encoded><![CDATA[<p>该系列三篇文章已经全部完成：</p>
<ul>
<li><a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/06/sql-server-migration-3/">从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D</a></li>
</ul>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/flying-tanker.png" alt="flying-tanker"  />


</p>
<p><smaill>（image via <a href="https://pixabay.com/en/military-stealth-bomber-refueling-602729/">https://pixabay.com/en/military-stealth-bomber-refueling-602729/</a> ）</small></p>
<p>在上篇文章
<a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL （一）：异构数据库迁移 - Log4D</a>
中，我们给大家介绍了从 SQL Server 到 MySQL 异构数据库迁移的基本问题和全量解决方案。
全量方案可以满足一部分场景的需求，但是这个方案仍然是有缺陷的：
迁移过程中需要停机，停机的时长和数据量相关。
对于核心业务来说，停机就意味着损失。
比如用户中心的服务，以它的数据量来使用全量方案，会导致迁移过程中停机若干个小时。
而一旦用户中心停止服务，几乎所有依赖于这个中央服务的系统都会停摆。</p>
<p>能不能做到无缝的在线迁移呢？系统不需要或者只需要极短暂的停机？
作为有追求的技术人，我们一定要想办法解决上面的问题。</p>
<!-- more -->
<h2 id="在线迁移的原理和流程">在线迁移的原理和流程</h2>
<p>针对 Oracle 到 MySQL，市面上已经有比较成熟的解决方案 - alibaba 的
<a href="https://github.com/alibaba/yugong">yugong</a>
项目。
在解决 SQL Server 到 MySQL 在线迁移之前，我们先研究一下 yugong 是如何做到 Oracle
的在线迁移。</p>
<p>下图是 yugong 针对 Oracle 到 MySQL 的增量迁移流程：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/yugong-oracle.png" alt="yugong-oracle.png"  />


</p>
<p>这其中有四个步骤：</p>
<ol>
<li>增量数据收集 (创建 Oracle 表的增量物化视图)</li>
<li>进行全量复制</li>
<li>进行增量复制 (可并行进行数据校验)</li>
<li>原库停写，切到新库</li>
</ol>
<p>Oracle 物化视图（Materialized View）是 Oracle 提供的一个机制。
一个物化视图就是主库在某一个时间点上的复制，可以理解为是这个时间点上的 Snapshot。
当主库的数据持续更新时，物化视图的更新可以通过独立的批量更新完成，称之为 <code>refreshes</code>。
一批 <code>refreshes</code> 之间的变化，就对应到数据库的内容变化情况。
物化视图经常用来将主库的数据复制到从库，也常常在数据仓库用来缓存复杂查询。</p>
<p>物化视图有多种配置方式，这里比较关心刷新方式和刷新时间。
刷新方式有三种：</p>
<ul>
<li>Complete Refresh：删除所有数据记录重新生成物化视图</li>
<li>Fast Refresh：增量刷新</li>
<li>Force Refresh：根据条件判断使用 Complete Refresh 和 Fast Refres</li>
</ul>
<p>刷新机制有两种模式： Refresh-on-commit 和 Refresh-On-Demand。</p>
<p>Oracle 基于物化视图，就可以完成增量数据的获取，从而满足阿里的数据在线迁移。
将这个技术问题泛化一下，想做到在线增量迁移需要有哪些特性？
我们得到如下结论（针对源数据库）：</p>
<ul>
<li>增量变化：支持增量获得增量数据库变化</li>
<li>延迟：获取变化数据这个动作耗时需要尽可能低</li>
<li>幂等一致性：变化数据的消费应当做到幂等，即不管目标数据库已有数据什么状态，都可以无差别消费</li>
</ul>
<p>回到我们面临的问题上来，SQL Server 是否有这个机制满足这三个特性呢？
答案是肯定的，SQL Server 官方提供了 CDC 功能。</p>
<h2 id="cdc-的工作原理">CDC 的工作原理</h2>
<p>什么是 CDC？
CDC 全称 Change Data Capture，设计目的就是用来解决增量数据的。
它是 SQL Server 2008 新增的特性，
在这之前只能使用 SQl Server 2005 中的 <code>after insert</code> / <code>after delete</code>
/ <code>after update</code> Trigger 功能来获得数据变化。</p>
<p>CDC 的工作原理如下：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/cdc-data-flow.png" alt="cdc-data-flow.png"  />


</p>
<p>当数据库表发生变化时候，Capture process 会从 transaction log 里面获取数据变化，
然后将这些数据记录到 Change Table 里面。
有了这些数据，用户可以通过特定的 CDC 查询函数将这些变化数据查出来。</p>
<h2 id="cdc-的数据结构和基本使用">CDC 的数据结构和基本使用</h2>
<p>CDC 的核心数据就是那些 Change Table 了，这里我们给大家看一下
Change Table 长什么样，可以有个直观的认识。</p>
<p>通过以下的函数打开一张表（fruits）的 CDC 功能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- enable cdc for db
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">sys</span><span class="p">.</span><span class="n">sp_cdc_enable_db</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- enable by table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">EXEC</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">sp_cdc_enable_table</span><span class="w"> </span><span class="o">@</span><span class="n">source_schema</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="s1">&#39;dbo&#39;</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">source_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="s1">&#39;fruits&#39;</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">role_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">NULL</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- list cdc enabled table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">is_cdc_enabled</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">databases</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">is_cdc_enabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>至此 CDC 功能已经开启，如果需要查看哪些表开启了 CDC 功能，可以使用一下 SQL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- list cdc enabled table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">is_cdc_enabled</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">databases</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">is_cdc_enabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>开启 CDC 会导致产生一张 Change Table 表 <code>cdc.dbo_fruits_CT</code>，这张表的表结构如何呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="p">.</span><span class="k">schema</span><span class="w"> </span><span class="n">cdc</span><span class="p">.</span><span class="n">dbo_fruits_CT</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">name</span><span class="w">            </span><span class="k">default</span><span class="w">  </span><span class="k">nullable</span><span class="w">  </span><span class="k">type</span><span class="w">          </span><span class="k">length</span><span class="w">  </span><span class="n">indexed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">--------------  -------  --------  ------------  ------  -------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__$end_lsn</span><span class="w">      </span><span class="k">null</span><span class="w">     </span><span class="n">YES</span><span class="w">       </span><span class="nb">binary</span><span class="w">        </span><span class="mi">10</span><span class="w">      </span><span class="k">NO</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">__$operation</span><span class="w">    </span><span class="k">null</span><span class="w">     </span><span class="k">NO</span><span class="w">        </span><span class="nb">int</span><span class="w">           </span><span class="mi">4</span><span class="w">       </span><span class="k">NO</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">__$seqval</span><span class="w">       </span><span class="k">null</span><span class="w">     </span><span class="k">NO</span><span class="w">        </span><span class="nb">binary</span><span class="w">        </span><span class="mi">10</span><span class="w">      </span><span class="k">NO</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">__$start_lsn</span><span class="w">    </span><span class="k">null</span><span class="w">     </span><span class="k">NO</span><span class="w">        </span><span class="nb">binary</span><span class="w">        </span><span class="mi">10</span><span class="w">      </span><span class="n">YES</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">__$update_mask</span><span class="w">  </span><span class="k">null</span><span class="w">     </span><span class="n">YES</span><span class="w">       </span><span class="n">varbinary</span><span class="w">     </span><span class="mi">128</span><span class="w">     </span><span class="k">NO</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">id</span><span class="w">              </span><span class="k">null</span><span class="w">     </span><span class="n">YES</span><span class="w">       </span><span class="nb">int</span><span class="w">           </span><span class="mi">4</span><span class="w">       </span><span class="k">NO</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">name</span><span class="w">            </span><span class="k">null</span><span class="w">     </span><span class="n">YES</span><span class="w">       </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span><span class="w">  </span><span class="mi">255</span><span class="w">     </span><span class="k">NO</span><span class="w">
</span></span></span></code></pre></div><p>这张表中以 <code>__</code> 开头的字段是 CDC 所记录的元数据，<code>id</code> 和 <code>name</code> 是 fruits 表的原始字段。
这意味着 CDC 的表结构和原始表结构是一一对应的。</p>
<p>接下来我们做一些业务操作，让数据库的数据发生一些变化，然后查看 CDC 的 Change Table：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 1 step
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DECLARE</span><span class="w"> </span><span class="o">@</span><span class="n">begin_time</span><span class="w"> </span><span class="n">datetime</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">end_time</span><span class="w"> </span><span class="n">datetime</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">begin_lsn</span><span class="w"> </span><span class="nb">binary</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="o">@</span><span class="n">end_lsn</span><span class="w"> </span><span class="nb">binary</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 2 step
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SET</span><span class="w"> </span><span class="o">@</span><span class="n">begin_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2017-09-11 14:03:00.000&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="o">@</span><span class="n">end_time</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2017-09-11 14:10:00.000&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 3 step
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">@</span><span class="n">begin_lsn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">fn_cdc_map_time_to_lsn</span><span class="p">(</span><span class="s1">&#39;smallest greater than&#39;</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">begin_time</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">@</span><span class="n">end_lsn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">fn_cdc_map_time_to_lsn</span><span class="p">(</span><span class="s1">&#39;largest less than or equal&#39;</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">end_time</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 4 step
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">cdc</span><span class="p">.</span><span class="n">fn_cdc_get_all_changes_dbo_fruits</span><span class="p">(</span><span class="o">@</span><span class="n">begin_lsn</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">end_lsn</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;all&#39;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>这里的操作含义是：</p>
<ol>
<li>定义存储过程中需要使用的 4 个变量</li>
<li>begin_time / end_time 是 Human Readable 的字符串格式时间</li>
<li>begin_lsn / end_lsn 是通过 CDC 函数转化过的 Log Sequence Number，代表数据库变更的唯一操作 ID</li>
<li>根据 begin_lsn / end_lsn 查询到 CDC 变化数据</li>
</ol>
<p>查询出来的数据如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="n">__$start_lsn</span><span class="w">          </span><span class="n">__$end_lsn</span><span class="w">  </span><span class="n">__$seqval</span><span class="w">             </span><span class="n">__$operation</span><span class="w">  </span><span class="n">__$update_mask</span><span class="w">  </span><span class="n">id</span><span class="w">  </span><span class="n">name</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">--------------------  ----------  --------------------  ------------  --------------  --  ------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">0000</span><span class="n">dede0000019f001a</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede0000019f0018</span><span class="w">  </span><span class="mi">2</span><span class="w">             </span><span class="mi">03</span><span class="w">              </span><span class="mi">1</span><span class="w">   </span><span class="n">apple</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">0000</span><span class="n">dede000001ad0004</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede000001ad0003</span><span class="w">  </span><span class="mi">2</span><span class="w">             </span><span class="mi">03</span><span class="w">              </span><span class="mi">2</span><span class="w">   </span><span class="n">apple2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">0000</span><span class="n">dede000001ba0003</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede000001ba0002</span><span class="w">  </span><span class="mi">3</span><span class="w">             </span><span class="mi">02</span><span class="w">              </span><span class="mi">2</span><span class="w">   </span><span class="n">apple2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">0000</span><span class="n">dede000001ba0003</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede000001ba0002</span><span class="w">  </span><span class="mi">4</span><span class="w">             </span><span class="mi">02</span><span class="w">              </span><span class="mi">2</span><span class="w">   </span><span class="n">apple3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">0000</span><span class="n">dede000001c10003</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede000001c10002</span><span class="w">  </span><span class="mi">2</span><span class="w">             </span><span class="mi">03</span><span class="w">              </span><span class="mi">3</span><span class="w">   </span><span class="n">apple4</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="mi">0000</span><span class="n">dede000001cc0005</span><span class="w">  </span><span class="k">null</span><span class="w">        </span><span class="mi">0000</span><span class="n">dede000001cc0002</span><span class="w">  </span><span class="mi">1</span><span class="w">             </span><span class="mi">03</span><span class="w">              </span><span class="mi">3</span><span class="w">   </span><span class="n">apple4</span><span class="w">
</span></span></span></code></pre></div><p>可以看到 Change Table 已经如实的记录了我们操作内容，注意 <code>__$operation</code>
代表了数据库操作：</p>
<ul>
<li>1 =&gt; 删除</li>
<li>2 =&gt; 插入</li>
<li>3 =&gt; 更新前数据</li>
<li>4 =&gt; 更新后数据</li>
</ul>
<p>根据查出来的数据，我们可以重现这段时间数据库的操作：</p>
<ul>
<li>新增了 <code>id</code> 为 1 / 2 的两条数据</li>
<li>更新了 <code>id</code> 为 2 的数据</li>
<li>插入了 <code>id</code> 为 3 的数据</li>
<li>删除了 <code>id</code> 为 3 的数据</li>
</ul>
<h2 id="cdc-调优">CDC 调优</h2>
<p>有了 CDC 这个利器，终于意味着我们的方向是没有问题的，我们终于稍稍吁了一口气。
但除了了解原理和使用方式，我们还需要深入了解 CDC 的工作机制，对其进行压测、调优，
了解其极限和边界，否则一旦线上出现不可控的情况，就会对业务带来巨大损失。</p>
<p>我们先看看 CDC 的工作流程，就可以知道有哪些核心参数可以调整：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/cdc-influence.png" alt="Influence of capture job parameters"  />


</p>
<p>上图是 CDC Job 的工作流程：</p>
<ul>
<li>蓝色区域是一次 Log 扫描执行的最大扫描次数：maxscans number（<code>maxscans</code>）</li>
<li>蓝色区域同时被最大扫描 transcation 数量控制：<code>maxtrans</code></li>
<li>浅蓝色区域是扫描间隔时间，单位是秒：<code>pollinginterval</code></li>
</ul>
<p>这三个参数平衡着 CDC 的服务器资源消耗、吞吐量和延迟，
根据具体场景，比如大字段，宽表，BLOB 表，可以调整从而达到满足业务需要。
他们的默认值如下：</p>
<ul>
<li><code>maxscan</code> 默认值 10</li>
<li><code>maxtrans</code> 默认值 500</li>
<li><code>pollinginterval</code> 默认值 5 秒</li>
</ul>
<h2 id="cdc-压测">CDC 压测</h2>
<p>掌握了能够调整的核心参数，我们即将对 CDC 进行了多种形式的测试。
在压测之前，我们还需要确定关键的健康指标，这些指标有：</p>
<ul>
<li>内存：buffer-cache-hit / page-life-expectancy / page-split 等</li>
<li>吞吐：batch-requets / sql-compilations / sql-re-compilations / transactions count</li>
<li>资源消耗：user-connections / processes-blocked / lock-waits / checkpoint-pages</li>
<li>操作系统层面：CPU 利用率、磁盘 IO</li>
</ul>
<p>出于篇幅考虑，我们无法将所有测试结果贴出来，
这里放一个在并发 30 下面插入一百万数据（随机数据）进行展示：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/cdc-metrics.png" alt="cdc-metrics.png"  />


</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/cdc-system-load.png" alt="cdc-system-load.png"  />


</p>
<p>测试结论是，在默认的 CDC 参数下面：</p>
<p>CDC 的开启/关闭过程中会导致若干个 Process Block，
大流量请求下面（15k TPS）过程会导致约 20 个左右 Process Block。
这个过程中对服务器的 IO / CPU 无明显波动，
开启/关闭瞬间会带来 mssql.sql-statistics.sql-compilations 剧烈波动。
CDC 开启后，在大流量请求下面对 QPS / Page IO 无明显波动，
对服务器的 IO / CPU 也无明显波动， CDC 开启后可以在 16k TPS 下正常工作。</p>
<p>如果对性能不达标，官方有一些简单的优化指南：</p>
<ul>
<li>调整 maxscan maxtrans pollinginterval</li>
<li>减少在插入后立刻插入</li>
<li>避免大批量写操作</li>
<li>限制需要记录的字段</li>
<li>尽可能关闭 net changes</li>
<li>没任务压力时跑 cleanup</li>
<li>监控 log file 大小和 IO 压力，确保不会写爆磁盘</li>
<li>要设置 filegroup_name</li>
<li>开启 sp_cdc_enable_table 之前设置 filegroup</li>
</ul>
<h2 id="yugong-的在线迁移机制">yugong 的在线迁移机制</h2>
<p>OK，截目前位置，我们已经具备了 CDC 这个工具，但是这仅仅提供了一种可能性，
我们还需要一个工具将 CDC 的数据消费出来，并喂到 MySQL 里面去。</p>
<p>好在有 yugong。
Yugong 官方提供了 Oracle 到 MySQL 的封装，并且抽象了 Source / Target /
SQL Tempalte 等接口，
我们只要实现相关接口，就可以完成从 SQL Server 消费数据到 MySQL 了。</p>
<p>这里我们不展开，我还会花专门的一篇文章讲如何在 yugong 上面进行开发。
可以提前剧透一下，我们已经将支持 SQL Server 的 yugong 版本开源了。</p>
<h2 id="如何回滚">如何回滚</h2>
<p>数据库迁移这样的项目，我们不仅仅要保证单向从 SQL Server 到 MySQL 的写入，
同时要从 MySQL 写入 SQL Server。</p>
<p>这个流程同样考虑增量写入的要素：增量消费，延迟，幂等一致性。</p>
<p>MySQL 的 binlog 可以满足这三个要素，需要注意的是，MySQL binlog 有三种模式，
Statement based，Row based 和 Mixed。只有 Row based 才能满足幂等一致性的要求。</p>
<p>确认理论上可行之后，我们一样需要一个工具将 binlog 读取出来，并且将其转化为
SQL Server 可以消费的数据格式，然后写入 SQL Server。</p>
<p>我们目光转到 alibaba 的另外一个项目 Canal。
Canal 是阿里中间件团队提供的 binlog 增量订阅 &amp; 消费组件。
之所以叫组件，是由于 Canal 提供了 Canal-Server 应用和 Canal Client Library，
Canal 会模拟成一个 MySQL 实例，作为 Slave 连接到 Master 上面，
然后实时将 binlog 读取出来。
至于 binlog 读出之后想怎么使用，权看用户如何使用。</p>
<p>我们基于 Canal 设计了一个简单的数据流，在 yugong 中增加了这么几个功能：</p>
<ul>
<li>SQL Server 的写入功能</li>
<li>消费 Canal 数据源的功能</li>
</ul>
<p>Canal Server 中的 binlog 只能做一次性消费，
内部实现是一个 Queue，
为了满足我们可以重复消费数据的能力，我们还额外设计了一个环节，将 Canal
的数据放到 Queue 中，在未来任意时间可以重复消费数据。
我们选择了 Redis 作为这个 Queue，数据流如下。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201805/canal.png" alt="canal.png"  />


</p>
<h2 id="最佳实践">最佳实践</h2>
<p>数据库的迁移在去 Windows 中，是最不容得出错的环节。
应用是无状态的，出现问题可以通过回切较快地回滚。
但数据库的迁移就需要考虑周到，做好资源准备，发布流程，
故障预案处理。</p>
<p>考虑到多个事业部都需要经历这个一个过程，我们项目组将每一个步骤都固化下来，
形成了一个最佳实践。我们的迁移步骤如下，供大家参考：</p>
<table>
<thead>
<tr>
<th>大阶段</th>
<th>阶段</th>
<th>事项</th>
<th>是否完成</th>
<th>负责人</th>
<th>耗时</th>
<th>开始时间</th>
<th>完成时间</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>白天</td>
<td>存量数据阶段</td>
<td>创建 MySQL 数据库，准备相关账号资源</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>开启 CDC</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>从 Slave SQLServer dump 一份 snapshot 到 Backup SQL Server</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Backup SQL Server 消费数据， ETL 到 MySQL</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>增量数据阶段</td>
<td>确认 ETL 数据已经消费完成，检查数据总条数</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>从 Slave SQLServer 开始消费 CDC 数据，持续写入 MySQL</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>使用 yugong 检查一天内数据的一致性</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>检查不一致的数据，10 分钟之后人工进行检查，确认是 CDC 延迟带来的问题</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>检查数据总量条目</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>使用 yugong 对抽样表进行全量检查</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>凌晨</td>
<td>应用发布阶段</td>
<td>停止 SQL Server 的应用</td>
<td></td>
<td>技术经理</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>检查没有连接进入 SQL Server</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>使用 yugong 检查一天内数据的一致性</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>检查数据总量条目</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>启用基于 MySQL 的应用</td>
<td></td>
<td>运维</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>测试阶段</td>
<td>测试应用是否正常，回归所有功能</td>
<td></td>
<td>QA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>（临时新增）测试 ReadOnly DB 的应用访问情况</td>
<td></td>
<td>QA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>完成阶段</td>
<td>接入流量</td>
<td></td>
<td>运维</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>（可选）回滚阶段</td>
<td>发现问题，直接将应用切回 SQL Server</td>
<td></td>
<td>运维</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>事后进行数据审计，进行新增数据补偿</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>（可选）回滚过程中，使用 Canal 读取 binlog，并使用 Canal Client 重放到 SQL Server</td>
<td></td>
<td>DBA</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://docs.oracle.com/cd/B10500_01/server.920/a96567/repmview.htm">Materialized View Concepts and Architecture</a></li>
<li><a href="https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008/dd266396(v=sql.100)">Tuning the Performance of Change Data Capture in SQL Server 2008 | Microsoft Docs</a></li>
<li><a href="https://github.com/alibaba/yugong">alibaba/yugong: 阿里巴巴去Oracle数据迁移同步工具(全量+增量,目标支持MySQL/DRDS)</a></li>
<li><a href="https://github.com/alibaba/canal">alibaba/canal: 阿里巴巴mysql数据库binlog的增量订阅&amp;消费组件 。阿里云DRDS( https://www.aliyun.com/product/drds )、阿里巴巴TDDL 二级索引、小表复制powerd by canal.</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>从 SQL Server 到 MySQL（一）：异构数据库迁移</title>
      <link>https://blog.alswl.com/2018/03/sql-server-migration-1/</link>
      <pubDate>Mon, 12 Mar 2018 21:08:56 +0800</pubDate>
      <guid>https://blog.alswl.com/2018/03/sql-server-migration-1/</guid>
      <description>该系列三篇文章已经全部完成： 从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D 从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D 背景 沪江成立于 2001 年，作为较早期的教育学习网站， 当时技术选型范围并不大： Java 的版本是 1.2，C# 尚未诞生，MySQL 还没有被 Sun 收购， 版本号是 3.23。 工程师们选择了当时最合适的微软体系，并在日后的岁月里， 逐步从 ASP 过度到 .net，数据</description>
      <content:encoded><![CDATA[<p>该系列三篇文章已经全部完成：</p>
<ul>
<li><a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/06/sql-server-migration-3/">从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D</a></li>
</ul>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201803/migration-bird.png" alt="201803/migration-bird.png"  />


</p>
<h2 id="背景">背景</h2>
<p>沪江成立于 2001 年，作为较早期的教育学习网站，
当时技术选型范围并不大：
Java 的版本是 1.2，C# 尚未诞生，MySQL 还没有被 Sun 收购，
版本号是 3.23。
工程师们选择了当时最合适的微软体系，并在日后的岁月里，
逐步从 ASP 过度到 .net，数据库也跟随 SQL Server 进行版本升级。</p>
<p>十几年过去了，技术社区已经发生了天翻地覆的变化。
沪江的技术栈还基本在 .net 体系上，这给业务持续发展带来了一些限制。
人才招聘、社区生态、架构优化、成本风险方面都面临挑战。
集团经过慎重考虑，发起了大规模的去 Windows 化项目。
这其中包含两个重点子项目：开发语言从 C# 迁移到 Java，
数据库从 SQL Server 迁移到 MySQL。</p>
<p>本系列文章就是向大家介绍，
从 SQL Server 迁移到 MySQL 所面临的问题和我们的解决方案。</p>
<!-- more -->
<h2 id="迁移方案的基本流程">迁移方案的基本流程</h2>
<p>设计迁移方案需要考量以下几个指标：</p>
<ul>
<li>迁移前后的数据一致性</li>
<li>业务停机时间</li>
<li>迁移项目是否对业务代码有侵入</li>
<li>需要提供额外的功能：表结构重构、字段调整</li>
</ul>
<p>经过仔细调研，在平衡复杂性和业务方需求后，
迁移方案设计为两种：停机数据迁移和在线数据迁移。
如果业务场景允许数小时的停机，那么使用停机迁移方案，
复杂度低，数据损失风险低。
如果业务场景不允许长时间停机，或者迁移数据量过大，
无法在几个小时内迁移完成，那么就需要使用在线迁移方案了。</p>
<p>数据库停机迁移的流程：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201803/migration-db-offline-readonly.png" alt="201803/migration-db-offline-readonly.png"  />


</p>
<p>停机迁移逻辑比较简单，使用 ETL（Extract Translate Load）
工具从 Source 写入 Target，然后进行一致性校验，最后确认应用运行 OK，
将 Source 表名改掉进行备份。</p>
<p>在线迁移的流程：</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201803/migration-db-online.png" alt="201803/migration-db-online.png"  />


</p>
<p>在线迁移的方案稍微复杂一些，流程上有准备全量数据，然后实时同步增量数据，
在数据同步跟上（延迟秒级别）之后，进行短暂停机（Hang 住，确保没有流量），
就可以使用新的应用配置，并使用新的数据库。</p>
<h2 id="需要解决的问题">需要解决的问题</h2>
<p>从 SQL Server 迁移到 MySQL，核心是完成异构数据库的迁移。</p>
<p>基于两种数据迁移方案，我们需要解决以下问题：</p>
<ul>
<li>两个数据库的数据结构是否可以一一对应？出现不一致如何处理？</li>
<li>MySQL 的使用方式和 SQL Server 使用方式是否一致？有哪些地方需要注意？</li>
<li>如何确保迁移前后的数据一致性？</li>
<li>在迁移中，如何支持数据结构调整？</li>
<li>如何保证业务不停情况下面，实现在线迁移？</li>
<li>数据迁移后如果发现业务异常需要回滚，如何处理新产生的数据？</li>
</ul>
<p>为了解决以上的问题，我们需要引入一整套解决方案，包含以下部分：</p>
<ul>
<li>指导文档 A：SQL Server 转换 MySQL 的数据类型对应表</li>
<li>指导文档 B：MySQL 的使用方式以及注意点</li>
<li>支持表结构变更，从 SQL Server 到 MySQL 的 ETL 工具</li>
<li>支持 SQL Server 到 MySQL 的在线 ETL 工具</li>
<li>一致性校验工具</li>
<li>一个回滚工具</li>
</ul>
<p>让我们一一来解决这些问题。</p>
<h2 id="sql-server-到-mysql-指导文档">SQL Server 到 MySQL 指导文档</h2>
<p>非常幸运的是，MySQL 官方早就准备了一份如何其他数据库迁移到
MySQL 的白皮书。
<a href="https://www.mysql.com/it/why-mysql/white-papers/guide-to-migrating-from-sql-server-to-mysql/">MySQL :: Guide to Migrating from Microsoft SQL Server to MySQL</a>
里提供了详尽的 SQL Server 到 MySQL 的对应方案。
包含了：</p>
<ul>
<li>SQL Server to MySQL - Datatypes 数据类型对应表</li>
<li>SQL Server to MySQL - Predicates 逻辑算子对应表</li>
<li>SQL Server to MySQL – Operators and Date Functions 函数对应表</li>
<li>T-SQL Conversion Suggestions 存储过程转换建议</li>
</ul>
<p>需要额外处理的数据类型：</p>
<table>
<thead>
<tr>
<th>SQL Server</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDENTITY</td>
<td>AUTO_INCREMENT</td>
</tr>
<tr>
<td>NTEXT, NATIONAL TEXT</td>
<td>TEXT CHARACTER SET UTF8</td>
</tr>
<tr>
<td>SMALLDATETIME</td>
<td>DATETIME</td>
</tr>
<tr>
<td>MONEY</td>
<td>DECIMAL(19,4)</td>
</tr>
<tr>
<td>SMALL MONEY</td>
<td>DECIMAL(10,4)</td>
</tr>
<tr>
<td>UNIQUEIDENTIFIER</td>
<td>BINARY(16)</td>
</tr>
<tr>
<td>SYSNAME</td>
<td>CHAR(256)</td>
</tr>
</tbody>
</table>
<p>在实际进行中，还额外遇到了一个用来解决树形结构存储的字段类型
Hierarchyid。这个场景需要额外进行业务调整。</p>
<p>我们在内部做了针对 MySQL 知识的摸底排查工作，
并进行了若干次的 MySQL 使用技巧培训，
将工程师对 MySQL 的认知拉到一根统一的线。</p>
<p>关于存储过程使用，我们和业务方也达成了一致：所有 SQL Server
存储过程使用业务代码进行重构，不能在 MySQL 中使用存储过程。
原因是存储过程增加了业务和 DB 的耦合，会让维护成本变得极高。
另外 MySQL 的存储过程功能和性能都较弱，无法大规模使用。</p>
<p>最后我们提供了一个 MySQL 开发规范文档，借数据库迁移的机会，
将之前相对混乱的表结构设计做了统一了约束（部分有业务绑定的设计，
在考虑成本之后没有做调整）。</p>
<h2 id="etl-工具">ETL 工具</h2>
<p>ETL 的全称是 Extract Translate Load（读取、转换、载入），
数据库迁移最核心过程就是 ETL 过程。
如果将 ETL 过程简化，去掉 Translate 过程，
就退化为一个简单的数据导入导出工具。
我们可以先看一下市面上常见的导入导出工具，
了解他们的原理和特性，方便我们选型。</p>
<p>MySQL 同构数据库数据迁移工具：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html">mysqldump</a>
和 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlimport.html">mysqlimport</a>
MySQL 官方提供的 SQL 导出导出工具</li>
<li><a href="https://www.percona.com/doc/percona-toolkit/LATEST/pt-table-sync.html">pt-table-sync</a>
Percona 提供的主从同步工具</li>
<li><a href="https://www.percona.com/software/mysql-database/percona-xtrabackup">XtraBackup</a>
Percona 提供的备份工具</li>
</ul>
<p>异构数据库迁移工具：</p>
<ul>
<li><a href="https://www.convert-in.com/">Database migration and synchronization tools</a>
：国外一家提供数据库迁移解决方案的公司</li>
<li><a href="https://github.com/alibaba/DataX">DataX</a>
：阿里巴巴开发的数据库同步工具</li>
<li><a href="https://github.com/alibaba/yugong">yugong</a>
：阿里巴巴开发的数据库迁移工具</li>
<li><a href="https://www.mysql.com/cn/products/workbench/">MySQL Workbench</a>
：MySQL 提供的 GUI 管理工具，包含数据库迁移功能</li>
<li><a href="https://community.hds.com/docs/DOC-1009855">Data Integration - Kettle</a>
：国外的一款 GUI ETL 工具</li>
<li><a href="https://www.ispirer.cn/products/sql-server-to-mysql-migration">Ispirer</a>
：提供应用程序、数据库异构迁移方案的公司</li>
<li><a href="http://www.szmesoft.com/DB2DB">DB2DB 数据库转换工具</a>
：一个国产的商业数据库迁移软件</li>
<li><a href="https://www.navicat.com/en/products/navicat-premium">Navicat Premium</a>
：经典的数据库管理工具，带数据迁移功能</li>
<li><a href="http://www.cnblogs.com/cyq1162/p/5637978.html">DBImport</a>
：个人维护的迁移工具，非常简陋，需要付费</li>
</ul>
<p>看上去异构数据库迁移工具和方案很多，但是经过我们调研，其中不少是为老派的传统行业服务的。
比如 Kettle / Ispirerer，他们关注的特性，不能满足互联网公司对性能、迁移耗时的要求。
简单筛选后，以下几个工具进入我们候选列表（为了做特性对比，加入几个同构数据库迁移工具）：</p>
<table>
<thead>
<tr>
<th>工具名称</th>
<th>热数据备份保证一致性</th>
<th>batch 操作</th>
<th>支持异构数据库</th>
<th>断点续接</th>
<th>开源</th>
<th>开发语言</th>
<th>GUI</th>
</tr>
</thead>
<tbody>
<tr>
<td>mysqldump</td>
<td>V 使用 <code>single-transaction</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>V</td>
<td>C</td>
<td>X</td>
</tr>
<tr>
<td>pt-table-sync</td>
<td>V 使用 transaction 或 <code>lock table</code> 的 FTWRL</td>
<td>V</td>
<td>X</td>
<td>V</td>
<td>V</td>
<td>Pell</td>
<td>X</td>
</tr>
<tr>
<td>DataX</td>
<td>X</td>
<td>V</td>
<td>V</td>
<td>X</td>
<td>V</td>
<td>Java</td>
<td>X</td>
</tr>
<tr>
<td>yugong</td>
<td>X</td>
<td>V</td>
<td>V</td>
<td>V</td>
<td>V</td>
<td>Java</td>
<td>X</td>
</tr>
<tr>
<td>DB2DB</td>
<td>X</td>
<td>V</td>
<td>V</td>
<td>X</td>
<td>X</td>
<td>.net</td>
<td>V</td>
</tr>
<tr>
<td>MySQL Workbench</td>
<td>X</td>
<td>?</td>
<td>V</td>
<td>X</td>
<td>V</td>
<td>C++</td>
<td>V</td>
</tr>
</tbody>
</table>
<p>由于异构数据库迁移，真正能够进入我们选型的只有
DataX / yugong / DB2DB / MySQL Workbench。
经过综合考虑，我们最终选用了三种方案，
DB2DB 提供小数据量、简单模式的停机模式支持，
足以应付小数据量的停机迁移，开发工程师可以自助完成。
DataX 为大数据量的停机模式提供服务，
使用 JSON 进行配置，通过修改查询 SQL，可以完成一部分结构调整工程。
yugong 的强大可定制性也为在线迁移提供了基础，
我们在官方开源版本的基础之上，增加了以下额外功能：</p>
<ul>
<li>支持 SQL Server 作为 Source 和 Target</li>
<li>支持 MySQL 作为 Source</li>
<li>支持 SQL Server 增量更新</li>
<li>支持使用 YAML 作为配置格式</li>
<li>调整 yugong 为 fat jar 模式运行</li>
<li>支持表名、字段名大小写格式变化，驼峰和下划线自由转换</li>
<li>支持表名、字段名细粒度自定义</li>
<li>支持复合主键迁移</li>
<li>支持迁移过程中完成 Range / Time / Mod / Hash 分表</li>
<li>支持新增、删除字段</li>
</ul>
<p>关于 yugong 的二次开发，我们也积累了一些经验，这个我们下篇文章会来分享。</p>
<h2 id="一致性校验工具">一致性校验工具</h2>
<p>在 ETL 之后，需要有一个流程来确认数据迁移前后是否一致。
虽然理论上不会有差异，但是如果中间有程序异常，
或者数据库在迁移过程中发生操作，数据就会不一致。</p>
<p>业界有没有类似的工具呢？
有，Percona 提供了 pt-table-checksum 这样的工具，
这个工具设计从 master 使用 <code>checksum</code> 来和 slave 进行数据对比。
这个设计场景是为 MySQL 主从同步设计，
显然无法完成从 SQL Server 到 MySQL 的一致性校验。
尽管如此，它的一些技术设计特性也值得参考：</p>
<ul>
<li>一次检查一张表</li>
<li>每次检查表，将表数据拆分为多个 trunk 进行检查</li>
<li>使用 <code>REPLACE...SELECT</code> 查询，避免大表查询的长时间带来的不一致性</li>
<li>每个 trunk 的查询预期时间是 0.5s</li>
<li>动态调整 trunk 大小，使用指数级增长控制大小</li>
<li>查询超时时间 1s / 并发量 25</li>
<li>支持故障后断点恢复</li>
<li>在数据库内部维护 src / diff，meta 信息</li>
<li>通过 Master 提供的信息自动连接上 slave</li>
<li>必须 Schema 结构一致</li>
</ul>
<p>我们选择 yugong 作为 ETL 工具的一大原因也是因为它提供了多种模式。
支持 CHECK / FULL / INC / AUTO 四种模式。
其中 CHECK 模式就是将 yugong 作为数据一致性检查工具使用。
yugong 工作原理是通过 JDBC 根据主键范围变化，将数据取出进行批量对比。</p>
<p>这个模式会遇到一点点小问题，如果数据库表没有主键，将无法进行顺序对比。
其实不同数据库有自己的逻辑主键，Oracle 有 <code>rowid</code>，
SQL Server 有 <code>physloc</code>。这种方案可以解决无主键进行比对的问题。</p>
<h2 id="如何回滚">如何回滚</h2>
<p>我们需要考虑一个场景，在数据库迁移成功之后业务已经运行了几个小时，
但是遇到了一些 Critical 级别的问题，必须回滚到迁移之前状态。
这时候如何保证这段时间内的数据更新到老的数据库里面去？</p>
<p>最朴素的做法是，在业务层面植入 DAO 层的打点，
将 SQL 操作记录下来到老数据库进行重放。
这种方式虽然直观，但是要侵入业务系统，直接被我们否决了。
其实这种方式是 binlog statement based 模式，
理论上我们可以直接从 MySQL 的 binlog 里面获取数据变更记录。
以 row based 方式重放到 SQL Server。</p>
<p>这时候又涉及到逆向 ETL 过程，
因为很可能 Translate 过程中，做了表结构重构。
我们的解决方法是，使用 Canal 对 MySQL binlog 进行解析，
然后将解析之后的数据作为数据源，
将其中的变更重放到 SQL Server。</p>
<p>由于回滚的过程也是 ETL，基于 yugong，
我们继续定制了 SQL Server 的写入功能，
这个模式类似于在线迁移，只不过方向是从 MySQL 到 SQL Server。</p>
<h2 id="其他实践">其他实践</h2>
<p>我们在迁移之前做了大量压测工作，
并针对每个迁移的 DB 进行线上环境一致的全真演练。
我们构建了和生产环境机器配置一样，
数据量一样的测试环境，并要求每个系统在上线之前都进行若干次演练。
演练之前准备详尽的操作手册和事故处理方案。
演练准出的标准是：能够在单次演练中不出任何意外，时间在估计范围内。
通过演练我们保证了整个操作时间可控，减少操作时候的风险。</p>
<p>为了让数据库的状态更为直观的展现出来，
我们对 MySQL / SQL Server 添加了细致的 Metrics 监控。
在测试和迁移过程中，可以便利地看到数据库的响应情况。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201803/sql-server-metrics.png" alt="201803/sql-server-metrics.png"  />


</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201803/mysql-metrics.png" alt="201803/mysql-metrics.png"  />


</p>
<p>为了方便 DBA 快速 Review SQL。
我们提供了一些工具，直接将代码库中的 SQL 拎出来，
可以方便地进行 SQL Review。
再配合其他 SQL Review 工具，
比如 <a href="https://github.com/Meituan-Dianping/SQLAdvisor">Meituan-Dianping/SQLAdvisor</a>，
可以实现一部分自动化，提高 DBA 效率，避免线上出现明显的 Slow SQL。</p>
<h2 id="最后">最后</h2>
<p>基于这几种方案我们打了一套组合拳。经过将近一年的使用，
进行了 28 个通宵，迁移了 42 个系统，
完成了包括用户、订单、支付、电商、学习、社群、内容和工具的迁移。
迁移的数据总规模接近百亿，所有迁移项目均一次成功。
迁移过程中积累了丰富的实战经验，保障了业务快速向前发展。</p>
<p>下一篇：<a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D</a></p>
]]></content:encoded>
    </item>
  </channel>
</rss>
