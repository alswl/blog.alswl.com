<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>重构 on Log4D</title>
    <link>https://blog.alswl.com/tags/%E9%87%8D%E6%9E%84/</link>
    <description>Recent content in 重构 on Log4D</description>
    <generator>Hugo -- 0.125.6</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 17 Nov 2009 00:00:00 +0800</lastBuildDate>
    <atom:link href="https://blog.alswl.com/tags/%E9%87%8D%E6%9E%84/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java笔记 使用反射来改进BaseDao</title>
      <link>https://blog.alswl.com/2009/11/note-the-use-of-java-reflection-to-improve-the-basedao/</link>
      <pubDate>Tue, 17 Nov 2009 00:00:00 +0800</pubDate>
      <guid>https://blog.alswl.com/2009/11/note-the-use-of-java-reflection-to-improve-the-basedao/</guid>
      <description>关于反射 反射的定义（via Wiki）：在计算机科学中，反射是指一种特定类型的计算机程序能够在运行时以一种依 赖于它的代码的抽象特性和它的运行时行为的方式被更改的特性。用比喻来说，那种程式能够&amp;quot;观察&amp;ldquo;并且修改自己的行为。 Java中的反射示例如下： package dddspace.job.exercise1116; public class Foo { public void fun(String str) { System.out.println(str); } } package dddspace.job.exercise1116; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class ReflectionDemo { public static void main(String[] args) throws SecurityException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { // 不使用反射 Foo foo = new Foo(); foo.fun(&amp;#34;no reflection&amp;#34;); // 使用反射 String className = &amp;#34;dddspace.job.exercise1116.Foo&amp;#34;; String funName = &amp;#34;fun&amp;#34;; // 获取类</description>
      <content:encoded><![CDATA[<h2 id="关于反射">关于反射</h2>
<p>反射的定义（via <a href="http://zh.wikipedia.org/zh-cn/%E5%8F%8D%E5%B0%84_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29">Wiki</a>）：在计算机科学中，反射是<strong>指一种特定类型的计算机程序能够在运行时以一种依
赖于它的代码的抽象特性和它的运行时行为的方式被更改</strong>的特性。用比喻来说，那种程式能够&quot;<strong>观察</strong>&ldquo;并且修改自己的行为。</p>
<p>Java中的反射示例如下：</p>
<pre tabindex="0"><code>    package dddspace.job.exercise1116;

public class Foo {

public void fun(String str) {

System.out.println(str);

}

}


    package dddspace.job.exercise1116;

import java.lang.reflect.InvocationTargetException;

import java.lang.reflect.Method;

public class ReflectionDemo {

public static void main(String[] args) throws SecurityException,

NoSuchMethodException, ClassNotFoundException, InstantiationException,

IllegalAccessException, IllegalArgumentException,

InvocationTargetException {

// 不使用反射

Foo foo = new Foo();

foo.fun(&#34;no reflection&#34;);


// 使用反射

String className = &#34;dddspace.job.exercise1116.Foo&#34;;

String funName = &#34;fun&#34;;

// 获取类名

Class cls = Class.forName(className);

// 创建Object实例

Object foo2 = cls.newInstance();

// 创建Method hello

Method method = cls.getMethod(&#34;fun&#34;, String.class);

// 使用反射来调用Method的invode方法，参数是目标对象+参数

method.invoke(foo, &#34;use reflection&#34;);

}

}
</code></pre><h2 id="原始basedao设计">原始BaseDao设计</h2>
<p>我先阐述一下BaseDao的设计想法：BaseDao是一个<strong>抽象类</strong>，提供一系列Dao方法&rdquo;<strong>get()/getAll()/add()/update()/delete()/getCount()</strong>&quot;，通过<strong>泛型匹配</strong>的获取类，我取出一个方法来做示例。</p>
<pre tabindex="0"><code>    public int getCount()
    {
    	int count = 0;
    	Session session = null;
    	Transaction tx = null;
    	String Tstr = getClass().getSimpleName().substring (0,
    			getClass().getSimpleName().length() - 3);
    	String hql = &#34;select count(*) from &#34; + Tstr;
    	try {
    		session = HibernateSessionFactory.currentSession();
    		tx = session.beginTransaction();
    		Query query = session.createQuery(hql);
    		count = Integer.parseInt(query.uniqueResult().toString());
    		query = null;
    		tx.commit();
    	} catch (HibernateException e) {
    		if (tx != null) {
    			tx.rollback();
    		}
    		throw e;
    	} finally {
    		HibernateSessionFactory.closeSession();
    	}				
    	return count;
    }
</code></pre><p>其中有一段<strong>dirty work</strong>，就是TStr的获取，这段TStr是想从实现Dao类获取实体类的类型名称，也就是
从&quot;TopicDao&quot;获取&quot;Topic&quot;这个类型名称。整个BaseDao的泛型设计不错，但是在这一段上面存在一段dirty work，始终让我不爽。</p>
<h2 id="重构basedao和topicdao">重构BaseDao和TopicDao</h2>
<p>我今天复习完抽象类/接口/反射这些内容，又在纸上画了一个模型，觉得用这种新方法解决会更好一点。</p>
<p>给抽象类BasoDao加入新的变量Class c，然后在TopicDao初始化时候对Class
c进行设置为Topic.class，这样就比原来的拼字符串好的多。耦合也显得漂亮了</p>
<pre tabindex="0"><code>    public abstract class BaseDAO&lt;T&gt; {
    	
    	protected Class c;
    	
    	private Logger logger = Logger.getLogger(this.getClass());
    	
    	/**
    	 * 根据某个Bean的beanId取出Bean
    	 * @param tId
    	 * @return Bean
    	 */
    	public T get(int tId)
    	{
    		T t=null;
    		Session session = null;
    		Transaction tx = null;
    		// 原始设计
    //		String Tstr = getClass().getSimpleName().substring (0,
    //				getClass().getSimpleName().length() - 3);
    		// 获取c的名称
    		String Tstr = c.getSimpleName();
    		String TstrId = Tstr+&#34;Id&#34;;
    		String hql = &#34;from &#34; + Tstr + &#34; where &#34; +
    			TstrId.substring(0, 1).toLowerCase() + TstrId.substring(1) + &#34; = ?&#34;;
    		try {
    			session = HibernateSessionFactory.currentSession();
    			tx = session.beginTransaction();
    			Query query = session.createQuery(hql);
    			query.setInteger(0,tId);
    			t = (T)query.uniqueResult();
    			query = null;
    			tx.commit();
    		} catch (HibernateException e) {
    			if (tx != null) {
    				tx.rollback();
    			}
    			throw e;
    		} finally {
    			HibernateSessionFactory.closeSession();
    		}		
    		return t;
    	}
    
    public class TopicDAO extends BaseDAO&lt;Topic&gt;{
    		
    	private Logger logger = Logger.getLogger(this.getClass());
    	/**
    	 * 根据froumId取出某一吧内的所有没被屏蔽的帖子
    	 * @param froumId
    	 * @return ArrayList&lt;Topic&gt; 
    	 * @throws HibernateException
    	 */
    	// 在构造函数中进行c的设置
    	public TopicDAO () {
    		c = Topic.class;
    	}
    	//doSomething
    }
</code></pre><p>这样完成之后，就完成了一次简单的重构，实现了<strong>变化点分离</strong>，而且不那么dirty。</p>
<p>本文的代码来源自PostBar项目。这里有<a href="http://code.google.com/p/postbar/">Google Code链接</a>，v1.0.1的代码并没有上文的实现，本文中的修改还在trunk中。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
