<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hiredis on Log4D</title>
    <link>https://blog.alswl.com/tags/hiredis/</link>
    <description>Recent content in Hiredis on Log4D</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 30 Mar 2014 15:41:43 +0800</lastBuildDate>
    <atom:link href="https://blog.alswl.com/tags/hiredis/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>hiredis 源码学习</title>
      <link>https://blog.alswl.com/2014/03/hiredis/</link>
      <pubDate>Sun, 30 Mar 2014 15:41:43 +0800</pubDate>
      <guid>https://blog.alswl.com/2014/03/hiredis/</guid>
      <description>&lt;p&gt;前段时间学习 Redis 时候，听到 hiredis 的大名，正好也在做异步的学习，就找来代码学习一下。
我几乎不太会 C，仅限于最简单的语法，完全没有在生产环境中写过，
所以先看个 Client 简单代码，下次看 Memcached 代码应该会更顺畅一些。&lt;/p&gt;
&lt;p&gt;Hiredis 是用 C 写的 Redis 客户端，对 Redis 协议进行了简单的封装，
同时提供了同步和异步的两种 API。Hiredis 的代码位于
&lt;a href=&#34;https://github.com/redis/hiredis&#34;&gt;https://github.com/redis/hiredis&lt;/a&gt;。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一分钟使用入门&#34;&gt;一分钟使用入门&lt;/h2&gt;
&lt;p&gt;同步 API 的调用方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;redisContext *context = redisConnect(&amp;#34;127.0.0.1&amp;#34;, 6379);
reply = redisCommand(context, &amp;#34;SET foo %s&amp;#34;, value);	
printf(&amp;#34;PING: %s\n&amp;#34;, reply-&amp;gt;str);
freeReplyObject(reply)
redisFree(context);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Redis ae 异步 API 的调用方法，使用 Redis 自己的 ae 事件库，
至于为什么 Redis 没有使用 libevent 或者 libev，可以参考
&lt;a href=&#34;http://groups.google.com/group/redis-db/browse_thread/thread/b52814e9ef15b8d0/&#34;&gt;Reason&lt;/a&gt;，
&lt;a href=&#34;http://blog.csdn.net/archimedes_zht/article/details/6909074&#34;&gt;中文翻译&lt;/a&gt;：&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>前段时间学习 Redis 时候，听到 hiredis 的大名，正好也在做异步的学习，就找来代码学习一下。
我几乎不太会 C，仅限于最简单的语法，完全没有在生产环境中写过，
所以先看个 Client 简单代码，下次看 Memcached 代码应该会更顺畅一些。</p>
<p>Hiredis 是用 C 写的 Redis 客户端，对 Redis 协议进行了简单的封装，
同时提供了同步和异步的两种 API。Hiredis 的代码位于
<a href="https://github.com/redis/hiredis">https://github.com/redis/hiredis</a>。</p>
<!-- more -->
<h2 id="一分钟使用入门">一分钟使用入门</h2>
<p>同步 API 的调用方法：</p>
<pre tabindex="0"><code>redisContext *context = redisConnect(&#34;127.0.0.1&#34;, 6379);
reply = redisCommand(context, &#34;SET foo %s&#34;, value);	
printf(&#34;PING: %s\n&#34;, reply-&gt;str);
freeReplyObject(reply)
redisFree(context);
</code></pre><p>Redis ae 异步 API 的调用方法，使用 Redis 自己的 ae 事件库，
至于为什么 Redis 没有使用 libevent 或者 libev，可以参考
<a href="http://groups.google.com/group/redis-db/browse_thread/thread/b52814e9ef15b8d0/">Reason</a>，
<a href="http://blog.csdn.net/archimedes_zht/article/details/6909074">中文翻译</a>：</p>
<pre tabindex="0"><code>void connectCallback(const redisAsyncContext *c, int status) {
    printf(&#34;Connected...\n&#34;);
}

void disconnectCallback(const redisAsyncContext *c, int status) {
    printf(&#34;Disconnected...\n&#34;);
}
void getCallback(redisAsyncContext *c, void *r, void *privdata) {
    redisReply *reply = r;
    if (reply == NULL) return;
    printf(&#34;argv[%s]: %s\n&#34;, (char*)privdata, reply-&gt;str);
    redisAsyncDisconnect(c);
}

redisAsyncContext *c = redisAsyncConnect(&#34;127.0.0.1&#34;, 6379);
loop = aeCreateEventLoop();
redisAeAttach(loop, c);
redisAsyncSetConnectCallback(c,connectCallback);
redisAsyncSetDisconnectCallback(c,disconnectCallback);

redisAsyncCommand(c, getCallback, (char*)&#34;end-1&#34;, &#34;GET key&#34;);
</code></pre><p>Libev 异步 API 调用，因为 <code>adapters/*.h</code> 封装的好，所以几乎和 ae 调用一致：</p>
<pre tabindex="0"><code>void connectCallback(const redisAsyncContext *c, int status) {
    printf(&#34;Connected...\n&#34;);
}
void disconnectCallback(const redisAsyncContext *c, int status) {
    printf(&#34;Disconnected...\n&#34;);
}
void getCallback(redisAsyncContext *c, void *r, void *privdata) {
    redisReply *reply = r;
    if (reply == NULL) return;
    printf(&#34;argv[%s]: %s\n&#34;, (char*)privdata, reply-&gt;str);

    /* Disconnect after receiving the reply to GET */
    redisAsyncDisconnect(c);
}

redisAsyncContext *c = redisAsyncConnect(&#34;127.0.0.1&#34;, 6379);
redisLibevAttach(EV_DEFAULT_ c);
redisAsyncSetConnectCallback(c,connectCallback);
redisAsyncSetDisconnectCallback(c,disconnectCallback);
redisAsyncCommand(c, getCallback, (char*)&#34;end-1&#34;, &#34;GET key&#34;);
</code></pre><p>Hiredis 还支持使用 libevent，我就不列出来了。</p>
<p>详细的使用 example 可以看
<a href="https://github.com/redis/hiredis/tree/master/examples">https://github.com/redis/hiredis/tree/master/examples</a>。</p>
<h2 id="主要结构">主要结构</h2>
<ul>
<li>redisReply</li>
<li>redisReader</li>
<li>redisContext</li>
</ul>
<h2 id="流程">流程</h2>
<h3 id="同步连接">同步连接</h3>
<p>同步连接的代码在 <code>hiredis.c</code> 和 <code>net.c</code> 中。</p>
<p><code>redisConnect</code> / <code>redisConnectWithTimeout</code> / <code>redisConnectNonBlock</code> 都调用了
<code>net.c</code> 里面的 <code>redisContextConnectTcp</code>。使用 <code>fcntl(fd, F_SETFL, flags)</code>
设置是否阻塞连接。</p>
<p><code>O_NONBLOCK</code> 即 Socket 非阻塞模式，但仍然是同步的哦。</p>
<p>事实上，无论阻塞还是非阻塞，hiredis 都会使用非阻塞（poll）来
<code>connect</code> 连接服务器，会返回 -1，并且 <code>errno</code>
为 <code>EINPROGRESS</code>，这是非阻塞模式正常的表现。
为什么阻塞模式也会强制使用非阻塞的 <code>poll</code> 连接？其实是为了能够支持 timeout 功能。
hiredis 在连接成功之后，按照之前需求重新设定为阻塞或者非阻塞模式。</p>
<p>关于如何设计超时功能，可以参考 <a href="http://blog.csdn.net/ast_224/article/details/2957294">http://blog.csdn.net/ast_224/article/details/2957294</a>。</p>
<h3 id="命令">命令</h3>
<p>使用 va_list 解决变参问题（C 也支持变长参数，被惊呆了，我果然是 C 盲啊）。</p>
<pre tabindex="0"><code>int redisFormatCommand(char **target, const char *format, ...) {
	va_list ap;
	int len;
	va_start(ap,format);
}
</code></pre><p><code>redisvCommand</code> 用来执行阻塞Redis 命令，它会调用 <code>__redisBlockForReply</code>，
内部调用 <code>redisBufferWrite</code> 从 socket 写 buffer，然后同步等待，从
<code>redisBufferRead</code> 读数据，用 <code>redisGetReplyFromReader</code> 解析返回数据。</p>
<h3 id="异步连接">异步连接</h3>
<p>异步调用的代码在 <code>async.c</code> 中，我先看 ae 库。</p>
<p>重要的结构是 <code>redisAsyncContext</code> 和 <code>redisAeEvents</code>，前者重要的方法是注册回调函数：
<code>addRead</code> / <code>delRead</code> / <code>addWrite</code> / <code>delWrite</code>，后者是用来存放 loop / fd / event stream
的。</p>
<p>异步连接时候，仍然使用 <code>redisContextConnectTcp</code> 来发起到服务器的非阻塞连接。</p>
<p>使用 <code>aeCreateEventLoop</code> 创建一个事件循环，然后使用 <code>redisAeAttach</code> 给
<code>context</code> 注册事件，比如说 <code>aeCreateFileEvent(loop,e-&gt;fd,AE_READABLE,redisAeReadEvent,e)</code>
就注册了一个 <code>read</code> 事件，并将 callback 调用设置到 <code>redisAeReadEvent</code>，
<code>redisAeReadEvent</code> 再将这个事件托管给 <code>redisAsyncHandleRead</code>（定义在 async.c 里面，
被三个 event 库调用）。</p>
<p>所以，hiredis 通过 adapter 的封装，屏蔽了 ae / libevent / libev 的 API 差异，
从而可以灵活的选择。据说 ae 是从两个 libevent 库重写过来的，可是我觉得 ae
的风格和 libev 比较像，而 libevent 的风格比较好理解。</p>
<p>如果拿这段代码的复杂度和 Tornado 的 IOLoop 进行对比，真实感觉 Tornado 那段 API
封装太人性化了，C 的代码写起来好复杂，系统 API、资源控制、错误控制都挺麻烦。</p>
<p>Redis ae 事件库的分析可以参考 <a href="http://my.oschina.net/u/917596/blog/161077#OSC_h4_6">http://my.oschina.net/u/917596/blog/161077#OSC_h4_6</a>。
Libevent 的一个简单教程 <a href="http://www.wangafu.net/~nickm/libevent-book/01_intro.html">http://www.wangafu.net/~nickm/libevent-book/01_intro.html</a>。</p>
<h2 id="关于-c">关于 C</h2>
<p>作为 C 渣的我，勉强读完 hiredis，感觉那点 C 基础完全不够用，
稍微将学习过程中疑惑的地方罗列一下：</p>
<ul>
<li><code>IFDEF</code> 使用，可以防止重复导入同一个头文件定义，这里有一个详细的解释
<a href="http://faculty.cs.niu.edu/~mcmahon/CS241/c241man/node90.html">http://faculty.cs.niu.edu/~mcmahon/CS241/c241man/node90.html</a></li>
<li><code>__cplusplus</code>: C++ 里面定义了这个变量，而 C 没有定义，所以当 C++ 编译器识别
source 时候，通过这个加上 <code>ifdef</code> 来使用 <code>extern</code> 编译 C 代码。</li>
<li>long long: long 只能存放 32 位，long long 可以存放 64 位长度，即 0 - 2^64-1。</li>
<li><code>c-&gt;flags |= REDIS_BLOCK</code> / <code>c-&gt;flags &amp;= ~REDIS_BLOCK;</code> 简洁的位操作。</li>
<li>sds（simple dynamic string）是 Redis 自己实现的 C String 字符串结构。</li>
<li><code>((void)fd)</code> 好像是将 fd 指针转成无类型的指针，不知道有什么用处。</li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>
