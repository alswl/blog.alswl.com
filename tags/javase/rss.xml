<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Javase on Log4D</title>
    <link>https://blog.alswl.com/tags/javase/</link>
    <description>Recent content in Javase on Log4D</description>
    <generator>Hugo -- 0.128.2</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 18 Apr 2010 00:00:00 +0800</lastBuildDate>
    <atom:link href="https://blog.alswl.com/tags/javase/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>最近在学的技术</title>
      <link>https://blog.alswl.com/2010/04/recent-study-technologys/</link>
      <pubDate>Sun, 18 Apr 2010 00:00:00 +0800</pubDate>
      <guid>https://blog.alswl.com/2010/04/recent-study-technologys/</guid>
      <description>根据这篇日志的题目，必然是一篇水文，我思量再三，还是把它放出来，这些技术的接触把我带入了另一个广阔的天堂。这是我学Java以来的第二个里程碑。 使用Java1年半，1年前开始JSP编程，一直是我和周围的朋友自己摸索，学校没有开Java课，也没有参加什么培训课程，面对庞大的Java开源分支，我一直摸索 ，不能登堂入室。 万分感谢倪经理这1个月来的教导，他给了我一个不一样的Java。 iBatis 如果说Hibernat</description>
      <content:encoded><![CDATA[<p>根据这篇日志的题目，必然是一篇水文，我思量再三，还是把它放出来，这些技术的接触把我带入了另一个广阔的天堂。这是我学Java以来的第二个里程碑。</p>
<p>使用Java1年半，1年前开始JSP编程，一直是我和周围的朋友自己摸索，学校没有开Java课，也没有参加什么培训课程，面对庞大的Java开源分支，我一直摸索
，不能登堂入室。</p>
<p>万分感谢倪经理这1个月来的教导，他给了我一个不一样的Java。</p>
<h3 id="ibatis">iBatis</h3>
<p>如果说Hibernate是一款自动化的导弹，那么iBatis则是一款轻型的半自动步枪，简介、高效、方便配置。加上iBator这个神器，iBatis可以使开发
效率几倍提升。</p>
<p>年前开始学习iBatis，想借其思想自己完成一个简单的ORM系统，3月份时候，公司的一个新框架采用了iBatis，更是给我提供了一个绝佳的Playgroun
d。Hibernate和iBatis有各自的适合使用的领域，不能单纯的说谁好谁不好，不过iBatis绝对值得尝试。</p>
<p>动软的.net生成器使用的DAL接入层也是使用的iBats.net做数据接入。</p>
<h3 id="jaas">Jaas</h3>
<p>我对权限控制的理解，从最早的单表用户字段管理，到贴吧的基于角色权限控制，直到后来公司使用的基于权限+菜单控制，最好到现在的Jaas提供的资源-角色-权限-
菜单 控制体系。细化到原子级的权限控制带来了莫大的好处，这个很大程度归功于Jaas。</p>
<blockquote>
<p>Java Authentication Authorization Service（JAAS，Java验证和授权API）提供了灵活和可伸缩的机制来保证客
户端或服务器端的Java程序。Java早期的安全框架强调的是通过验证代码的来源和作者，保护用户避免受到下载下来的代码的攻击。JAAS强调的是通过验证谁在运行
代码以及他／她的权限来保护系统面受用户的攻击。它让你能够将一些标准的安全机制，例如Solaris NIS（网络信息服务）、Windows
NT、LDAP（轻量目录存取协议），Kerberos等通过一种通用的，可配置的方式集成到系统中。</p>
</blockquote>
<p>我对这套权限系统的学习还不透彻，还有很多地方需要琢磨和研究，学无止境啊。</p>
<h3 id="esb">ESB</h3>
<p>很惭愧，知道现在才知道这个名词，ESB的思想其实在很多地方得到了灌输，我一直自认经常会跟进主流技术，现在才发现果然还是自己道行不够。</p>
<blockquote>
<p>ESB全称为Enterprise Service
Bus，即企业服务总线。它是传统中间件技术与XML、Web服务等技术结合的产物。ESB提供了网络中最基本的连接中枢，是构筑企业神经系统的必要元素</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>ESB的出现改变了传统的软件架构，可以提供比传统中间件产品更为廉价的解决方案，同时它还可以消除不同应用之间的技术差异，让不同的应用服务器协调运作，实现了
不同服务之间的通信与整合。从功能上看，ESB提供了事件驱动和文档导向的处理模式，以及分布式的运行管理机制，它支持基于内容的路由和过滤，具备了复杂数据的传输能
力，并可以提供一系列的标准接口。</p>
</blockquote>
<h3 id="mule">Mule</h3>
<p>Mule是一个企业服务总线(ESB)消息框架，也就是上面所说的ESB的一个开源框架实现。Mule的优势体现在：</p>
<p>1.基于J2EE1.4的企业消息总线(ESB)和消息代理(broker).</p>
<p>2.可插入的连接性:比如 Jms,jdbc,tcp,udp,multicast,http,servlet,smtp,pop3, file,xmpp等.</p>
<p>3.支持任何传输之上的异步，同步和请求响应事件处理机制.</p>
<p>4.支持Axis或者Glue的Web Service.</p>
<p>5.灵活的部署结构 [Topologies]包括Client/Server, P2P, ESB 和Enterprise Service Network.</p>
<ol start="6">
<li>与Spring 框架集成:可用作ESB 容器，也可以很容易的嵌入到Spring应用中.</li>
</ol>
<p>7.使用基于SEDA处理模型的高度可伸缩的企业服务器.</p>
<p>8.强大的基于EIP模式的事件路由机制等.</p>
<p>Mule发布最新版本1.1，这个发布包括集成了JBI，对 BPEL的支持,还增加一些新的传输器(transport)Quartz,FTP,RMI与EJB等。</p>
<h3 id="tiles">Tiles</h3>
<p>我之前认识是<include>已经是一种比较好的页面实现方式，Tiles的出现粉碎了我的认识。Tiles框架提供了一种模板机制，模板定义了网页的布局，同一模
板可以被多个Web页面共用。通过配置文件进行协调，把页面文件的分层应用到极致。</p>
<blockquote>
<p>Apache Tiles 是一个创建简单的网络应用用户界面的模板框架，Tiles让用户可以在运行中使用定义好的小模块装配成完整的页面。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>采用基本的JSP语句创建复合式网页 -&gt; 采用JSP的include指令创建复合式网页 -&gt; 采用Tiles:Insert标签创建复合式网页 -&gt;
采用Tiles模板创建复合式网页</p>
</blockquote>
<h3 id="web压力测试">Web压力测试</h3>
<p>这是我在翻阅大学里软件工程课孙老师给05届毕业生的PPT时候发现的内容。PPT体面推荐了3种Web压力测试工具。</p>
<p>Web Application Stress Tool, Microsoft</p>
<p><a href="http://jakarta.apache.org/jmeter/">JMeter, Java Apache Project</a></p>
<p><a href="http://www.broadgun.com">LoadItUp, BroadGun Software</a></p>
<p>上述三种，我只试用了JMeter，还在继续研究中。</p>
<h3 id="web测试自动化">Web测试自动化</h3>
<p>这也是从那堆PPT中学习的东西，我把他们列到我的GTD计划中，还没来得及实现。</p>
<h4 id="watir">[Watir</h4>
<p>](<a href="http://wtr.rubyforge.org/">http://wtr.rubyforge.org/</a>)</p>
<p>一个使用 Ruby 实现的开源Web 自动化测试框架。</p>
<h4 id="selenium">[Selenium</h4>
<p>](<a href="http://selenium.openqa.org/">http://selenium.openqa.org/</a>)</p>
<p>ThoughtWorks 专门为 Web 应用而开发的自动化测试工具，适合进行功能测试、验收测试 。</p>
<h4 id="jwebunit">[jWebUnit</h4>
<p>](<a href="http://jwebunit.sourceforge.net/">http://jwebunit.sourceforge.net/</a>)</p>
<p>为 Web 应用程序创建测试用例的一个开源框架，它可以容易地插入到大多数 Java IDE 中。</p>
<h3 id="last">Last</h3>
<p>啥也不说了，埋头学习吧～</p>
<p>路漫漫其修远兮，吾将上下而求索。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java笔记 使用反射来改进BaseDao</title>
      <link>https://blog.alswl.com/2009/11/note-the-use-of-java-reflection-to-improve-the-basedao/</link>
      <pubDate>Tue, 17 Nov 2009 00:00:00 +0800</pubDate>
      <guid>https://blog.alswl.com/2009/11/note-the-use-of-java-reflection-to-improve-the-basedao/</guid>
      <description>关于反射 反射的定义（via Wiki）：在计算机科学中，反射是指一种特定类型的计算机程序能够在运行时以一种依 赖于它的代码的抽象特性和它的运行时行为的方式被更改的特性。用比喻来说，那种程式能够&amp;quot;观察&amp;ldquo;并且修改自己的行为。 Java中的反射示例如下： package dddspace.job.exercise1116; public class Foo { public void fun(String str) { System.out.println(str); } } package dddspace.job.exercise1116; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class ReflectionDemo { public static void main(String[] args) throws SecurityException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { // 不使用反射 Foo foo = new Foo(); foo.fun(&amp;#34;no reflection&amp;#34;); // 使用反射 String className = &amp;#34;dddspace.job.exercise1116.Foo&amp;#34;; String funName = &amp;#34;fun&amp;#34;; // 获取类</description>
      <content:encoded><![CDATA[<h2 id="关于反射">关于反射</h2>
<p>反射的定义（via <a href="http://zh.wikipedia.org/zh-cn/%E5%8F%8D%E5%B0%84_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29">Wiki</a>）：在计算机科学中，反射是<strong>指一种特定类型的计算机程序能够在运行时以一种依
赖于它的代码的抽象特性和它的运行时行为的方式被更改</strong>的特性。用比喻来说，那种程式能够&quot;<strong>观察</strong>&ldquo;并且修改自己的行为。</p>
<p>Java中的反射示例如下：</p>
<pre tabindex="0"><code>    package dddspace.job.exercise1116;

public class Foo {

public void fun(String str) {

System.out.println(str);

}

}


    package dddspace.job.exercise1116;

import java.lang.reflect.InvocationTargetException;

import java.lang.reflect.Method;

public class ReflectionDemo {

public static void main(String[] args) throws SecurityException,

NoSuchMethodException, ClassNotFoundException, InstantiationException,

IllegalAccessException, IllegalArgumentException,

InvocationTargetException {

// 不使用反射

Foo foo = new Foo();

foo.fun(&#34;no reflection&#34;);


// 使用反射

String className = &#34;dddspace.job.exercise1116.Foo&#34;;

String funName = &#34;fun&#34;;

// 获取类名

Class cls = Class.forName(className);

// 创建Object实例

Object foo2 = cls.newInstance();

// 创建Method hello

Method method = cls.getMethod(&#34;fun&#34;, String.class);

// 使用反射来调用Method的invode方法，参数是目标对象+参数

method.invoke(foo, &#34;use reflection&#34;);

}

}
</code></pre><h2 id="原始basedao设计">原始BaseDao设计</h2>
<p>我先阐述一下BaseDao的设计想法：BaseDao是一个<strong>抽象类</strong>，提供一系列Dao方法&rdquo;<strong>get()/getAll()/add()/update()/delete()/getCount()</strong>&quot;，通过<strong>泛型匹配</strong>的获取类，我取出一个方法来做示例。</p>
<pre tabindex="0"><code>    public int getCount()
    {
    	int count = 0;
    	Session session = null;
    	Transaction tx = null;
    	String Tstr = getClass().getSimpleName().substring (0,
    			getClass().getSimpleName().length() - 3);
    	String hql = &#34;select count(*) from &#34; + Tstr;
    	try {
    		session = HibernateSessionFactory.currentSession();
    		tx = session.beginTransaction();
    		Query query = session.createQuery(hql);
    		count = Integer.parseInt(query.uniqueResult().toString());
    		query = null;
    		tx.commit();
    	} catch (HibernateException e) {
    		if (tx != null) {
    			tx.rollback();
    		}
    		throw e;
    	} finally {
    		HibernateSessionFactory.closeSession();
    	}				
    	return count;
    }
</code></pre><p>其中有一段<strong>dirty work</strong>，就是TStr的获取，这段TStr是想从实现Dao类获取实体类的类型名称，也就是
从&quot;TopicDao&quot;获取&quot;Topic&quot;这个类型名称。整个BaseDao的泛型设计不错，但是在这一段上面存在一段dirty work，始终让我不爽。</p>
<h2 id="重构basedao和topicdao">重构BaseDao和TopicDao</h2>
<p>我今天复习完抽象类/接口/反射这些内容，又在纸上画了一个模型，觉得用这种新方法解决会更好一点。</p>
<p>给抽象类BasoDao加入新的变量Class c，然后在TopicDao初始化时候对Class
c进行设置为Topic.class，这样就比原来的拼字符串好的多。耦合也显得漂亮了</p>
<pre tabindex="0"><code>    public abstract class BaseDAO&lt;T&gt; {
    	
    	protected Class c;
    	
    	private Logger logger = Logger.getLogger(this.getClass());
    	
    	/**
    	 * 根据某个Bean的beanId取出Bean
    	 * @param tId
    	 * @return Bean
    	 */
    	public T get(int tId)
    	{
    		T t=null;
    		Session session = null;
    		Transaction tx = null;
    		// 原始设计
    //		String Tstr = getClass().getSimpleName().substring (0,
    //				getClass().getSimpleName().length() - 3);
    		// 获取c的名称
    		String Tstr = c.getSimpleName();
    		String TstrId = Tstr+&#34;Id&#34;;
    		String hql = &#34;from &#34; + Tstr + &#34; where &#34; +
    			TstrId.substring(0, 1).toLowerCase() + TstrId.substring(1) + &#34; = ?&#34;;
    		try {
    			session = HibernateSessionFactory.currentSession();
    			tx = session.beginTransaction();
    			Query query = session.createQuery(hql);
    			query.setInteger(0,tId);
    			t = (T)query.uniqueResult();
    			query = null;
    			tx.commit();
    		} catch (HibernateException e) {
    			if (tx != null) {
    				tx.rollback();
    			}
    			throw e;
    		} finally {
    			HibernateSessionFactory.closeSession();
    		}		
    		return t;
    	}
    
    public class TopicDAO extends BaseDAO&lt;Topic&gt;{
    		
    	private Logger logger = Logger.getLogger(this.getClass());
    	/**
    	 * 根据froumId取出某一吧内的所有没被屏蔽的帖子
    	 * @param froumId
    	 * @return ArrayList&lt;Topic&gt; 
    	 * @throws HibernateException
    	 */
    	// 在构造函数中进行c的设置
    	public TopicDAO () {
    		c = Topic.class;
    	}
    	//doSomething
    }
</code></pre><p>这样完成之后，就完成了一次简单的重构，实现了<strong>变化点分离</strong>，而且不那么dirty。</p>
<p>本文的代码来源自PostBar项目。这里有<a href="http://code.google.com/p/postbar/">Google Code链接</a>，v1.0.1的代码并没有上文的实现，本文中的修改还在trunk中。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java入门好书《Java JDK6学习笔记》</title>
      <link>https://blog.alswl.com/2009/11/getting-started-with-java-books-java-jdk6-study-notes/</link>
      <pubDate>Mon, 16 Nov 2009 00:00:00 +0800</pubDate>
      <guid>https://blog.alswl.com/2009/11/getting-started-with-java-books-java-jdk6-study-notes/</guid>
      <description>《Java JDK6学习笔记》(via 豆瓣，via ChinaPub)是我最近在看的一本书。虽然名为Java学习笔记，其实** 深入浅出的讲解了Java这门语言。书中的语言颇有白文风格**，适合没有语言基础的同学学习，也适合对一些概念不清楚的开发人员。 我很快的翻阅了半本书，作者的范例代码简单精要(&amp;ldquo;Java笔记split/不定长度参数/泛型类型通配符&amp;rdquo;中示例代码就是改编自本书)。</description>
      <content:encoded><![CDATA[<p><a href="http://img3.doubanio.com/lpic/s2518833.jpg">




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/200911/s2518833.jpg" alt="Java JDK6学习笔记"  />


</a></p>
<p>《Java JDK6学习笔记》(via <a href="http://www.douban.com/subject/2057790/">豆瓣</a>，via
<a href="http://www.china-pub.com/34512&amp;ref=ps">ChinaPub</a>)是我最近在看的一本书。虽然名为Java学习笔记，其实**
深入浅出<strong>的讲解了Java这门语言。书中的语言颇有</strong>白文风格**，适合没有语言基础的同学学习，也适合对一些概念不清楚的开发人员。</p>
<p>我很快的翻阅了半本书，作者的范例代码简单精要(<a href="http://log4d.com/2009/11/java-notes-_split-variable-length-parameter-generic-type-wildcard">&ldquo;Java笔记split/不定长度参数/泛型类型通配符&rdquo;</a>中示例代码就是改编自本书)。我现在正在阅读线程、反射和Annotation这三块内容，看得我酣畅淋漓啊。</p>
<p>我算是概念模糊的开发者，现在准备笔试/面试所以恶补一下平时接触比较少的概念。我虽然也有《<strong>Think in
Java</strong>》这本至尊级的书，但是显然这本书研究过深，不适合快速复习。《Java JDK6学习笔记》就成了我首选了。（感谢CUMT图书馆！）</p>
<p>豆瓣简介：</p>
<blockquote>
<p>本书是作者良葛格本人近几年来学习Java的心得笔记，结构按照作者的学习脉络依次展开，从什么是Java、如何配置Java开发环境、基本的Java语法到程序
流程控制、管理类文件、异常处理、枚举类型、泛型、J2SE中标准的API等均进行了详细介绍。本书还安排了一个&quot;文字编辑器&quot;的专题制作。此外，Java
SE6的新功能，对Java lang等套件的功能加强，以及JDBC4.0、Apache Derby纯Java数据库等新增功能，本书也都予以介绍。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>本书门槛很低，只要您了解Windows基本操作，无须有其他程序语言的基础，甚至没有接触过Java，都可以通过本书扎扎实实地学习Java。而对于一些曾经学
习过Java，但概念和基础仍不扎实的读者，本书也准备了一些面向对象的观点与进阶的议题可供参考。</p>
</blockquote>
<p>作者在书中其中有几句话我颇为欣赏：</p>
<blockquote>
<p>学习一个新的事物时，如果遇到一些概念无法很快理解，这可能是因为要理解概念会需要其他概念先建立起来，所以先暂时放下这个疑问也是一个学习方法，称之为&quot;存疑&quot;
，在以后的学习过程中待必要的概念学会后，目前的疑问自然也会解开。</p>
</blockquote>
<p>下面是豆瓣<a href="http://www.douban.com/people/snable/">snable</a>的评论，深得我心。</p>
<blockquote>
<p>每当有学习java的人让我推荐书籍的时候，我都会毫不犹豫地向他推荐《Java学习笔记》。这本书的上一版是前几年读的了，当时还是按jdk1.5写的。本书最
大特点是：</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>1、内容翔实。说翔实不是说它厚，java书里有很多厚而无物的滥书，本书基本覆盖了javaSE的内容，总体说达到中偏高的层次，有些高级内容没有涉及。每一部
分都有其他书籍里没有介绍或者介绍不全面的东西，可以说言之有物。</p>
</blockquote>
<p>2、叙述清楚。对于一些易错或难易理解的概念，作者总是能用通俗的语言讲明白，而不像某些书那样&quot;遮遮掩掩&quot;。这对于初学者无疑是最有帮助的。我读这本书上一版时已经
学过java，当时的目的是为了了解jsk1.5的新变化，但在读的过程中才发现自己对很多点的理解是模糊的。所以个人认为这本书不止适合初学者。</p>
<p>3、例题有力。例题是最容易帮助我们理解问题的工具，本书的例题都非常有针对性。所选例题有一定实用性，难度适中，不是Toy Program。</p>
<blockquote>
</blockquote>
<blockquote>
<p>每个人的理解方向不一样，不可能有一本书适合所有学习者，但我坚信好书最终总会被大多数人承认的，这也是我推荐此书的目的。书的价格略高，但物有所值，有条件可以
去图书馆借或者读电子版。</p>
</blockquote>
<p>另外再多写几句吧，其他推荐的java书籍还有两本：</p>
<blockquote>
</blockquote>
<blockquote>
<p>1、《Java2核心技术》，此书分上下两卷（基础、高级），优点在于层次比上边那本书要高，话说回来，书也厚了一倍，适合当手册用。此书版本变化频繁，现在已经
到了中文第八版，但个人感觉没有超越第六版翻译的高度。</p>
</blockquote>
<p>2、《Java编程思想》，大名鼎鼎，作者对java的理解程度让人五体投地，优点是就是内容相当深入。个人认为本书试图一次性全面解释清楚某些问题，不适合初学者读
。这种书必须长期反复地阅读，常读常新。</p>
<blockquote>
</blockquote>
<blockquote>
<p>再多说一句吧，有一本《JAVA实例技术手册》是我买过最失败的一本书，缺点在于：1、内容不深入；2实例没有想象中的实用，或者有的根本就没有实用价值。</p>
</blockquote>
<p>如果你还没有学过Java却想学，我强烈推荐此书。￥59.9绝对物有所值，呃，电子书嘛，给个<a href="http://www.google.cn/search?hl=zh-CN&amp;newwindow=1&amp;q=Java+JDK6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0+%E7%94%B5%E5%AD%90%E4%B9%A6&amp;btnG=Google+%E6%90%9C%E7%B4%A2&amp;aq=f&amp;oq=">Google搜索链接</a>吧。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Java笔记 split/不定长度参数/泛型类型通配符</title>
      <link>https://blog.alswl.com/2009/11/java-notes-_split-variable-length-parameter-generic-type-wildcard/</link>
      <pubDate>Sun, 15 Nov 2009 00:00:00 +0800</pubDate>
      <guid>https://blog.alswl.com/2009/11/java-notes-_split-variable-length-parameter-generic-type-wildcard/</guid>
      <description>今天看了一下午《Java学习笔记》，作者林信良，花名良葛格。从书中所获颇 多，正所谓温故而知新，我就把今天的&amp;quot;新&amp;quot;总结一下，加深记忆。良葛格也提倡&amp;quot;在网上写文章是我记录所学的一种方式&amp;quot;。 split的正则式和其中的正则式 C语言其中有函数strtok，就是按某些char对字符串进行切割。下面给出一个C下面的范例 char str[] = &amp;#34;now # is the time for all # good men to come to the # aid of their country&amp;#34;; char delims[] = &amp;#34;#&amp;#34;; char</description>
      <content:encoded><![CDATA[<p>今天看了一下午《<a href="http://www.douban.com/subject/2057790/">Java学习笔记</a>》，作者林信良，花名良葛格。从书中所获颇
多，正所谓温故而知新，我就把今天的&quot;新&quot;总结一下，加深记忆。良葛格也提倡&quot;在网上写文章是我记录所学的一种方式&quot;。</p>
<h2 id="split的正则式和其中的正则式">split的正则式和其中的正则式</h2>
<p>C语言其中有函数strtok，就是按某些char对字符串进行切割。下面给出一个C下面的范例</p>
<pre tabindex="0"><code>    char str[] = &#34;now # is the time for all # good men to come to the # aid of their country&#34;;
    char delims[] = &#34;#&#34;;
    char *result = NULL;

result = strtok( str, delims );

while( result != NULL ) {

printf( &#34;result is &#34;%s&#34;n&#34;, result );

result = strtok( NULL, delims );

}
</code></pre><p>在Java中也有类似的StringTokenizer，但是在JDK5中，已经被标记为Legacy
Class(遗产类)，推荐使用String.split(String regex)，可以接受正则表达式。范例如下。</p>
<pre tabindex="0"><code>    private void init() {
    	Scanner scanner = new Scanner(System.in);

System.out.println(&#34;input n and data&#34;);

n = scanner.nextInt();

data = new int[n];

String input = scanner.next().trim();

//String[] strData = splitByTokenizer(input);

String[] strData = input.split(&#34;[,\s]&#34;);

int i = 0;

for (String t : strData) {

data[i] = Integer.parseInt(t);

i++;

}

}

//已过时，Legacy Class(遗产类)

private String[] splitByTokenizer (String input, String regex) {

String [] result = null;

if (input != null &amp;&amp; !input.equals(&#34;&#34;)) {

StringTokenizer commaToker = new StringTokenizer(input, &#34;,&#34;);

result = new String[commaToker.countTokens()];

int i = 0;

while (commaToker.hasMoreTokens())

{

result[i] = commaToker.nextToken();

i++;

}

}

return result;

}
</code></pre><h2 id="不定长度参数">不定长度参数</h2>
<p>听名字这东西就相当有用，也是JDK5开始支持的。（话说现在都JDK6.0了，我们很多童鞋对Java的概念还停留在最开始，其中也包括我，咱们要与时俱进嘛）直接
上代码，就知道怎么用了。</p>
<pre tabindex="0"><code>package dddspace.job.exercise1115;

/**

* 使用不定长度参数  
* 参考《Java学习笔记》P153相关内容  
*   
*/  
public class VarArgs {

public static void main(String[] args) {


int sum = 0;

sum = VarArgs.sum(1, 2);

System.out.println(sum);


sum = VarArgs.sum(1, 3, 5, 7);

System.out.println(sum);

}

//关键在 &#34;int...&#34;

private static int sum(int... nums) {

int sum = 0;

for (int num : nums) {

sum += num;

}

return sum;

}

}
</code></pre><h2 id="泛型类型通配符">泛型类型通配符</h2>
<p>如果你还不知道泛型是什么，那么最好补一下基础(via [Baidu Zhidao](<a href="http://baike.baidu.com/view/965887.h">http://baike.baidu.com/view/965887.h</a>
tml?wtp=tt))，这个在C++中运用广泛，在JDK5.0加入Java大家族。我这里要解释的是泛型类型的通配符，呃，有点绕口。其实就是让泛型T这个T通
过支持一个接口来支持其实现类。</p>
<p>咱们还是让代码来反应思想吧。</p>
<pre tabindex="0"><code>package dddspace.job.exercise1115;

import java.util.ArrayList;

import java.util.LinkedList;

import java.util.List;

/**

* 泛型类型通配符  
* 参考《Java学习笔记》P249相关内容  
*  
*/  
public class WildcardTest&lt;T&gt; {

public static void main(String[] args) {


/*想定义泛型为List接口，错误

WildcardTest&lt;List&gt; wildcardTestW= null;

wildcardTestW = new WildcardTest&lt;ArrayList&gt;();

wildcardTestW = new WildcardTest&lt;LinkedList&gt;();

*/  

//关键词 &#34;&lt;? extends Class&gt;&#34;匹配正确

WildcardTest&lt;? extends List&gt; wildcardTest= null;

wildcardTest = new WildcardTest&lt;ArrayList&gt;();

wildcardTest = new WildcardTest&lt;LinkedList&gt;();

}

}
</code></pre><h2 id="补遗关于stringstringbuilderstringbuffer">补遗：关于String/StringBuilder/StringBuffer</h2>
<p>简单来说，String是不可变的，每次都是指向不同的内存空间。StringBuilder是可变的，线程不安全。StringBuffer是可变的并且线程安全。
StringBuilder是JDK5.0加入的。（今天5.0开心了，都是推它的）</p>
<p>A.shun有一篇关于String/StringBuilder/StringBuffer的文，可以移步到<a href="http://www.a18zhizao.cn/y2009/1060_string-stringbuffer-and-stringbuilders-the-difference.html">这里</a>看详细介绍。</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用XOM类库对Java对象进行序列化</title>
      <link>https://blog.alswl.com/2009/06/xom-class-library-to-use-java-objects-serialization/</link>
      <pubDate>Wed, 10 Jun 2009 00:00:00 +0800</pubDate>
      <guid>https://blog.alswl.com/2009/06/xom-class-library-to-use-java-objects-serialization/</guid>
      <description>校内工具需要保存用户名和帐号，我就想把帐号信息作为一个XiaoneiUser类，然后对其进行对象持久化。 Google下的方法有好几种方法进行持久化，JDOM， DOM4J, SAX等。我看了之后，感觉都比较麻烦，我个人比较喜欢使用jdk自带的工具，但是查阅jdk api之后，感觉使用 javax.xml.* 下工具开发更加困难。 我仅仅是需要对一个简单的对象进行持久化来保存数据，并不需要太多太复杂的功能。最后我决定使用《Thinking in</description>
      <content:encoded><![CDATA[<p>校内工具需要保存用户名和帐号，我就想把帐号信息作为一个XiaoneiUser类，然后对其进行对象持久化。
Google下的方法有好几种方法进行持久化，JDOM， DOM4J,
SAX等。我看了之后，感觉都比较麻烦，我个人比较喜欢使用jdk自带的工具，但是查阅jdk api之后，感觉使用 <code>javax.xml.*</code> 下工具开发更加困难。
我仅仅是需要对一个简单的对象进行持久化来保存数据，并不需要太多太复杂的功能。最后我决定使用《Thinking in Java》推荐的开源类库：XOM
<a href="http://www.xom.nu">猛击这里打开www.xom.nu</a> 友情提示一下，网站可以打开，但是下载的连接貌似被墙了，至少我教育网连不上去。推荐
一个在线代理服务器古狗在线代理（<a href="http://www.ggproxy.com/">猛击这里打开</a>），通过它就可以下载类库了。
使用类库非常简单，我这里提供个小例子。XiaoneiUser类</p>
<pre tabindex="0"><code>package cn.dddspace.xiaonei.bean;

import java.io.OutputStream;

import nu.xom.*;

public class XiaoneiUser {

    /**

    * 用户Email  
    */
    private String userEmail;

    /**

    * 用户Password  
    */
    private String userPassword;

    public String getUserEmail() {

        return userEmail;

    }

    public void setUserEmail(String userEmail) {

        this.userEmail = userEmail;

    }

    public String getUserPassword() {

        return userPassword;

    }

    public void setUserPassword(String userPassword) {

        this.userPassword = userPassword;

    }

    /**

    * 将类转换为XML  
    *   
    * @return  
    */
    public Element getXML() {

        Element userE = new Element(&#34;xiaoneiUser&#34;);

        Element userEmailE = new Element(&#34;userEmail&#34;);

        userEmailE.appendChild(userEmail);

        Element userPasswordE = new Element(&#34;userPassword&#34;);

        userPasswordE.appendChild(userPassword);

        userE.appendChild(userEmailE);

        userE.appendChild(userPasswordE);

        return userE;

    }

    /**

    * 复制构造函数  
    *   
    * @param xiaoneiUser  
    */
    public XiaoneiUser(Element xiaoneiUser) {

        userEmail = xiaoneiUser.getFirstChildElement(&#34;userEmail&#34;).getValue();

        userPassword = xiaoneiUser.getFirstChildElement(&#34;userPassword&#34;)

            .getValue();

    }

    /**

    * 构造函数  
    *   
    * @param userEmail  
    * @param userPassword  
    */
    public XiaoneiUser(String userEmail, String userPassword) {

        this.userEmail = userEmail;

        this.userPassword = userPassword;

    }

    /**

    * Format输出函数  
    *   
    * @param os  
    * @param doc  
    * @throws Exception  
    */
    public void format(OutputStream os, Document doc) throws Exception {

        Serializer serializer = new Serializer(os, &#34;UTF-8&#34;);

        serializer.setIndent(4);

        serializer.setMaxLength(60);

        serializer.write(doc);

        serializer.flush();

    }

}
</code></pre><p>Test类入口函数</p>
<pre tabindex="0"><code>/**
 * @title Test.java
 * @author ddd
 * @time 2009-6-10 16:35:36
 * @site http://log4d.com
 */
package cn.dddspace.xiaonei.test;

import java.io.BufferedOutputStream;

import java.io.File;

import java.io.FileNotFoundException;

import java.io.FileOutputStream;

import cn.dddspace.xiaonei.bean.XiaoneiUser;

import nu.xom.*;

public class Test {

/**

* @param args  
* @throws Exception   
* @throws FileNotFoundException   
*/  
public static void main(String[] args) throws FileNotFoundException, Exception
{

XiaoneiUser user = new XiaoneiUser(&#34;a@a.com&#34;, &#34;123&#34;);

  
//序列化user为xml文档

Document doc = new Document(user.getXML());

//输出到屏幕

user.format(System.out, doc);

//输出到XML文件user.xml

user.format(new BufferedOutputStream(new FileOutputStream(

&#34;user.xml&#34;)), doc);

  
//反序列化XML文件为XiaoneiUser对象

Document doc2 = new Builder().build(&#34;user.xml&#34;);

Element element = doc2.getRootElement();

XiaoneiUser user2 = new XiaoneiUser(element);

//输出对象信息，验证对象

System.out.println(user2.getUserEmail());

System.out.println(user2.getUserPassword());

}

}
</code></pre><p>代码非常简单，如果要进行简单的对象序列化，我觉得这个400kb的类库非常实用</p>
]]></content:encoded>
    </item>
    <item>
      <title>java.net.*操作session/GET/POST方法</title>
      <link>https://blog.alswl.com/2009/06/java-net-operation-session-get-post-method/</link>
      <pubDate>Tue, 09 Jun 2009 00:00:00 +0800</pubDate>
      <guid>https://blog.alswl.com/2009/06/java-net-operation-session-get-post-method/</guid>
      <description>终于又考完一门试，开始做课程设计了，结果课程设计给工作室一个尾气3个月的项目，而这次的先用我写的贴吧放上去，我变得暂时空闲了，开始着手写校内开心农场小工具- 全能拖拉机。 首先要解决的就是校内登录的问题，那就是Get/Post方法了，还有用户状态保存，就是session的操作。Java不同于C#，那位可以集成系统 的浏览器或者之间创建一个Browser。 开始写了自己的第一个版本。 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.MalformedURLException; import java.net.ProtocolException; import java.net.URL;</description>
      <content:encoded><![CDATA[<p>终于又考完一门试，开始做课程设计了，结果课程设计给工作室一个尾气3个月的项目，而这次的先用我写的贴吧放上去，我变得暂时空闲了，开始着手写校内开心农场小工具-
全能拖拉机。 首先要解决的就是校内登录的问题，那就是Get/Post方法了，还有用户状态保存，就是session的操作。Java不同于C#，那位可以集成系统
的浏览器或者之间创建一个Browser。</p>
<p>开始写了自己的第一个版本。</p>
<pre tabindex="0"><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.ProtocolException;
import java.net.URL;
import java.net.HttpURLConnection;

public class FarmerHelper {

/**

* @param args  
* @throws ProtocolException  
*/  
public static void main(String[] args) throws ProtocolException {

String loginUrlStr = &#34;http://login.xiaonei.com/Login.do&#34;;

String homeUrlStr = &#34;http://home.xiaonei.com/Home.do&#34;;

URL loginUrl = null;

URL homeUrl = null;

HttpURLConnection loginConn = null;

HttpURLConnection homeConn = null;

try {

loginUrl = new URL(loginUrlStr);

homeUrl = new URL(homeUrlStr);

try {

loginConn = (HttpURLConnection) loginUrl.openConnection();

homeConn = (HttpURLConnection) homeUrl.openConnection();

} catch (IOException e) {

print(&#34;Conn&#39;t open the url connection!&#34;);

e.printStackTrace();

}

} catch (MalformedURLException e) {

print(&#34;Illegal URL!&#34;);

e.printStackTrace();

return;

}

loginConn.setRequestMethod(&#34;POST&#34;);

loginConn.setRequestProperty(&#34;User-Agent&#34;,

&#34;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.0.10)&#34;

+ &#34; Gecko/2009042316 Firefox/3.0.10&#34;);

loginConn.setRequestProperty(&#34;Keep-Alive&#34;, &#34;300&#34;);

loginConn.setRequestProperty(&#34;Connection&#34;, &#34;keep-alive&#34;);

loginConn.setRequestProperty(&#34;email&#34;, &#34;alswlwangzi@163.com&#34;);

loginConn.setRequestProperty(&#34;password&#34;, &#34;xh77Gffb_i&#34;);

loginConn.setRequestProperty(&#34;submit&#34;, &#34;登录&#34;);

loginConn.setRequestProperty(&#34;Keep-Alive&#34;, &#34;300&#34;);

try {

loginConn.connect();

String headerName = null;

String cookie = &#34;&#34;;

/*

* for (int i=0; (headerName =  
* loginConn.getHeaderFieldKey(i))!=null; i++) { if  
* (headerName.equals(&#34;Set-Cookie&#34;)) { cookie =  
* loginConn.getHeaderField(i); print(cookie); } }  
*/  
cookie = loginConn.getHeaderField(&#34;Set-Cookie&#34;);

print(cookie);

homeConn.setRequestProperty(&#34;Cookie&#34;, cookie);

homeConn.setRequestMethod(&#34;GET&#34;);

homeConn.connect();

BufferedReader in = new BufferedReader(new InputStreamReader(

homeConn.getInputStream()));

String lineStr = null;

while ((lineStr = in.readLine()) != null) {

// print(lineStr);

print(new String(lineStr.getBytes(&#34;GBK&#34;), &#34;UTF-8&#34;));

}

} catch (IOException e) {

print(&#34;conn&#39;t connect to the server!&#34;);

e.printStackTrace();

}

}

private static void print(Object o) {

System.out.println(o);

}

}
</code></pre><p>想法总是好的，现实总是残酷的，调试很久，用WireShark抓包，都是有Length
Required错误，这个比较头疼，我感觉是我session传递的问题（其实不是，后来发现是Post的格式问题），于是网上找来一个Session操作类。</p>
<p><a href="../../static/images/upload_dropbox/200906/cookiemanager.java">猛击这里下载cookiemanager</a> 同时你可以参考这个类作者的文章
<a href="http://www.hccp.org/java-net-cookie-how-to.html">猛击这里打开HOW-TO: Handling cookies using the java.net.* API</a>，谢谢这位外国朋友的帮助。 可惜尽管有这个外国朋友帮助，我写了第二个版本，仍然遇到了相同问题，Length
Required&hellip; 崩溃了，开始查找网络编程书，同时参考WireShark的抓包，我惊讶的发现，我把数据域写到了Headers里面去了。
这个致命性的错误导致服务器不能找到正确的数据，并且没有提供数据域的大小Content-Length，所以导致服务器报错。
最后再借花献佛，送上一个完整操作Http GET/POST的类<a href="../../static/images/upload_dropbox/200906/httprequestproxy.java">猛击这里下载httprequestproxy</a>依然感谢原作者，</p>
<p><a href="http://benlsoft.javaeye.com/blog/97059">猛击这里打开原文链接</a>友情提示一下，这个类是07年写的，里面有一些注释说明在1.4和1.5下几个参数不一样，我没有亲测，建议使用1.5
的设置 嗯，有这两个类，明天工作应该会轻松一些，继续fighting!</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
