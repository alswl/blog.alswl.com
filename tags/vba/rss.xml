<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Vba on Log4D</title>
    <link>https://blog.alswl.com/tags/vba/</link>
    <description>Recent content in Vba on Log4D</description>
    <generator>Hugo -- 0.129.0</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 14 Dec 2010 00:00:00 +0800</lastBuildDate>
    <atom:link href="https://blog.alswl.com/tags/vba/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C#&#43;VBA操作Excel总结</title>
      <link>https://blog.alswl.com/2010/12/csharp-vba-excel/</link>
      <pubDate>Tue, 14 Dec 2010 00:00:00 +0800</pubDate>
      <guid>https://blog.alswl.com/2010/12/csharp-vba-excel/</guid>
      <description>Excel在日常办公中应用非常广泛，这次我接到一个案子，需要往Excel中写入数据并能够打印出固定格式，前前后后大概花了将近2星期才搞定，现在做一些分享。 一、关于操作Excel的几种方式 我们导出Excel，大抵是有两种方法，一种是在服务器端用一些类库或者COM组件直接生成Excel成品，其二是在后台只写入数据，而不写入具体格式，等用户下载完 Excel之后再在客户端上利用vba生成Excel成品。 1</description>
      <content:encoded><![CDATA[<p>Excel在日常办公中应用非常广泛，这次我接到一个案子，需要往Excel中写入数据并能够打印出固定格式，前前后后大概花了将近2星期才搞定，现在做一些分享。</p>
<h2 id="一关于操作excel的几种方式">一、关于操作Excel的几种方式</h2>
<p>我们导出Excel，大抵是有两种方法，一种是在服务器端用一些类库或者COM组件直接生成Excel成品，其二是在后台只写入数据，而不写入具体格式，等用户下载完
Excel之后再在客户端上利用vba生成Excel成品。</p>
<h3 id="11使用自动化功能-后台生成成品">1.1使用&quot;自动化&quot;功能-后台生成成品</h3>
<p>微软把后台使用COM组件称之为&quot;自动化&quot;，其实它本身是不建议这种用法，在<a href="http://support.microsoft.com/kb/257757">257757 号文章（服务器端 Office自动化注意事项）</a>也明文标出&quot;Microsoft
目前建议不要从任何无人参与的、非交互式客户端应用程序或组件（包括 ASP、DCOM 和 NT Service）中进行 Microsoft Office
应用程序的&quot;自动化&quot;，也不为此提供支持，因为 Office 在这种环境中运行时可能会出现不稳定的现象并且/或者会死锁。&quot;</p>
<p>这种方法的优点是给用户更简洁的展现，毕竟原生的Excel成品比半成品来更容易接受，而且可以避免宏安全问题，万一客户端禁止了宏，就只能看到丑陋的模板界面+一坨
数据。</p>
<p>缺点是需要服务端支持，编写成本也比较高（VBA有时候可以直接录制）。服务端支持体现在需要安装一些微软或者第三方的类库。我当时采用的是Office类库，也就是
在安装有Office的机器上面使用Interop.Excel.dll这个中间动态链接库进行操作，需要麻烦的安全设置，效率低不说还会扯出Excel无法关闭的B
ug。</p>
<p>关于效率低我深有体会，我使用这种方法生成5页数据大约2m，客户等的急死，其根本原因是由于COM组件在调用时候，每一个Range这种对象都会产生一个借口请求。</p>
<h3 id="12使用adonet传输数据vba控制模板和数据">1.2、使用ADO.net传输数据+VBA控制模板和数据</h3>
<p>这方法的优缺点正好与上文相反，由于只是写入数据，即通过ADO.net的连接方式INSERT一堆数据到Excel文件的隐藏Sheet里面去（别跟我说你不知道E
xcel可以隐藏某个Sheet），所以速度后台速度极快。前台Excel文件虽然需要VBA编程支持，但是在理解Excel模型之后也不是很难的事情。</p>
<h3 id="13">1.3</h3>
<p>选择哪种方式，取决于你的需求，如果你在Java平台下面并且输出文件页面格式不复杂，我推荐第一种，如果是.net平台又或者要处理复杂的页面样式，就选用第二种吧
（我前期使用第一种，后来因为效率问题和无法关闭Excel的问题，重写逻辑，选用第二种）。</p>
<p>关于Excel导出方案的选择，微软官方也是不建议使用第一种方案，甚至不提供技术支持。它推荐了一些方案，包括使用报表导出Excel或者ADO.net方式导出（
即第二种），具体文章见<a href="http://support.microsoft.com/kb/306023/zh-cn">如何使用 Visual C# 2005 或 Visual C# .NET 向 Excel 工作簿传输数据</a>。</p>
<h2 id="二office-excel文档模型">二、Office Excel文档模型</h2>
<p>在写操作Excel代码之前，需要了解一下Excel的文档模型，才能想当然的把代码写出来。</p>
<p>简单说来，我们只要了解Application 、Workbook 、Worksheet
、Range这四种类型，如果需要操作图像的话，还需要多了解一种Chart。</p>
<p>Application就是Excel实例，不仅仅是一个Excel文件，而是整体的Excel程序（Office都是MDI文档体系）。</p>
<p>WorkBook就是实质意义上的某个Excel文件，你可以进行保存操作等等。</p>
<p>Worksheet是某个工作簿类型。</p>
<p>Range是我们打交道最多的，可以理解成一个区域快，也就是常见的&quot;A2:B5&quot;这种表示方式。</p>
<p>了解这几种之后，我们就可以下手操作了。更详细的微软官方文档，可以在<a href="http://msdn.microsoft.com/zh-cn/library/wss56bz7(v=vs.80).aspx">Excel 对象模型概述</a>找到。</p>
<h2 id="三使用c操作excel">三、使用C#操作Excel</h2>
<p>我虽然不推荐第一种，但是毕竟是一种解决方案。</p>
<p>需要使用的命名空间为using Excel = Microsoft.Office.Interop.Excel;（使用别名简化一下）</p>
<p>另外需要项目引用Office的类库，如果不是项目形式而是网站形式，则需要手动编译对应Interop.Excel.dll到网站bin目录下面，我使用Excel
2007编译出这个链接库，版本为1.6.0.0，需要的可以点击<a href="../../static/images/2010/12/Interop_Excel.zip">Interop.Excel.dll</a>下载。</p>
<h3 id="31-编译interopexceldll">3.1 编译Interop.Excel.dll</h3>
<p>编译的方法出自于&quot;[使用Office组件读取Excel，引用Microsoft.Office.Interop.Excel出现的问题](http://www.
cnblogs.com/Mainz/archive/2009/11/11/Microsoft_Office_Interop_Excel.html)&quot;&amp;nbs
p_place_holder;</p>
<blockquote>
<p>进入你的visual studio的sdk下的bin目录，找到TlbImp.exe文件，如果没有，请用光盘安装此文件，详细说明请参照MSDN。&amp;nbsp
_place_holder;</p>
</blockquote>
<p>命令行(cmd)进入bin目录，运行TlbImp /out:Interop.Excel.dll
Office安装目录+Excel.exe</p>
<p>此时很可能会报错：TlbImp  error:  Unable
to  locate  input
type  library:
&lsquo;c:program filesmcrosoft officeofficeEXCEL.EXE&rsquo;</p>
<blockquote>
</blockquote>
<blockquote>
<p>此问题很有可能是TlbImp的bug，不支持空格式的路径；（具体原因不明）不要紧，将Excel.exe拷贝入bin目录，直接运行TlbImp
/out:Interop.Excel.dll Excel.exe,提示&quot;Type library imported to
Interop.Excel.dll路径&quot;</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>在bin目录下找到Interop.Excel.dll文件。在你的visual studio里将其引用即可。</p>
</blockquote>
<h3 id="32-封装的一个c操作excel类库">3.2 封装的一个C#操作Excel类库</h3>
<p>我把我之前封装的C#操作Excel类库分享一下</p>
<p>注：这个类的Dispose仍然没有解决Excel文件生成之后Excel进程无法正常关闭的问题，目前看来只有杀死进程方法才能起实质性作用。</p>
<p>其实我觉得这个类库除了让我熟悉一下Excel模型之外，并没派上实质的用场~</p>
<pre><code>/// &lt;summary&gt;
/// Excel帮助类
/// Add by alswl 20101130
/// &lt;/summary&gt;
public class ExcelHelper : IDisposable
{
    private Excel._Application excelApplication = null;
    public Excel._Workbook workbook = null;
    public Excel._Worksheet worksheet = null;
    private object missing = System.Reflection.Missing.Value;
</code></pre>
<p>public ExcelHelper()</p>
<p>{</p>
<p>if (excelApplication == null)</p>
<p>{</p>
<p>excelApplication = new Excel.ApplicationClass();</p>
<p>}</p>
<p>}</p>
<p>/// <summary></p>
<p>/// ~</p>
<p>/// </summary></p>
<p>~ExcelHelper()</p>
<p>{</p>
<p>if (excelApplication != null)</p>
<p>excelApplication.Quit();</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 释放非托管资源</p>
<p>/// </summary></p>
<p>public void Dispose()</p>
<p>{</p>
<p>try</p>
<p>{</p>
<p>if (excelApplication != null)</p>
<p>{</p>
<p>if (!workbook.Saved)</p>
<p>this.Close(false);</p>
<p>excelApplication.Quit();</p>
<p>System.Runtime.InteropServices.Marshal.ReleaseComObject(worksheet);</p>
<p>System.Runtime.InteropServices.Marshal.ReleaseComObject(workbook);</p>
<p>System.Runtime.InteropServices.Marshal.ReleaseComObject(excelApplication);</p>
<p>GC.Collect(System.GC.GetGeneration(worksheet));</p>
<p>GC.Collect(System.GC.GetGeneration(workbook));</p>
<p>GC.Collect(System.GC.GetGeneration(excelApplication));</p>
<p>if (excelApplication != null)</p>
<p>{</p>
<p>excelApplication = null;</p>
<p>}</p>
<p>GC.WaitForPendingFinalizers();</p>
<p>GC.Collect();</p>
<p>GC.WaitForPendingFinalizers();</p>
<p>GC.Collect();</p>
<p>}</p>
<p>}</p>
<p>catch</p>
<p>{</p>
<p>}</p>
<p>finally</p>
<p>{</p>
<p>GC.Collect();</p>
<p>}</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 设置当前工作表</p>
<p>/// </summary></p>
<p>public int CurrentWorksheetIndex</p>
<p>{</p>
<p>set</p>
<p>{</p>
<p>if (value &lt;= 0 || value &gt; workbook.Worksheets.Count)</p>
<p>throw new ArgumentException(&ldquo;索引超出范围&rdquo;);</p>
<p>else</p>
<p>{</p>
<p>object index = value;</p>
<p>worksheet = workbook.Worksheets[index] as Excel._Worksheet;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 打开一个Excel工作薄</p>
<p>/// </summary></p>
<p>/// <param name="fileName"></param></p>
<p>public void OpenWorkbook(string fileName)</p>
<p>{</p>
<p>workbook = excelApplication.Workbooks.Open(fileName, missing, missing,
missing, missing, missing,</p>
<p>missing, missing, missing, missing, missing, missing, missing, missing,
missing);</p>
<p>if (workbook.Worksheets.Count &gt; 0)</p>
<p>{</p>
<p>int index = 1;</p>
<p>worksheet = workbook.Worksheets[index] as Excel._Worksheet;</p>
<p>}</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 添加一个工作表</p>
<p>/// </summary></p>
<p>/// <param name="SheetName"></param></p>
<p>/// <returns></returns></p>
<p>public Excel.Worksheet AddSheet(string sheetName)</p>
<p>{</p>
<p>Excel.Worksheet worksheet =
(Excel.Worksheet)workbook.Worksheets.Add(Type.Missing, Type.Missing,
Type.Missing, Type.Missing);</p>
<p>worksheet.Name = sheetName;</p>
<p>return worksheet;</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 删除一个Sheet</p>
<p>/// </summary></p>
<p>/// <param name="sheetName"></param></p>
<p>public void DeleteSheet(string sheetName)</p>
<p>{</p>
<p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p>
<p>excelApplication.DisplayAlerts = false;</p>
<p>sheet.Delete();</p>
<p>excelApplication.DisplayAlerts = true;</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 保存数据</p>
<p>/// </summary></p>
<p>public void Save()</p>
<p>{</p>
<p>if (workbook != null)</p>
<p>{</p>
<p>workbook.Save();</p>
<p>}</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 关闭文档</p>
<p>/// </summary></p>
<p>/// <param name="isSave"></param></p>
<p>public void Close(bool isSave)</p>
<p>{</p>
<p>object obj_Save = isSave;</p>
<p>workbook.Close(obj_Save, missing, missing);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 设置当前工作表中某单元格的值</p>
<p>/// </summary></p>
<p>/// <param name="range"></param></p>
<p>/// <param name="value"></param></p>
<p>public void SetRangeValue(string range, object value)</p>
<p>{</p>
<p>SetRangeValue(worksheet.Name, range, value);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 设置工作表中某单元格的值</p>
<p>/// </summary></p>
<p>/// <param name="sheetName"></param></p>
<p>/// <param name="range"></param></p>
<p>/// <param name="value"></param></p>
<p>public void SetRangeValue(string sheetName, string range, object value)</p>
<p>{</p>
<p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p>
<p>sheet.get_Range(range, missing).Value2 = value;</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 删除某个Range，右侧左移</p>
<p>/// </summary></p>
<p>/// <param name="sheetName"></param></p>
<p>/// <param name="rangeStr"></param></p>
<p>public void DeleteRange(string sheetName, string rangeStr)</p>
<p>{</p>
<p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p>
<p>sheet.get_Range(rangeStr,
missing).Delete(Excel.XlDeleteShiftDirection.xlShiftToLeft);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 删除某个Range，右侧左移</p>
<p>/// </summary></p>
<p>/// <param name="sheetName"></param></p>
<p>/// <param name="rangeStr"></param></p>
<p>public void DeleteRange(string rangeStr)</p>
<p>{</p>
<p>DeleteRange(worksheet.Name, rangeStr);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 合并单元格</p>
<p>/// </summary></p>
<p>/// <param name="sheetName"></param></p>
<p>/// <param name="range1"></param></p>
<p>/// <param name="range2"></param></p>
<p>public void Merge(string sheetName, string range1, string range2)</p>
<p>{</p>
<p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p>
<p>Excel.Range range = worksheet.get_Range(range1, range2);</p>
<p>range.Merge(true);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 合并单元格</p>
<p>/// </summary></p>
<p>/// <param name="range1"></param></p>
<p>/// <param name="range2"></param></p>
<p>public void Merge(string range1, string range2)</p>
<p>{</p>
<p>Merge(worksheet.Name, range1, range2);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 设置一个单元格的属性</p>
<p>/// </summary></p>
<p>/// <param name="sheetName"></param></p>
<p>/// <param name="range"></param></p>
<p>/// <param name="size">大小</param></p>
<p>/// <param name="name">字体</param></p>
<p>/// <param name="color">颜色</param></p>
<p>/// <param name="HorizontalAlignment">对齐方式</param></p>
<p>public void SetCellProperty(string sheetName, string rangeStr, double
fontSize, string fontName,</p>
<p>double height, Excel.Constants horizontalStyle)</p>
<p>{</p>
<p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p>
<p>Excel.Range range = sheet.get_Range(rangeStr, missing);</p>
<p>range.Font.Size = fontSize;</p>
<p>range.Font.Name = fontName;</p>
<p>//range.Font.Color = fontColor;</p>
<p>range.RowHeight = height;</p>
<p>range.HorizontalAlignment = horizontalStyle;</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 设置一个单元格的属性</p>
<p>/// </summary></p>
<p>/// <param name="range"></param></p>
<p>/// <param name="fontSize"></param></p>
<p>/// <param name="fontName"></param></p>
<p>/// <param name="fontColor"></param></p>
<p>/// <param name="horizontalStyle"></param></p>
<p>public void SetCellProperty(string range, double fontSize, string fontName,</p>
<p>double height, Excel.Constants horizontalStyle)</p>
<p>{</p>
<p>SetCellProperty(worksheet.Name, range, fontSize, fontName,</p>
<p>height, horizontalStyle);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 设定Range的边框格式</p>
<p>/// </summary></p>
<p>/// <param name="rangeStart"></param></p>
<p>/// <param name="rangeEnd"></param></p>
<p>/// <param name="topStyle"></param></p>
<p>/// <param name="rightStyle"></param></p>
<p>/// <param name="bottomStyle"></param></p>
<p>/// <param name="leftStyle"></param></p>
<p>public void SetRangeBorderStyle(string sheetName, string rangeStr,
Excel.XlLineStyle topStyle,</p>
<p>Excel.XlLineStyle rightStyle, Excel.XlLineStyle bottomStyle, Excel.XlLineStyle
leftStyle)</p>
<p>{</p>
<p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p>
<p>Excel.Range range = sheet.get_Range(rangeStr, missing);</p>
<p>range.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeTop].LineSty
le = topStyle;</p>
<p>range.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeRight].LineS
tyle = rightStyle;</p>
<p>range.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeBottom].Line
Style = bottomStyle;</p>
<p>range.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeLeft].LineSt
yle = leftStyle;</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 设定Range的边框格式</p>
<p>/// </summary></p>
<p>/// <param name="rangeStr"></param></p>
<p>/// <param name="topStyle"></param></p>
<p>/// <param name="rightStyle"></param></p>
<p>/// <param name="bottomStyle"></param></p>
<p>/// <param name="leftStyle"></param></p>
<p>public void SetRangeBorderStyle(string rangeStr, Excel.XlLineStyle topStyle,</p>
<p>Excel.XlLineStyle rightStyle, Excel.XlLineStyle bottomStyle, Excel.XlLineStyle
leftStyle)</p>
<p>{</p>
<p>SetRangeBorderStyle(worksheet.Name, rangeStr, topStyle,</p>
<p>rightStyle, bottomStyle, leftStyle);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 设定Range数字格式</p>
<p>/// </summary></p>
<p>/// <param name="sheetName"></param></p>
<p>/// <param name="rangeStr"></param></p>
<p>/// <param name="format"></param></p>
<p>public void SetRangeNumberFormat(string sheetName, string rangeStr, string
format)</p>
<p>{</p>
<p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p>
<p>Excel.Range range = sheet.get_Range(rangeStr, missing);</p>
<p>range.NumberFormat = format;//0%</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 设定Range数字格式</p>
<p>/// </summary></p>
<p>/// <param name="rangeStr"></param></p>
<p>/// <param name="format"></param></p>
<p>public void SetRangeNumberFormat(string rangeStr, string format)</p>
<p>{</p>
<p>SetRangeNumberFormat(worksheet.Name, rangeStr, format);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 将数据表格添加到Excel指定工作表的指定位置</p>
<p>/// </summary></p>
<p>/// <param name="dt"></param></p>
<p>/// <param name="ws"></param></p>
<p>/// <param name="startX"></param></p>
<p>/// <param name="startY"></param></p>
<p>public void AddTable(System.Data.DataTable dt, int startX, int startY)</p>
<p>{</p>
<p>for (int i = 0; i &lt;= dt.Rows.Count - 1; i++)</p>
<p>{</p>
<p>for (int j = 0; j &lt;= dt.Columns.Count - 1; j++)</p>
<p>{</p>
<p>worksheet.Cells[i + startX, j + startY] = dt.Rows[i][j];</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 加入分页符</p>
<p>/// </summary></p>
<p>/// <param name="rangeStr"></param></p>
<p>/// <param name="lineNumber"></param></p>
<p>public void AddPageBreak(string rangeStr, int lineNumber)</p>
<p>{</p>
<p>Excel.Range range = worksheet.get_Range(&ldquo;A&rdquo; + lineNumber.ToString(), missing);</p>
<p>worksheet.HPageBreaks.Add(range);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 加入分页符</p>
<p>/// </summary></p>
<p>/// <param name="lineNumber"></param></p>
<p>public void AddPageBreak(int lineNumber)</p>
<p>{</p>
<p>AddPageBreak(worksheet.Name, lineNumber);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 从当前工作表数据区域复制数据到另一个区域</p>
<p>/// </summary></p>
<p>/// <param name="sheetFromRange"></param></p>
<p>/// <param name="sheetToRange"></param></p>
<p>public void CopyRange2Range(string sheetFromRange, string sheetToRange)</p>
<p>{</p>
<p>CopyRange2Range(worksheet.Name, worksheet.Name, sheetFromRange, sheetToRange);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 从一个表的某个数据区域复制数据到另一个表的某个区域</p>
<p>/// </summary></p>
<p>/// <param name="sheetFromName"></param></p>
<p>/// <param name="sheetToName"></param></p>
<p>/// <param name="sheetFromRange"></param></p>
<p>/// <param name="sheetToRange"></param></p>
<p>public void CopyRange2Range(string sheetFromName, string sheetToName, string
sheetFromRange, string sheetToRange)</p>
<p>{</p>
<p>Excel.Worksheet sheetFrom = workbook.Worksheets[sheetFromName] as
Excel.Worksheet;</p>
<p>Excel.Worksheet sheetTo = workbook.Worksheets[sheetToName] as Excel.Worksheet;</p>
<p>sheetFrom.get_Range(sheetFromRange,
missing).Copy(sheetTo.get_Range(sheetToRange, missing));</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 移动Range到另一个Range</p>
<p>/// </summary></p>
<p>/// <param name="FromRange"></param></p>
<p>/// <param name="ToRange"></param></p>
<p>public void MoveRange2Range(string FromRange, string ToRange)</p>
<p>{</p>
<p>MoveRange2Range(worksheet.Name, FromRange, ToRange);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 移动Range到另一个Range</p>
<p>/// </summary></p>
<p>/// <param name="sheetName"></param></p>
<p>/// <param name="FromRange"></param></p>
<p>/// <param name="ToRange"></param></p>
<p>public void MoveRange2Range(string sheetName, string FromRange, string
ToRange)</p>
<p>{</p>
<p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p>
<p>sheet.get_Range(FromRange, missing).Cut(sheet.get_Range(ToRange, missing));</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 重设当前工作目录的打印区域</p>
<p>/// </summary></p>
<p>public void ResetPrintArea()</p>
<p>{</p>
<p>SetPrintArea(worksheet.Name, &ldquo;&rdquo;);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 重设工作目录的打印区域</p>
<p>/// </summary></p>
<p>public void ResetPrintArea(string sheetName)</p>
<p>{</p>
<p>SetPrintArea(sheetName, &ldquo;&rdquo;);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 设定工作目录的打印区域</p>
<p>/// </summary></p>
<p>/// <param name="area"></param></p>
<p>public void SetPrintArea(string area)</p>
<p>{</p>
<p>SetPrintArea(worksheet.Name, area);</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 设定工作目录的打印区域</p>
<p>/// </summary></p>
<p>/// <param name="sheetName"></param></p>
<p>/// <param name="area"></param></p>
<p>public void SetPrintArea(string sheetName, string area)</p>
<p>{</p>
<p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p>
<p>sheet.PageSetup.PrintArea = area;</p>
<p>}</p>
<p>/// <summary></p>
<p>/// 将当前工作表中的表格数据复制到剪切板</p>
<p>/// </summary></p>
<p>public void Copy()</p>
<p>{</p>
<p>if (worksheet != null)</p>
<p>{</p>
<p>try</p>
<p>{</p>
<p>worksheet.UsedRange.Select();</p>
<p>}</p>
<p>catch { }</p>
<p>worksheet.UsedRange.Copy(missing);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h2 id="四使用adonetvba操作excel">四、使用ADO.net+VBA操作Excel</h2>
<p>我手头的这个案子在用第一种方法撰写一个星期之后遇到效率瓶颈，无奈改为第二种方法，由于对Excel的文档模型有了较全面的认识，几个主流函数也很清楚，所以写的速
度很快。</p>
<p>这里我还是要佩服一下微软，曾经我对Office很不屑，后来看完《[Word排版艺术](<a href="http://book.douban.com/subject/1193">http://book.douban.com/subject/1193</a>
565/)》才开始认识Office，再之后深入PPT和Excel，更是感觉文档模型了不起。。。咳咳咳，扯远了~</p>
<h3 id="41-使用adonet写入数据到excel文件">4.1 使用ADO.net写入数据到Excel文件</h3>
<p>废话不说了，上核心代码</p>
<pre><code>System.Data.OleDb.OleDbConnection objConn = new System.Data.OleDb.OleDbConnection(&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=&quot; +
                    destFileName + &quot;;Extended Properties=Excel 8.0;&quot;);
objConn.Open();
</code></pre>
<p>System.Data.OleDb.OleDbCommand objCmd = new System.Data.OleDb.OleDbCommand();</p>
<p>objCmd.Connection = objConn;</p>
<p>foreach (DataRow row in dt.Rows)</p>
<p>{ StringBuilder stringBuilder = new StringBuilder();</p>
<p>stringBuilder.AppendFormat(&ldquo;INSERT INTO [{0}$] (&rdquo;, sheetName);</p>
<p>for (int i = 0; i &lt; dt.Columns.Count; i++)</p>
<p>{</p>
<p>if (i &lt; dt.Columns.Count - 1)</p>
<p>stringBuilder.Append(dt.Columns[i].ColumnName + &ldquo;,&rdquo;);</p>
<p>else</p>
<p>stringBuilder.Append(dt.Columns[i].ColumnName + &ldquo;) VALUES (&rdquo;);</p>
<p>}</p>
<p>for (int i = 0; i &lt; dt.Columns.Count; i++)</p>
<p>{</p>
<p>if (i &lt; dt.Columns.Count - 1)</p>
<p>stringBuilder.Append(&quot;@&quot; + dt.Columns[i].ColumnName + &ldquo;,&rdquo;);</p>
<p>else</p>
<p>stringBuilder.Append(&quot;@&quot; + dt.Columns[i].ColumnName + &ldquo;);&rdquo;);</p>
<p>}</p>
<p>objCmd.Parameters.Clear();</p>
<p>for (int i = 0; i &lt; dt.Columns.Count; i++)</p>
<p>{</p>
<p>objCmd.Parameters.Add(dt.Columns[i].ColumnName, row[i]);</p>
<p>}</p>
<p>objCmd.CommandText = stringBuilder.ToString();</p>
<p>objCmd.ExecuteNonQuery();</p>
<p>}</p>
<p>注意点就是INSERT的表明就是Sheet的名字加上中括号和$符号。</p>
<h3 id="42-使用vba操作模板和数据">4.2 使用VBA操作模板和数据</h3>
<p>使用VBA操作模板和数据的过程是一个assign的过程，就是把数据和模板杂糅起来，类似于MVC中C控制M输出到V中，我建议针对不同类型的页面制作多个模板，而
不要使用VBA进行各种样式修改操作，减少代码量。我这个案子中使用了8个不同类型模板，毕竟直接使用鼠标拖拽出一个模板比用VBA代码修改处一个模板简单的多。</p>
<p>Excel2007的VBA界面在&quot;开发工具&quot;-&ldquo;Visual
Basic&quot;中打开，千万不要以为写VBA就是录制宏呀~另外附赠一个小技巧，在VBA编辑界面里面使用Ctrl+J可以自动补全，相当实用。</p>
<p>我把项目分成5个模块：Golbal 、Init 、Insert 、Finalize
、Utils，看名字就知道意思了，其中Utils包含一个中文大写数字转换的函数，供前面使用。</p>
<p>我们需要在Excel自动打开时候进行操作，需要使用函数Workbook_Open，另有Auto_Open，两个有不同之处，可以Google之。</p>
<p>启用代码如下：</p>
<pre><code>'开启工作簿时候动作
Private Sub Workbook_Open()
    
    MAIN_SHEET = &quot;报价模板&quot;
    For Each Sheet In Sheets
        If Sheet.Name = MAIN_SHEET Then
            Exit Sub
        End If
    Next
    If Sheets(&quot;OPTION&quot;).Range(&quot;B2&quot;).Value = &quot;&quot; Then '如果不存在DH行数，则退出
        Exit Sub
    End If
    
    MsgBox (&quot;初始化数据，请稍等片刻！&quot;)
    Call Run
    Call DeleteSheets
    'Call ActiveWorkbook.Save
    MsgBox (&quot;初始化数据完成，请保存Excel文件！&quot;)
</code></pre>
<p>End Sub</p>
<p>核心代码的话。。。其实没什么核心代码，就是频繁的使用赋值和Copy函数。。。。</p>
<h2 id="五相关资料链接">五、相关资料链接</h2>
<p>[C#操作Excel开发报表系列整理](<a href="http://www.cnblogs.com/dahuzizyd/archive/2007/04/11/CSharp">http://www.cnblogs.com/dahuzizyd/archive/2007/04/11/CSharp</a>
_Excel_Report_Chart_All.html)</p>
<p><a href="http://www.cnblogs.com/HQT/archive/2006/05/22/406345.html">检索 COM 类工厂中 CLSID 为 {00024500-0000-0000-C000-000000000046} 的组件时失败，原因是出现以下错误:
80070005</a></p>
<p>PS:8000401a的错误会在服务器上出现，不会在xp上出现，原因是交互式用户也没有Excel操作权限，这时候要给Excel手动制动一个有Excel操作权
限用户，比如administrator。</p>
<p><a href="http://archive.cnblogs.com/a/567305/">Office编程在dot Net环境中总结(Excel篇)</a></p>
<p>好了，这就是我这次Excel学习的分享，谢谢大家耐着性子看完~</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
