<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Pymssql on Log4D</title>
    <link>https://blog.alswl.com/tags/pymssql/</link>
    <description>Recent content in Pymssql on Log4D</description>
    <generator>Hugo -- 0.125.3</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 09 Nov 2010 00:00:00 +0800</lastBuildDate>
    <atom:link href="https://blog.alswl.com/tags/pymssql/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一周Python小记</title>
      <link>https://blog.alswl.com/2010/11/a-week-python/</link>
      <pubDate>Tue, 09 Nov 2010 00:00:00 +0800</pubDate>
      <guid>https://blog.alswl.com/2010/11/a-week-python/</guid>
      <description>上个星期以来忙里偷闲一直在写一系列小型的代码生成器，完成一些从需求到结构化代码生成和验证作业。这个小东西是用Python写的，我简单分享一下中间所得。 一、配置文件 1、YAML格式 数据库连接信息和作业相关信息是存放在数据库中的，配置文件形式可以有很多种选择：XML / ini / txt，我这里选择YAML作为存放。 YAML使用起来相当方便，能够自动解析成对应语言中的变量，比如列表解析为列表，数字文字分别解析成</description>
      <content:encoded><![CDATA[<p>上个星期以来忙里偷闲一直在写一系列小型的代码生成器，完成一些从需求到结构化代码生成和验证作业。这个小东西是用Python写的，我简单分享一下中间所得。</p>
<h2 id="一配置文件">一、配置文件</h2>
<h3 id="1yaml格式">1、YAML格式</h3>
<p>数据库连接信息和作业相关信息是存放在数据库中的，配置文件形式可以有很多种选择：XML / ini / txt，我这里选择YAML作为存放。</p>
<p>YAML使用起来相当方便，能够自动解析成对应语言中的变量，比如列表解析为列表，数字文字分别解析成对应的格式变量。</p>
<p>之所以选择YAML，是看中它对语言的亲和性和可读性，GAE的配置文件就是YAML格式。YAML的语法相当简单，用:来分隔key: value，用 -
来分隔列表，注意点是缩进需要用空格，关键符号和内容之间要加上一个空格。我的配置文件如下：</p>
<pre><code>taskId: PQMI06
taskName: 测试建制作业
author: alswl
confirmId: 20101025xxx
</code></pre>
<p>headFiles:</p>
<ul>
<li>
<p>head1.txt</p>
</li>
<li>
<p>head2.txt</p>
</li>
<li>
<p>head3.txt<br />
bodyFiles:</p>
</li>
<li>
<p>body1.txt</p>
</li>
<li>
<p>body2.txt</p>
</li>
<li>
<p>body3.txt</p>
</li>
</ul>
<p>qbe: qbe.txt</p>
<p>qbeGrid: qbegrid.txt</p>
<p>server: 172.16.1.20</p>
<p>user: sa</p>
<p>dbpassword: 518518</p>
<p>databaseSys: ebChainSys30_0</p>
<p>databaseSyn: ebChainSyn30_0</p>
<p>YAML可以用VIM或者notepad++进行编辑，两者都对YAML提供语法高亮支持（博客的SyantaxHighLighter不支持~）。</p>
<p>相关链接：<a href="http://www.yaml.org/">YAML的官方网站</a>（网站的分隔就是YAML格式，相当有趣）
<a href="http://www.ibm.com/developerworks/cn/xml/x-cn-yamlintro/">YAML简介</a>（来自IBM）</p>
<p>2、PyYAML</p>
<p>Python有几种YAML的实现，我这里推荐使用PyYAML，比较流行的模块，毕竟我这里只需要简单的读写操作。</p>
<p>PyYAML通过官方宣称的神奇的yaml.load()方法载入YAML文件，可以将列表识别为list和dictionary，通过key可以直接读取对应的值。</p>
<p>我的Demo代码如下：</p>
<pre><code>#coding=utf-8
'''
全局配置文件
alswl
20101026
'''
import os
import yaml
</code></pre>
<p>rootPath = os.path.normpath(os.path.dirname(<strong>file</strong>) + &lsquo;..&rsquo;)</p>
<p>configFile = open(rootPath + &lsquo;&lsquo;&lsquo;inconfig.yaml&rsquo;&rsquo;&rsquo;)</p>
<p>configYaml = configFile.read()</p>
<p>configFile.close()</p>
<p>CONFIG = yaml.load(configYaml)</p>
<p>通过上面的方法，我就能获取CONFIG这个变量，然后设置为全局变量使用了。</p>
<p>上面代码中一个小技巧就是使用os.path.dirname(<strong>file</strong>)获取当前的路径的父路径，在通过normpath转换为绝对路径，这样可以使用配置
文件的相对路径，以方便文件的迁移。（使用sys.path[0]也能获取文件运行路径，两者略有小区别）</p>
<p>相关链接：<a href="http://pyyaml.org/">PyYAML的官网</a> [PyYAML_3.09-2.6下载](<a href="http://pyyaml.org/dow">http://pyyaml.org/dow</a>
nload/pyyaml/PyYAML-3.09.win32-py2.6.exe)</p>
<h2 id="二数据库连接-pymssql">二、数据库连接-pymssql</h2>
<p>Python连接MSSQL有多种模块选择，我选用pymssql。pymssql可以在[这里](<a href="http://code.google.com/p/pymssq">http://code.google.com/p/pymssq</a>
l/)下载到。我使用的版本是1.9.908。</p>
<p>其他的一些数据库连接模块，可以参考这里：<a href="http://wiki.woodpecker.org.cn/moin/Py4Database">Py4Database - Woodpecker Wiki for
CPUG</a>以及<a href="http://wiki.woodpecker.org.cn/moin/DatabaseModules">DatabaseModules -
Woodpecker Wiki for CPUG</a></p>
<p>很不幸的是，pymssql在IDLE下面会导致IDLE崩溃（经我测试，只要import
_mssql就会崩溃，这个Bug已经在pymssql报告了），所以当操作pymssql时候必须使用PythonWin或者Python
Shell。另外截止目前，pymssql还仅仅支持Python2.6。</p>
<p>下面的Code是简单的操作数据库，定义数据库连接，获取dataset，在for循环读取一遍，完成一个简单的检测动作</p>
<pre><code>conn =_mssql.connect(server=CONFIG['server'], user=CONFIG['user'], password=str(CONFIG['dbpassword']), database=CONFIG['databaseSys'])

def validateEntityInFrmFields(self, webControls, conn, boid):
    if webControls[0].d_ != '':
        boid = boid + '_d' + webControls[0].d_.rjust(2, '0')
    sqlCmd = &quot;SELECT FieldName FROM SYSFrmFields WHERE BOID='%s'&quot; %boid
    conn.execute_query(sqlCmd)
    res = [r for r in conn]
    fs = [i[0] for i in res]
    l = [i.fieldName for i in webControls]
    for i in l[:]:
        if i.strip() == '':
            l.remove(i)
    isSuccess = True
    for i in l:
        if i not in fs:
            isSuccess = False
            print u'SYSFrmFields中不存在栏位%s' %i
    if isSuccess:
        print u'检测成功，恭喜你'
        print u'页面元件需要的Field全部存在于在SYSFrmFieldsn'
    else:
        print u'检测失败'
</code></pre>
<p>print u&rsquo;检测完毕&rsquo;</p>
<p>简单的pymssql就这么用，import _mssql就可以了，如果需要原生的支持DB-API方式编程，可以使用import mssql。</p>
<h2 id="三脚本运行完之后继续操作">三、脚本运行完之后继续操作</h2>
<p>脚本不可避免的需要分包，分模块，然后在里面撰写代码，但有时候我们需要中途使用一些数据完成特定即时的操作。使用IDE的Debug暂停当然可以，但这不是最佳的解
决办法。</p>
<p>下面是我自己摸索出来的方法，也许不是最佳办法，但是可以用，可以在脚本执行完之后继续操作里面定义的变量，以完成更多动作。</p>
<p>用IDE打开Script，然后在里面键入类似代码。</p>
<pre><code>import codegenx;from codegenx import WEBCONTROLS;codegenx.main()
qbe = WEBCONTROLS['qbe'];
</code></pre>
<p>Python中可以通过加入分号来让多条语句放在同一行。经过上面代码的执行，我就可以获取WEBCONTROLS这个codegenx模块中的对象。如果担心cod
egenx中的WEBCONTROLS和Shell中的不一致，可以用id()来看一下内存标示，经我检测发现是一致的。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
