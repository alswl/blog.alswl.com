<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 | Log4D</title>
<meta name="keywords" content="sqlserver, mysql, db-migration">
<meta name="description" content="该系列三篇文章已经全部完成：
从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D 从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D 我们用了两章文章
从 SQL Server 到 MySQL（一）：异构数据库迁移
/
从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机
介绍我们遇到问题和解决方案。
不管是离线全量迁移还是在线无缝迁移，
核心 ETL 工具就是 yugong。
Yugong 是一个成熟工具， 在阿里巴巴去 IOE 行动中起了重要作用，
它与 Otter / Canal 都是阿里中间件团队出品。
它们三者各有分工：
Yugong 设计目标是异构数据库迁移；
Canal 设计用来解决 MySQL binlog 订阅和消费问题；
Otter 则是在 Canal 之上，以准实时标准解决数据库同步问题。
Otter 配备了相对 yugong 更健壮管理工具、分布式协调工具，
从而长期稳定运行。Yugong 设计目标则是一次性迁移工作，偏 Job 类型。">
<meta name="author" content="alswl">
<link rel="canonical" href="https://blog.alswl.com/2018/06/sql-server-migration-3/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://blog.alswl.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.alswl.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.alswl.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.alswl.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.alswl.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-8822123-3', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量" />
<meta property="og:description" content="该系列三篇文章已经全部完成：
从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D 从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D 我们用了两章文章
从 SQL Server 到 MySQL（一）：异构数据库迁移
/
从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机
介绍我们遇到问题和解决方案。
不管是离线全量迁移还是在线无缝迁移，
核心 ETL 工具就是 yugong。
Yugong 是一个成熟工具， 在阿里巴巴去 IOE 行动中起了重要作用，
它与 Otter / Canal 都是阿里中间件团队出品。
它们三者各有分工：
Yugong 设计目标是异构数据库迁移；
Canal 设计用来解决 MySQL binlog 订阅和消费问题；
Otter 则是在 Canal 之上，以准实时标准解决数据库同步问题。
Otter 配备了相对 yugong 更健壮管理工具、分布式协调工具，
从而长期稳定运行。Yugong 设计目标则是一次性迁移工作，偏 Job 类型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.alswl.com/2018/06/sql-server-migration-3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-20T20:18:52+08:00" />
<meta property="article:modified_time" content="2018-06-20T20:18:52+08:00" /><meta property="og:site_name" content="Log4D" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量"/>
<meta name="twitter:description" content="该系列三篇文章已经全部完成：
从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D 从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D 我们用了两章文章
从 SQL Server 到 MySQL（一）：异构数据库迁移
/
从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机
介绍我们遇到问题和解决方案。
不管是离线全量迁移还是在线无缝迁移，
核心 ETL 工具就是 yugong。
Yugong 是一个成熟工具， 在阿里巴巴去 IOE 行动中起了重要作用，
它与 Otter / Canal 都是阿里中间件团队出品。
它们三者各有分工：
Yugong 设计目标是异构数据库迁移；
Canal 设计用来解决 MySQL binlog 订阅和消费问题；
Otter 则是在 Canal 之上，以准实时标准解决数据库同步问题。
Otter 配备了相对 yugong 更健壮管理工具、分布式协调工具，
从而长期稳定运行。Yugong 设计目标则是一次性迁移工作，偏 Job 类型。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.alswl.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量",
      "item": "https://blog.alswl.com/2018/06/sql-server-migration-3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量",
  "name": "从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量",
  "description": "该系列三篇文章已经全部完成：\n从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D 从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D 我们用了两章文章\n从 SQL Server 到 MySQL（一）：异构数据库迁移\n/\n从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机\n介绍我们遇到问题和解决方案。\n不管是离线全量迁移还是在线无缝迁移，\n核心 ETL 工具就是 yugong。\nYugong 是一个成熟工具， 在阿里巴巴去 IOE 行动中起了重要作用，\n它与 Otter / Canal 都是阿里中间件团队出品。\n它们三者各有分工：\nYugong 设计目标是异构数据库迁移；\nCanal 设计用来解决 MySQL binlog 订阅和消费问题；\nOtter 则是在 Canal 之上，以准实时标准解决数据库同步问题。\nOtter 配备了相对 yugong 更健壮管理工具、分布式协调工具，\n从而长期稳定运行。Yugong 设计目标则是一次性迁移工作，偏 Job 类型。",
  "keywords": [
    "sqlserver", "mysql", "db-migration"
  ],
  "articleBody": "该系列三篇文章已经全部完成：\n从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D 从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D 从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D 我们用了两章文章\n从 SQL Server 到 MySQL（一）：异构数据库迁移\n/\n从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机\n介绍我们遇到问题和解决方案。\n不管是离线全量迁移还是在线无缝迁移，\n核心 ETL 工具就是 yugong。\nYugong 是一个成熟工具， 在阿里巴巴去 IOE 行动中起了重要作用，\n它与 Otter / Canal 都是阿里中间件团队出品。\n它们三者各有分工：\nYugong 设计目标是异构数据库迁移；\nCanal 设计用来解决 MySQL binlog 订阅和消费问题；\nOtter 则是在 Canal 之上，以准实时标准解决数据库同步问题。\nOtter 配备了相对 yugong 更健壮管理工具、分布式协调工具，\n从而长期稳定运行。Yugong 设计目标则是一次性迁移工作，偏 Job 类型。\n当然 yugong 本身质量不错，长期运行也没问题。\n我们有个产线小伙伴使用我们魔改后 yugong，\n用来将数据从管理平台同步数据到用户前台，已经稳定跑了半年多了。\nyugong 系统结构 这里我不赘述如何使用 yugong，有需求同学直接去\n官方文档 查看使用文档。\n我直接进入关键环节：解剖 yugong 核心模块。\nYugong 数据流是标准 ETL 流程，分别有 Extractor / Translator / Applier\n这三个大类来实现 ETL 过程:\n我们依次来看看这三大类具体设计。\nExtractor YuGongLifeCycle：Yugong 组件生命周期声明 AbstractYuGongLifeCycle：Yugong 组件生命周期一些实现 RecordExtractor：基础 Extractor Interface AbstractRecordExtractor：基础 Extractor 虚拟类，做了一部分实现 AbstractOracleRecordExtractor：Oracle Extractor 虚拟类，做了一部分 Oracle 相关实现 OracleOnceFullRecordExtractor：Oracle 基于特定 SQL 一次性 Extractor OracleFullRecordExtractor：Oracle 全量 Extractor OracleRecRecordExtractor：Oracle 记录 Extractor，用来创建物化视图 OracleMaterializedIncRecordExtractor：基于（已有）物化视图 Oracle 增量 Extrator OracleAllRecordExtractor：Oracle 自动化 Extractor，先 Mark 再 Full，再 Inc Exctractor 从 Source DB 读取数据写入内存，\nYugong 官方提供 Extractor 抽象出 AbstractRecordExtractor 类，\n其余类都是围绕 Oracle 实现。\n另外 Yugong 设计了 YuGongLifeCycle 类实现了组件生命周期管理。\nTranslator DataTranslator：Translator 基类，为 Row 级别数据处理 TableTranslator：Translator 基类，为 Table 级别提供处理（官方代码中没有使用） AbstractDataTranslator：Data Translator 虚拟类，做了部分实现 EncodeDataTranslator：转换编码格式 Translator OracleIncreamentDataTranslator：为 Oracle 增量数据准备 Translator，会调整一些数据状态 BackTableDataTranslator：Demo，允许在 Translator 中做回写数据操作 BillOutDataTranslator：Demo，包含一些阿里业务逻辑 Translator MidBillOutDetailDataTranslator：Demo，包含一些阿里业务逻辑 Translator Translator 读取内存中 RowData 然后变换，\n大部分 Translator 做一些无状态操作，比如编码转换。\n另外还有一小部分 Translator 做了业务逻辑操作，比如做一些数据回写。\nApplier RecordApplier：基础 Applier Interface AbstractRecordApplier：基础 Applier 虚拟类，做了一部分实现 CheckRecordRecordApplier：检查数据一致性 Applier，不做数据写入 FullRecordRecordApplier：全量数据 Applier，使用 UPSERT 做数据更新 IncreamentRecordApplier：增量 Applier，使用 Oracle 物化视图为数据源 AllRecordRecordApplier：自动化 Applier，先使用全量数据 Applier，然后使用增量数据 Applier Applier 将经过 Translator 处理过的数据写入 Target DB。\nYugong 提供了一致性检查、全量、增量 Applier。\n比较特殊是 AllRecordRecordApplier 提供了全套自动化操作。\nOthers 除了 ETL 三个要素，yugong 还有一些重要类：控制类和工具类。\nSqlTemplate：提供 CRUD / UPSERT 等操作的基类 SQL 模板 OracleSqlTemplate：基于 SqlTemplate 实现的 Oracle SQL 模板 RecordDiffer：一致性检查 differ YugongController：应用控制器，控制整个应用数据流向 YugongInstance：控制单个迁移任务实例，一张表对应一个 YugongInstance 老战士的问题 说 yugong 有问题会有些标题党，毕竟它是久经考验老战士了。\n但对我们来说，开源版本 yugong 还有一些不足：\n不支持 SQL Server 读取 不支持 SQL Server 写入（Rollback 需要写入 SQL Server） 不支持 MySQL 读取 除了数据库支持，Yugong 在工程上面倒是也有一些改善空间。\n我们最后花费了不少时间，做了工程上改进。\n抛弃默认打包方式（基于 maven-assembly-plugin 生成类似 LFS 结构 tar.gz 文件），\n改为使用 fat jar 模式打包，仅生成单文件可执行 jar 包 抛弃 ini 配置文件，使用 YAML 配置文件格式（已有老配置仍然使用 ini 文件，YAML 主要管理表结构变更） 改造 Plugin 模式，将 Java 运行时编译改为反射获取 Java 类 拆分 Unit Test / Integration Test，降低重构成本 重构 Oracle 继承结构，使其开放 SQL Server / MySQL 接口 支持 Canal Redis 格式数据作为 MySQL 在线增量数据源 改造之后结构 Extractor AbstractSqlServerExtractor：新增抽象 SqlServer Extractor AbstractMysqlExtractor：新增抽象 MySQL Extractor AbstractFullRecordExtractor：新增抽象 Full 模式 Extractor SqlServerCdcExtractor：新增 SQL Server CDC 增量模式 Extractor MysqlCanalExtractor：新增 MySQL Canal 格式增量消费 Extractor MysqlCanalRedisExtractor：新增 MySQL Canal 格式增量消费 Extractor，使用 Redis 做回溯 MysqlFullExtractor：新增 MySQL 全量 Extractor SqlServerFullExtractor：新增 SQL Server 全量 Extractor 在抽象出三个抽象类之后，整体逻辑更为清晰，如果未来要增加新数据库格式支持，也更为简单。\nTranslator Sha1ShardingTranslator：根据 Sha1 Sharding Translator ModShardingTranslator：根据 Value Mode Sharding Translator RangeShardingTranslator：根据范围 Sharding Translator UserRouterMapShardingTranslator：特定业务使用， 用户分表 Sharding Translator UserRouterMapMobileShardingTranslator：特定业务使用， 用户分表 Sharding Translator ClassLearningNoteInfoShardingTranslator：特定业务使用自定义 Translator ClassLearningIsActiveReverseShardingTranslator：特定业务使用自定义 Translator ColumnFixDataTranslator：调整表结构 Translator NameStyleDataTranslator：调整表字段名 Translator，支持按风格对整个表自动转换 CompositeIndexesDataTranslator：解决复合主键下唯一 PK 确定问题的 Translator 新增了一系列 Translator。\nApplier SqlServerIncreamentRecordApplier：新增 SQL Server 增量消费 Applier Applier 结构调整挺小，主要是增加了 SQL Server 的支持。\n二次开发心得 如何快速了解一个开源项目？很多同学第一反应就是阅读源码。\n看源码固然是有效果，但是性价比太低。\n如果项目设计不合理，很快会迷失在代码细节之中。\n我的经验是先阅读官方出品的一些 Slide 分享，然后阅读官方核心文档。\nSlide 含金量高，在讲述核心中核心。\n如果真要去了解细节去阅读源码，那我建议要善用工具，\n比如使用 IntelliJ 的 Diagram 功能，抽象出核心类。\n还有一些插件比如 SequencePluginReload 方便地生成函数之间调用，实为查看数据流利器。\n我在这次开发过程中，也根据生成类图发现了一些问题，\n从而在进入 Coding 之前，先对框架继承结构重构。提高了整体开发效率\n根据代码风格判断，Yugong 并非是出自一个人之手。这多少会导致代码风格和设计上面不一致。\n我自己也常年在业务线里面摸爬滚打，能想象到在快速推进项目中需要糙快猛。\n但后人接受开发，多少会有些头疼。\n于是我在进入开发之前，引入标准化 CheckStyle，用 Google Style 全局格式化，\n使用 Sonar 扫描保证一个代码质量基线。\n同时这也是一把双刃剑，格式化项目会导致大量 diff，\n这也给我自己埋下了一个苦果，在后期给上游提交 PR 引入无尽问题。\n开发过程中我也犯了一些错误。最为头疼是没有在早期考虑到向开源社区贡献，\n导致未来向上游合并困难重重，现在还在头疼合并代码中。\n另外，由于整体项目时间紧，我贪图实现速度，没有做更详尽单元测试覆盖。\n这里没有遵循开源软件的最佳实践。\n经过我改造的 Yugong 版本开源地址是：https://github.com/alswl/yugong 。\n我也提交了 Pull Request https://github.com/alibaba/yugong/pull/66 ，\n正在与官方沟通如何将这部分提交并入上游。\n",
  "wordCount" : "459",
  "inLanguage": "en",
  "datePublished": "2018-06-20T20:18:52+08:00",
  "dateModified": "2018-06-20T20:18:52+08:00",
  "author":{
    "@type": "Person",
    "name": "alswl"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.alswl.com/2018/06/sql-server-migration-3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Log4D",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.alswl.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.alswl.com/" accesskey="h" title="Log4D (Alt + H)">Log4D</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.alswl.com/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.alswl.com/">Home</a>&nbsp;»&nbsp;<a href="https://blog.alswl.com/posts/">Posts</a></div>
    <h1 class="post-title">
      从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量
    </h1>
    <div class="post-meta"><span title='2018-06-20 20:18:52 +0800 CST'>2018-06-20</span>&nbsp;·&nbsp;alswl

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#yugong-系统结构">yugong 系统结构</a>
      <ul>
        <li><a href="#extractor">Extractor</a></li>
        <li><a href="#translator">Translator</a></li>
        <li><a href="#applier">Applier</a></li>
        <li><a href="#others">Others</a></li>
      </ul>
    </li>
    <li><a href="#老战士的问题">老战士的问题</a></li>
    <li><a href="#改造之后结构">改造之后结构</a>
      <ul>
        <li><a href="#extractor-1">Extractor</a></li>
        <li><a href="#translator-1">Translator</a></li>
        <li><a href="#applier-1">Applier</a></li>
      </ul>
    </li>
    <li><a href="#二次开发心得">二次开发心得</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>该系列三篇文章已经全部完成：</p>
<ul>
<li><a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL（一）：异构数据库迁移 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机 - Log4D</a></li>
<li><a href="https://blog.alswl.com/2018/06/sql-server-migration-3/">从 SQL Server 到 MySQL（三）：愚公移山 - 开源力量 - Log4D</a></li>
</ul>
<p><img loading="lazy" src="https://4ocf5n.dijingchao.com/upload_dropbox/201806/refactor.png" alt="201806/refactor.png"  />
</p>
<p>我们用了两章文章<br />
<a href="https://blog.alswl.com/2018/03/sql-server-migration-1/">从 SQL Server 到 MySQL（一）：异构数据库迁移</a><br />
/<br />
<a href="https://blog.alswl.com/2018/05/sql-server-migration-2/">从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机</a><br />
介绍我们遇到问题和解决方案。<br />
不管是离线全量迁移还是在线无缝迁移，<br />
核心 ETL 工具就是 yugong。</p>
<p>Yugong 是一个成熟工具， 在阿里巴巴去 IOE 行动中起了重要作用，<br />
它与 Otter / Canal 都是阿里中间件团队出品。<br />
它们三者各有分工：<br />
Yugong 设计目标是异构数据库迁移；<br />
Canal 设计用来解决 MySQL binlog 订阅和消费问题；<br />
Otter 则是在 Canal 之上，以准实时标准解决数据库同步问题。<br />
Otter 配备了相对 yugong 更健壮管理工具、分布式协调工具，<br />
从而长期稳定运行。Yugong 设计目标则是一次性迁移工作，偏 Job 类型。<br />
当然 yugong 本身质量不错，长期运行也没问题。<br />
我们有个产线小伙伴使用我们魔改后 yugong，<br />
用来将数据从管理平台同步数据到用户前台，已经稳定跑了半年多了。</p>
<!-- more -->
<h2 id="yugong-系统结构">yugong 系统结构<a hidden class="anchor" aria-hidden="true" href="#yugong-系统结构">#</a></h2>
<p>这里我不赘述如何使用 yugong，有需求同学直接去<br />
<a href="https://github.com/alibaba/yugong">官方文档</a> 查看使用文档。</p>
<p>我直接进入关键环节：解剖 yugong 核心模块。<br />
Yugong 数据流是标准 ETL 流程，分别有 Extractor / Translator / Applier<br />
这三个大类来实现 ETL 过程:</p>
<p><img loading="lazy" src="https://4ocf5n.dijingchao.com/upload_dropbox/201806/etl.png" alt="ETL &amp;amp; Java Class"  />
</p>
<p>我们依次来看看这三大类具体设计。</p>
<h3 id="extractor">Extractor<a hidden class="anchor" aria-hidden="true" href="#extractor">#</a></h3>
<p><img loading="lazy" src="https://4ocf5n.dijingchao.com/upload_dropbox/201806/extractor.png" alt="Extractor Class"  />
</p>
<ul>
<li><code>YuGongLifeCycle</code>：Yugong 组件生命周期声明</li>
<li><code>AbstractYuGongLifeCycle</code>：Yugong 组件生命周期一些实现</li>
<li><code>RecordExtractor</code>：基础 Extractor Interface</li>
<li><code>AbstractRecordExtractor</code>：基础 Extractor 虚拟类，做了一部分实现</li>
<li><code>AbstractOracleRecordExtractor</code>：Oracle Extractor 虚拟类，做了一部分 Oracle 相关实现</li>
<li><code>OracleOnceFullRecordExtractor</code>：Oracle 基于特定 SQL 一次性 Extractor</li>
<li><code>OracleFullRecordExtractor</code>：Oracle 全量 Extractor</li>
<li><code>OracleRecRecordExtractor</code>：Oracle 记录 Extractor，用来创建物化视图</li>
<li><code>OracleMaterializedIncRecordExtractor</code>：基于（已有）物化视图 Oracle 增量 Extrator</li>
<li><code>OracleAllRecordExtractor</code>：Oracle 自动化 Extractor，先 Mark 再 Full，再 Inc</li>
</ul>
<p>Exctractor 从 Source DB 读取数据写入内存，<br />
Yugong 官方提供 Extractor 抽象出 <code>AbstractRecordExtractor</code> 类，<br />
其余类都是围绕 Oracle 实现。<br />
另外 Yugong 设计了 <code>YuGongLifeCycle</code> 类实现了组件生命周期管理。</p>
<h3 id="translator">Translator<a hidden class="anchor" aria-hidden="true" href="#translator">#</a></h3>
<p><img loading="lazy" src="https://4ocf5n.dijingchao.com/upload_dropbox/201806/translator.png" alt="Translator Class"  />
</p>
<ul>
<li><code>DataTranslator</code>：Translator 基类，为 Row 级别数据处理</li>
<li><code>TableTranslator</code>：Translator 基类，为 Table 级别提供处理（官方代码中没有使用）</li>
<li><code>AbstractDataTranslator</code>：Data Translator 虚拟类，做了部分实现</li>
<li><code>EncodeDataTranslator</code>：转换编码格式 Translator</li>
<li><code>OracleIncreamentDataTranslator</code>：为 Oracle 增量数据准备 Translator，会调整一些数据状态</li>
<li><code>BackTableDataTranslator</code>：Demo，允许在 Translator 中做回写数据操作</li>
<li><code>BillOutDataTranslator</code>：Demo，包含一些阿里业务逻辑 Translator</li>
<li><code>MidBillOutDetailDataTranslator</code>：Demo，包含一些阿里业务逻辑 Translator</li>
</ul>
<p>Translator 读取内存中 RowData 然后变换，<br />
大部分 Translator 做一些无状态操作，比如编码转换。<br />
另外还有一小部分 Translator 做了业务逻辑操作，比如做一些数据回写。</p>
<h3 id="applier">Applier<a hidden class="anchor" aria-hidden="true" href="#applier">#</a></h3>
<p><img loading="lazy" src="https://4ocf5n.dijingchao.com/upload_dropbox/201806/applier.png" alt="Applier Class"  />
</p>
<ul>
<li><code>RecordApplier</code>：基础 Applier Interface</li>
<li><code>AbstractRecordApplier</code>：基础 Applier 虚拟类，做了一部分实现</li>
<li><code>CheckRecordRecordApplier</code>：检查数据一致性 Applier，不做数据写入</li>
<li><code>FullRecordRecordApplier</code>：全量数据 Applier，使用 UPSERT 做数据更新</li>
<li><code>IncreamentRecordApplier</code>：增量 Applier，使用 Oracle 物化视图为数据源</li>
<li><code>AllRecordRecordApplier</code>：自动化 Applier，先使用全量数据 Applier，然后使用增量数据 Applier</li>
</ul>
<p>Applier 将经过 Translator 处理过的数据写入 Target DB。<br />
Yugong 提供了一致性检查、全量、增量 Applier。<br />
比较特殊是 <code>AllRecordRecordApplier</code> 提供了全套自动化操作。</p>
<h3 id="others">Others<a hidden class="anchor" aria-hidden="true" href="#others">#</a></h3>
<p>除了 ETL 三个要素，yugong 还有一些重要类：控制类和工具类。</p>
<ul>
<li><code>SqlTemplate</code>：提供 CRUD / UPSERT 等操作的基类 SQL 模板</li>
<li><code>OracleSqlTemplate</code>：基于 SqlTemplate 实现的 Oracle SQL 模板</li>
<li><code>RecordDiffer</code>：一致性检查 differ</li>
<li><code>YugongController</code>：应用控制器，控制整个应用数据流向</li>
<li><code>YugongInstance</code>：控制单个迁移任务实例，一张表对应一个 YugongInstance</li>
</ul>
<h2 id="老战士的问题">老战士的问题<a hidden class="anchor" aria-hidden="true" href="#老战士的问题">#</a></h2>
<p>说 yugong 有问题会有些标题党，毕竟它是久经考验老战士了。<br />
但对我们来说，开源版本 yugong 还有一些不足：</p>
<ul>
<li>不支持 SQL Server 读取</li>
<li>不支持 SQL Server 写入（Rollback 需要写入 SQL Server）</li>
<li>不支持 MySQL 读取</li>
</ul>
<p>除了数据库支持，Yugong 在工程上面倒是也有一些改善空间。<br />
我们最后花费了不少时间，做了工程上改进。</p>
<ul>
<li>抛弃默认打包方式（基于 maven-assembly-plugin 生成类似 LFS 结构 tar.gz 文件），<br />
改为使用 fat jar 模式打包，仅生成单文件可执行 jar 包</li>
<li>抛弃 ini 配置文件，使用 YAML 配置文件格式（已有老配置仍然使用 ini 文件，YAML 主要管理表结构变更）</li>
<li>改造 Plugin 模式，将 Java 运行时编译改为反射获取 Java 类</li>
<li>拆分 Unit Test / Integration Test，降低重构成本</li>
<li>重构 Oracle 继承结构，使其开放 SQL Server / MySQL 接口</li>
<li>支持 Canal Redis 格式数据作为 MySQL 在线增量数据源</li>
</ul>
<h2 id="改造之后结构">改造之后结构<a hidden class="anchor" aria-hidden="true" href="#改造之后结构">#</a></h2>
<h3 id="extractor-1">Extractor<a hidden class="anchor" aria-hidden="true" href="#extractor-1">#</a></h3>
<p><img loading="lazy" src="https://4ocf5n.dijingchao.com/upload_dropbox/201806/extractor-new.png" alt="Extractor New Class"  />
</p>
<ul>
<li><code>AbstractSqlServerExtractor</code>：新增抽象 SqlServer Extractor</li>
<li><code>AbstractMysqlExtractor</code>：新增抽象 MySQL Extractor</li>
<li><code>AbstractFullRecordExtractor</code>：新增抽象 Full 模式 Extractor</li>
<li><code>SqlServerCdcExtractor</code>：新增 SQL Server CDC 增量模式 Extractor</li>
<li><code>MysqlCanalExtractor</code>：新增 MySQL Canal 格式增量消费 Extractor</li>
<li><code>MysqlCanalRedisExtractor</code>：新增 MySQL Canal 格式增量消费 Extractor，使用 Redis 做回溯</li>
<li><code>MysqlFullExtractor</code>：新增 MySQL 全量 Extractor</li>
<li><code>SqlServerFullExtractor</code>：新增 SQL Server 全量 Extractor</li>
</ul>
<p>在抽象出三个抽象类之后，整体逻辑更为清晰，如果未来要增加新数据库格式支持，也更为简单。</p>
<h3 id="translator-1">Translator<a hidden class="anchor" aria-hidden="true" href="#translator-1">#</a></h3>
<p><img loading="lazy" src="https://4ocf5n.dijingchao.com/upload_dropbox/201806/translator-new.png" alt="Translator New Class"  />
</p>
<ul>
<li><code>Sha1ShardingTranslator</code>：根据 Sha1 Sharding Translator</li>
<li><code>ModShardingTranslator</code>：根据 Value Mode Sharding Translator</li>
<li><code>RangeShardingTranslator</code>：根据范围 Sharding Translator</li>
<li><code>UserRouterMapShardingTranslator</code>：特定业务使用， 用户分表 Sharding Translator</li>
<li><code>UserRouterMapMobileShardingTranslator</code>：特定业务使用， 用户分表 Sharding Translator</li>
<li><code>ClassLearningNoteInfoShardingTranslator</code>：特定业务使用自定义 Translator</li>
<li><code>ClassLearningIsActiveReverseShardingTranslator</code>：特定业务使用自定义 Translator</li>
<li><code>ColumnFixDataTranslator</code>：调整表结构 Translator</li>
<li><code>NameStyleDataTranslator</code>：调整表字段名 Translator，支持按风格对整个表自动转换</li>
<li><code>CompositeIndexesDataTranslator</code>：解决复合主键下唯一 PK 确定问题的 Translator</li>
</ul>
<p>新增了一系列 Translator。</p>
<h3 id="applier-1">Applier<a hidden class="anchor" aria-hidden="true" href="#applier-1">#</a></h3>
<p><img loading="lazy" src="https://4ocf5n.dijingchao.com/upload_dropbox/201806/applier-new.png" alt="Applier New Class"  />
</p>
<ul>
<li><code>SqlServerIncreamentRecordApplier</code>：新增 SQL Server 增量消费 Applier</li>
</ul>
<p>Applier 结构调整挺小，主要是增加了 SQL Server 的支持。</p>
<h2 id="二次开发心得">二次开发心得<a hidden class="anchor" aria-hidden="true" href="#二次开发心得">#</a></h2>
<p>如何快速了解一个开源项目？很多同学第一反应就是阅读源码。<br />
看源码固然是有效果，但是性价比太低。<br />
如果项目设计不合理，很快会迷失在代码细节之中。<br />
我的经验是先阅读官方出品的一些 Slide 分享，然后阅读官方核心文档。<br />
Slide 含金量高，在讲述核心中核心。</p>
<p>如果真要去了解细节去阅读源码，那我建议要善用工具，<br />
比如使用 IntelliJ 的 Diagram 功能，抽象出核心类。<br />
还有一些插件比如 SequencePluginReload 方便地生成函数之间调用，实为查看数据流利器。<br />
我在这次开发过程中，也根据生成类图发现了一些问题，<br />
从而在进入 Coding 之前，先对框架继承结构重构。提高了整体开发效率</p>
<p>根据代码风格判断，Yugong 并非是出自一个人之手。这多少会导致代码风格和设计上面不一致。<br />
我自己也常年在业务线里面摸爬滚打，能想象到在快速推进项目中需要糙快猛。<br />
但后人接受开发，多少会有些头疼。<br />
于是我在进入开发之前，引入标准化 CheckStyle，用 Google Style 全局格式化，<br />
使用 Sonar 扫描保证一个代码质量基线。<br />
同时这也是一把双刃剑，格式化项目会导致大量 diff，<br />
这也给我自己埋下了一个苦果，在后期给上游提交 PR 引入无尽问题。</p>
<p>开发过程中我也犯了一些错误。最为头疼是没有在早期考虑到向开源社区贡献，<br />
导致未来向上游合并困难重重，现在还在头疼合并代码中。<br />
另外，由于整体项目时间紧，我贪图实现速度，没有做更详尽单元测试覆盖。<br />
这里没有遵循开源软件的最佳实践。</p>
<p>经过我改造的 Yugong 版本开源地址是：https://github.com/alswl/yugong 。<br />
我也提交了 Pull Request <a href="https://github.com/alibaba/yugong/pull/66">https://github.com/alibaba/yugong/pull/66</a> ，<br />
正在与官方沟通如何将这部分提交并入上游。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.alswl.com/tags/sqlserver/">sqlserver</a></li>
      <li><a href="https://blog.alswl.com/tags/mysql/">mysql</a></li>
      <li><a href="https://blog.alswl.com/tags/db-migration/">db-migration</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.alswl.com/2018/07/naming-algorithem/">
    <span class="title">« Prev</span>
    <br>
    <span>破解三才五格姓名测试</span>
  </a>
  <a class="next" href="https://blog.alswl.com/2018/05/sql-server-migration-2/">
    <span class="title">Next »</span>
    <br>
    <span>从 SQL Server 到 MySQL（二）：在线迁移，空中换发动机</span>
  </a>
</nav>

  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "blog-alswl-com" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://blog.alswl.com/">Log4D</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
