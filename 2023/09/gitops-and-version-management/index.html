<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>GitOps 和版本管理 | Log4D</title>
<meta name="keywords" content="Design, Architecture">
<meta name="description" content="image via shipvehicles 如何使用 GitOps 管理交付内容版本是一个常见的问题。一个简单的回答是使用 Git 进行版本管理，并通过 Git Tag 来跟踪仓库内容的版本。虽然这可以解决一些问题，但在云原生技术的推动下，版本的概念远非如此简单。 版本问题 在引入 GitOps 到 DevOps 流程后，我们可以借助 GitOps 的能力进行持续集成和持续交付。 GitOps 解决了三个核心问题：内容、版本和协作。然而，我们经常将注意力集中在内容上，却经常忽略了版本管理问题。 那么，在 GitOps 过程中，有哪些版本管理问题">
<meta name="author" content="alswl">
<link rel="canonical" href="https://blog.alswl.com/2023/09/gitops-and-version-management/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8a8fb2252e3b86ff50510aea076c0754a4ac19e57254bb71b15cc554106148fb.css" integrity="sha256-io&#43;yJS47hv9QUQrqB2wHVKSsGeVyVLtxsVzFVBBhSPs=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://blog.alswl.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.alswl.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.alswl.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.alswl.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.alswl.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7S40P40QGJ"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-7S40P40QGJ', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="GitOps 和版本管理" />
<meta property="og:description" content="image via shipvehicles 如何使用 GitOps 管理交付内容版本是一个常见的问题。一个简单的回答是使用 Git 进行版本管理，并通过 Git Tag 来跟踪仓库内容的版本。虽然这可以解决一些问题，但在云原生技术的推动下，版本的概念远非如此简单。 版本问题 在引入 GitOps 到 DevOps 流程后，我们可以借助 GitOps 的能力进行持续集成和持续交付。 GitOps 解决了三个核心问题：内容、版本和协作。然而，我们经常将注意力集中在内容上，却经常忽略了版本管理问题。 那么，在 GitOps 过程中，有哪些版本管理问题" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.alswl.com/2023/09/gitops-and-version-management/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-23T18:22:27+08:00" />
<meta property="article:modified_time" content="2023-09-23T18:22:27+08:00" /><meta property="og:site_name" content="Log4D" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GitOps 和版本管理"/>
<meta name="twitter:description" content="image via shipvehicles 如何使用 GitOps 管理交付内容版本是一个常见的问题。一个简单的回答是使用 Git 进行版本管理，并通过 Git Tag 来跟踪仓库内容的版本。虽然这可以解决一些问题，但在云原生技术的推动下，版本的概念远非如此简单。 版本问题 在引入 GitOps 到 DevOps 流程后，我们可以借助 GitOps 的能力进行持续集成和持续交付。 GitOps 解决了三个核心问题：内容、版本和协作。然而，我们经常将注意力集中在内容上，却经常忽略了版本管理问题。 那么，在 GitOps 过程中，有哪些版本管理问题"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://blog.alswl.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "GitOps 和版本管理",
      "item": "https://blog.alswl.com/2023/09/gitops-and-version-management/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "GitOps 和版本管理",
  "name": "GitOps 和版本管理",
  "description": "image via shipvehicles 如何使用 GitOps 管理交付内容版本是一个常见的问题。一个简单的回答是使用 Git 进行版本管理，并通过 Git Tag 来跟踪仓库内容的版本。虽然这可以解决一些问题，但在云原生技术的推动下，版本的概念远非如此简单。 版本问题 在引入 GitOps 到 DevOps 流程后，我们可以借助 GitOps 的能力进行持续集成和持续交付。 GitOps 解决了三个核心问题：内容、版本和协作。然而，我们经常将注意力集中在内容上，却经常忽略了版本管理问题。 那么，在 GitOps 过程中，有哪些版本管理问题",
  "keywords": [
    "Design", "Architecture"
  ],
  "articleBody": " image via shipvehicles\n如何使用 GitOps 管理交付内容版本是一个常见的问题。一个简单的回答是使用 Git 进行版本管理，并通过 Git Tag 来跟踪仓库内容的版本。虽然这可以解决一些问题，但在云原生技术的推动下，版本的概念远非如此简单。\n版本问题 在引入 GitOps 到 DevOps 流程后，我们可以借助 GitOps 的能力进行持续集成和持续交付。 GitOps 解决了三个核心问题：内容、版本和协作。然而，我们经常将注意力集中在内容上，却经常忽略了版本管理问题。\n那么，在 GitOps 过程中，有哪些版本管理问题需要解决呢？\n一套完整的 GitOps 解决方案包括内容描述（Manifest）、构建方案（Builder）和生效方案（Applier）。其中，内容描述衍生出多种描述语言，从最传统的 Ansible / Chef，到云计算和云原生流行起来的 Terraform、Helm、Kustomize 等。引入了这么多内容描述方式之后，当我们想要明确一个应用的版本时，变得非常复杂。\n当提到版本时，我们是指应用源代码的版本？还是指镜像的版本？或者是指某个基础设施即代码（IaC）仓库的版本？进一步地，如果我们要发布一组相互关联的应用，例如前端和后端，或者由多个后端应用组成的系统，如何清晰地描述它们之间的版本依赖关系？\n一旦版本描述不准确，就会引入一系列问题，例如错误的上线版本、混乱的应用依赖关系、无法回滚等。\n大多数团队对于这个问题的解决方案比较模糊：发布最新的版本，先发布后端再发布前端。然而，在一个复杂的业务团队或需要同时保留多个稳定版本的团队中，这种粗暴的方案是无法接受的。\n版本管理不仅解决了版本定位的问题，还可以用于管理应用之间的依赖关系。因此，GitOps 版本管理需要解决以下问题：\n如何构建交付给客户的制品，如何定义这些制品的版本以及如何展示所有版本的制品。 如果有一组软件存在版本依赖关系，如何解决这些依赖问题。 如果一组软件形成了一个系统，如何描述这个系统。 在所有的交付产品中，版本管理都是一个重要问题。我们将逐步拆分版本管理这个命题，并从原始问题过渡到 GitOps 的版本管理最佳实践。\nGitOps 简介 在开始正文之前，我将简要介绍 GitOps，以避免对关键概念的理解出现分歧。\nGitOps 最核心的技术是基础设施即代码（IaC），即使用声明式描述来取代命令式描述。 通常，IaC 的内容基于某种范式，用于描述特定目标的期望状态。这个范式可以是 Terraform、Kubernetes YAML、Pulumi，甚至是 Ansible。而特定目标可以是云服务、Kubernetes，甚至是物理机。 直观的说，通过使用 YAML 取代过去的 Bash 命令，我们可以大大提高变更的准确性和可控性。\n对于 GitOps 来说，是否使用 Git 并不是最重要的，我们也可以使用 SVN 来实现 GitOps。只是 Git 具有更广泛的适用范围，并可以充分发挥 Git 仓库在团队协作和持续集成/持续部署中的能力。\n引入 Git 仓库后，我们还同时拥有了基于 Git Revision / Tag / Branch 的版本管理能力，这体现在业务上就是版本记录、多版本并行管理等方面。\n然而，简单地基于 Git Revision 进行描述还不足以满足我们的实际需求。\n问题的源头 - 二进制文件和启动配置文件 在探索版本的源头时，我们实际上指的是原始代码的版本。\n需要注意的是，这个版本并不是代码所在的版本管理系统（如 Git / Mercurial / SVN 等）的版本。尽管这两者经常相关，但事实上，一份代码本身只是一组代码文件，只要构建成功，就会有一个版本。如果没有定义，那么版本就是未知的，此时与仓库管理没有关联。\n注意：下文我们不再区分 Git / Mercurial / SVN 多种版本管理方案，统一使用 Git 进行描述\n需要注意的是，中文中有两个概念（库和仓库），无论是哪种定义，都没有明确规定一个库一定是一个 Git / SVN 仓库，这意味着我们并没有假设代码库一定是被版本化管理的。当我们将代码文件打包成一个 zip 文件时（GitHub 的 zip 下载就是这种形式），即使这个 zip 文件失去了所有的 Git 历史，它仍然是一个代码库。\n代码的版本实质上是作者的意图表达。目前最常见的管理方案是基于语义化版本。\n我推荐的版本存储方式是使用一个 VERSION 文件将版本存储在代码目录中。例如，Git 的 Version 文件可以清楚地看到当前 Git 的版本是：\nGVF=GIT-VERSION-FILE DEF_VER=v2.42.GIT 其中的 .GIT 也明确说明了这个代码是一个开发模式下的版本。如果我们切换到一个发布版本的代码，例如 v2.39.3 版本，我们可以看到 DEF_VER=v2.39.3，这是一个遵循标准的制品（Artifacts）格式。这里还有两个最佳实践：\n使用文件来保存源代码的版本。 源代码中的版本文件始终处于 dev 模式，只有在进行标记封版之后才会成为正式版本号。 源代码的最终产物不仅包括二进制文件、可执行文件和动态库（.dll / .so / .dylib），还包括相应的启动配置文件。这些启动配置文件通常与对应的版本一起进行管理。例如，Nginx 的启动文件 nginx.conf 和 Redis 的启动文件 redis.conf，这些启动配置文件也应该纳入版本管理。\n从源代码仓库构建出来的内容就是制品（Artifacts）。制品已经具有两个版本：\n源代码版本，即使用 VERSION 文件中定义的版本。 源代码仓库版本，即 Git Revision 制品的版本管理 引入制品版本管理后，问题变得更加复杂，因为制品带来了更多的问题：\n制品是什么，由什么构成？（上文已经回答） 制品如何进行安装，安装程序（Installer）是什么，运行时（Runtime）是什么？ 制品信息如何进行集中管理，数据如何管理？ 制品之间是否存在依赖关系，如何处理依赖关系，版本如何约束？ 制品的概念非常重要，其中最核心的一个理念是：制品可以通过打包器形成新的制品。\n由于制品具有版本，而新的制品将形成新的版本，我们将进入多层嵌套。为了避免最原始的版本信息丢失，我们将 Version 的概念扩展为 Upstream Version，这是软件作者人为指定的版本，是所有版本的源头。\n为什么制品可以形成新的制品呢？我举一个 Kubernetes 容器环境下的例子。 容器是一种交付形式，它将可执行文件和启动配置文件写入镜像文件中，并可以在容器环境中运行。形成的镜像文件存在于镜像仓库中，本身也是一种制品。\n另外，Helm / Kustomize 也是一种交付形式（打包工具链）。 每个构建层解决其特定问题，并且可以在特定环境（例如容器、Kubernetes、云基础设施）中运行。\n每个制品都需要构建，过程中会有自己的额外描述信息（Packaging Info），这些额外的描述信息本身也会发生变化，因此会增加一个版本。在实践中，我们希望制品的版本与其上游版本绑定。每种打包机制可能会包含自己的一些定义配置，但仍然遵循上游的版本。例如，Kubernetes 的 Workload 包含一个镜像，Workload 的描述是附加信息，而镜像仍然受到上游控制。\nArtifact + Packaging Info = New Artifact，制品经过打包可以形成新的制品。直到最后的 Installer 放置到相应的环境中生效。\n如果这些制品可以通过文件（IaC）进行描述，那么就形成了各种 IaC 仓库，这些仓库成为了 GitOps 的核心对象。\n概念梳理 让我们来理清一下这些略有晦涩的概念：\n中文 英文 解释 源代码 Source Code 程序、应用的源文件集合 代码仓库 Source Code Repo 源代码放到版本管理系统中的管理单元 版本 Version 源代码对应的应用版本，人为定义，语义化，有些场景会说 Upstream Version 可执行文件 Executable File 源代码构建出来的结果，一般是 ELF 可执行文件，也可以是 Lib 文件 启动配置文件 Configuration File 配套 ELF / Lib 的启动配置文件，区别于广泛意义上的配置文件（比如 Kubernetes YAML） 制品 Artifact 包含可执行文件和启动配置文件的集合，可以运行在运行时下面，一般是文件形态。制品可以嵌套制品。 安装器 Installer 将制品安装到运行时的工具 运行时 Runtime 制品的运行环境，比如特定操作系统，Kubernetes，Docker Engine。 打包器 Packer 将制品打包成特定格式（新的制品）的工具 打包附属信息 Packaging Info 制品打包时候需要的额外信息，比如容器的操作系统，进程的运行容量，默认环境变量等 这些概念共同构成了制品版本管理的核心要素，帮助我们管理和跟踪制品的不同版本，以及它们之间的关联和依赖关系。\n打包器 Packer 打包器是一种工具，通过打包操作（Packaging）将制品组织成特定的格式，形成全新的制品。 打包的过程涉及编译、链接、合并和存档等常见概念。\n它通常以上游（Upstream）作为输入，上游可以是源码，也可以是其他系统生成的制品（Artifacts）。\n例如，在打包 Docker Compose 时，输入是镜像（Image），而对于 Helm，输入则包括镜像、启动配置文件和 Helm 模板，而输出则是 YAML 文件。\n制品 Artifacts 制品是一种数据集合，可以在特定环境中运行。 它由可执行文件和启动配置文件等组成，通常以文件形式存在，并且可以在运行时环境下运行。制品具有嵌套的能力，可以包含其他制品。\n最常见的形态是二进制文件（ELF），也可以是适用于特定环境的运行物，如容器镜像。\n制品通常以文件形式进行传输。\n安装器 Installer 安装器是一种工具，用于将制品安装到运行时环境中。 它负责将制品部署到目标环境并确保其正常运行。 例如，dpkg、Pacman 是常见的安装器工具，而在 Windows 平台上，我们常见自引导的安装器。\n对于特定的环境如 Kubernetes，我们可以使用 kubectl 命令进行安装，而 Helm 则使用helm命令来进行安装。\nLinux 社区实践 当我们理解了这些概念后，我们或许会惊讶地发现，这些概念与 Linux 社区多年来的实践是如此相似。抛开云原生等新概念，Linux 社区早就拥有了完整的解决方案。\n自豪地使用 ArchLinux。\nArch Linux 社区的实践 Arch Linux 使用 Pacman 作为包安装器，并且拥有一套完整的构建方案。\n在 Arch Linux 中，PKGBUILD link用于描述包的构建方式，它本身是 Bash 的子集，是描述包的核心文件。\n版本管理方面，Arch Linux 提供了清晰明确的方案，并且设计了完整的制品嵌套解决方案。 在 PKGBUILD 中，pkgver 表示上游版本，并经过适当的修正，使用 _ 替代 -，并调整了时间戳的格式。而 pkgrel 则表示发布号，而不是构建号，每次发布都会增加该号码，用于管理 Arch Linux 的发布动作。当大部分 PKGBUILD 发生变化时，发布号都会发生变化。\n此外，epoch 是一个强制构建版本的机制，默认为 0 并且隐藏起来。使用 epoch 是一种兜底的解决方案，通过破坏版本对比来强制进行新版本的升级。\n另外，在 PKGBUILD 中，使用了版本依赖的方式来优雅地解决模块的问题。 例如，base-devel 包是对 26 个基础软件的依赖，而该包本身并没有具体的内容。这种方案非常优雅，避免了引入一个新的模型（比如叫做 Group / 产品）。\n基于 GitOps 的版本管理解决方案 最后让我们回归到 GitOps 版本管理本身，让我们重新面对文中的几个问题，通过以上的分析和调研，是否已经解决了这些问题呢？\n交付给客户的制品如何构成，如何定义这个制品的版本，以及如何呈现所有版本的制品？ 使用 VERSION 文件来确定软件版本，也就是上游版本（Upstream Version） 不同形式的制品有独立的版本号，这些版本号需要与上游版本关联。例如，可以使用 v1.2.3-afe12c 的形式来追踪 Git 仓库中的版本，使用 v1.2.3-afe12c-b1 来追踪镜像构建物的版本。 如果存在一组软件，如何解决这组软件之间的版本依赖问题？ 这个问题可以交给具体的安装器处理，一般这些元信息会在对应的打包信息（Packaging Info）中定义，并由 Installer 识别和处理。 如果一组软件形成了一套体系，如何表达这个体系？ 可以创建一个没有上游版本的新制品，其中交付的内容可能为空，但包含相应的打包信息和依赖信息。 （或者）也可以真正抽象出一个新的概念来进行管理，这取决于打包器和安装器之间的协作。 最后的 GitOps 题外话 我们经常提到 GitOps，那么 GitOps 究竟解决了什么问题呢？是打包？发布？还是版本定义？\n我认为 GitOps 的核心在于 IaC ，它提供了一种以终态描述的视角来描述我们期望系统处于的状态，并且这种期望是可透明、可持久化和可编程的。在 IaC 出现之前，我们可以使用传统的 Deb、RPM 等方式来完成部署，只是不太关注定制化配置和配置漂移检测的问题。\n每一层制品都会引入新的配置（Config）/ 扩展（Extension）/ 值（Values）/ 环境变量（Env）等等，无论如何称呼，我们统一称之为配置。这种不确定性在大规模系统中是不稳定的，因此 GitOps 的版本管理显得尤为重要。而这些新加入的 Packaging Info 的描述在大规模集群管理下也带来了新的问题。Terraform 的 HCL 提供了一套描述抽象的 DSL，Google 的 CUE 也是尝试提供一套抽象的方案，而蚂蚁金服的 KCL 也是一种描述抽象。 Pulumi 则放弃了 DSL 的抽象，转而使用通用编程语言来描述。\n就像当年的 RPM / DEB / PKGBUILD 一样。\n复杂性是不会消失的，只是以另一种形式存在或被隐藏起来。好的抽象解决问题，而不好的抽象则会带来问题。当我们被新事物迷惑时，也许我们可以回头看看那些老家伙（如 Arch Linux、Debian、CentOS），他们是如何解决各种复杂问题的。\n换个领域来描述，程序的依赖管理（Lib Dependencies）也是一个复杂的系统。有些人抱怨 Maven 太复杂，go.mod 难以使用，pip 太简单不够用，而 node_modules 则是个黑洞。\n依然是同样的道理，复杂性无法消除，留给用户的只有掌控或随缘了。\n",
  "wordCount" : "5108",
  "inLanguage": "en",
  "datePublished": "2023-09-23T18:22:27+08:00",
  "dateModified": "2023-09-23T18:22:27+08:00",
  "author":{
    "@type": "Person",
    "name": "alswl"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.alswl.com/2023/09/gitops-and-version-management/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Log4D",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.alswl.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.alswl.com" accesskey="h" title="Log4D (Alt + H)">Log4D</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://en.blog.alswl.com/" title="English Blog">
                    <span>English Blog</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/archives/" title="存档">
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/about/" title="关于我">
                    <span>关于我</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.alswl.com">Home</a>&nbsp;»&nbsp;<a href="https://blog.alswl.com/posts/">Posts</a></div>
    <h1 class="post-title">
      GitOps 和版本管理
    </h1>
    <div class="post-meta"><span title='2023-09-23 18:22:27 +0800 +0800'>2023-09-23</span>&nbsp;·&nbsp;alswl

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#版本问题">版本问题</a></li>
    <li><a href="#gitops-简介">GitOps 简介</a></li>
    <li><a href="#问题的源头---二进制文件和启动配置文件">问题的源头 - 二进制文件和启动配置文件</a></li>
    <li><a href="#制品的版本管理">制品的版本管理</a></li>
    <li><a href="#概念梳理">概念梳理</a>
      <ul>
        <li><a href="#打包器-packer">打包器 Packer</a></li>
        <li><a href="#制品-artifacts">制品 Artifacts</a></li>
        <li><a href="#安装器-installer">安装器 Installer</a></li>
      </ul>
    </li>
    <li><a href="#linux-社区实践">Linux 社区实践</a>
      <ul>
        <li><a href="#arch-linux-社区的实践">Arch Linux 社区的实践</a></li>
      </ul>
    </li>
    <li><a href="#基于-gitops-的版本管理解决方案">基于 GitOps 的版本管理解决方案</a></li>
    <li><a href="#最后的-gitops-题外话">最后的 GitOps 题外话</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/202309/car.png" alt="car"  />


</p>
<p><small>image via <a href="https://www.shipvehicles.com/step-by-step-guide-for-state-to-state-transport/">shipvehicles</a></small></p>
<p>如何使用 GitOps 管理交付内容版本是一个常见的问题。一个简单的回答是使用 Git 进行版本管理，并通过 Git Tag 来跟踪仓库内容的版本。虽然这可以解决一些问题，但在云原生技术的推动下，版本的概念远非如此简单。</p>
<h2 id="版本问题">版本问题<a hidden class="anchor" aria-hidden="true" href="#版本问题">#</a></h2>
<p>在引入 GitOps 到 DevOps 流程后，我们可以借助 GitOps 的能力进行持续集成和持续交付。
GitOps 解决了三个核心问题：内容、版本和协作。然而，我们经常将注意力集中在内容上，却经常忽略了版本管理问题。</p>
<p>那么，在 GitOps 过程中，有哪些版本管理问题需要解决呢？</p>
<p>一套完整的 GitOps 解决方案包括内容描述（Manifest）、构建方案（Builder）和生效方案（Applier）。其中，内容描述衍生出多种描述语言，从最传统的 <a href="https://www.ansible.com/">Ansible</a> / <a href="https://www.chef.io/products/chef-infra">Chef</a>，到云计算和云原生流行起来的 <a href="https://www.terraform.io/">Terraform</a>、<a href="https://helm.sh/">Helm</a>、<a href="https://kustomize.io/">Kustomize</a> 等。引入了这么多内容描述方式之后，当我们想要明确一个应用的版本时，变得非常复杂。</p>
<p>当提到版本时，我们是<mark>指应用源代码的版本？还是指镜像的版本？或者是指某个基础设施即代码（IaC）仓库的版本</mark>？进一步地，如果我们要发布一组相互关联的应用，例如前端和后端，或者由多个后端应用组成的系统，如何清晰地描述它们之间的<mark>版本依赖关系</mark>？</p>
<p>一旦版本描述不准确，就会引入一系列问题，例如错误的上线版本、混乱的应用依赖关系、无法回滚等。</p>
<p>大多数团队对于这个问题的解决方案比较模糊：发布最新的版本，先发布后端再发布前端。然而，在一个复杂的业务团队或需要同时保留多个稳定版本的团队中，这种粗暴的方案是无法接受的。</p>
<p>版本管理不仅解决了<mark>版本定位</mark>的问题，还可以用于管理应用之间的<mark>依赖关系</mark>。因此，GitOps 版本管理需要解决以下问题：</p>
<ul>
<li>如何构建交付给客户的制品，如何定义这些制品的版本以及如何展示所有版本的制品。</li>
<li>如果有一组软件存在版本依赖关系，如何解决这些依赖问题。</li>
<li>如果一组软件形成了一个系统，如何描述这个系统。</li>
</ul>
<p>在所有的交付产品中，版本管理都是一个重要问题。我们将逐步拆分版本管理这个命题，并从原始问题过渡到 GitOps 的版本管理最佳实践。</p>
<h2 id="gitops-简介">GitOps 简介<a hidden class="anchor" aria-hidden="true" href="#gitops-简介">#</a></h2>
<p>在开始正文之前，我将简要介绍 GitOps，以避免对关键概念的理解出现分歧。</p>
<p>GitOps 最核心的技术是<mark>基础设施即代码（IaC）</mark>，即使用声明式描述来取代命令式描述。
通常，IaC 的内容基于某种范式，用于描述特定目标的期望状态。这个范式可以是 Terraform、Kubernetes YAML、<a href="https://www.pulumi.com/">Pulumi</a>，甚至是 Ansible。而特定目标可以是云服务、Kubernetes，甚至是物理机。
直观的说，通过使用 YAML 取代过去的 Bash 命令，我们可以大大提高变更的准确性和可控性。</p>
<p>对于 GitOps 来说，是否使用 Git 并不是最重要的，我们也可以使用 SVN 来实现 GitOps。只是 Git 具有更广泛的适用范围，并可以充分发挥 Git 仓库在团队协作和持续集成/持续部署中的能力。</p>
<p>引入 Git 仓库后，我们还同时拥有了基于 Git Revision / Tag / Branch 的版本管理能力，这体现在业务上就是版本记录、多版本并行管理等方面。</p>
<p>然而，简单地基于 Git Revision 进行描述还不足以满足我们的实际需求。</p>
<h2 id="问题的源头---二进制文件和启动配置文件">问题的源头 - 二进制文件和启动配置文件<a hidden class="anchor" aria-hidden="true" href="#问题的源头---二进制文件和启动配置文件">#</a></h2>
<p>在探索版本的源头时，我们实际上指的是原始代码的版本。</p>
<p>需要注意的是，这个版本并不是代码所在的版本管理系统（如 Git / Mercurial / SVN 等）的版本。尽管这两者经常相关，但事实上，一份代码本身只是一组代码文件，只要构建成功，就会有一个版本。如果没有定义，那么版本就是未知的，此时与仓库管理没有关联。</p>
<blockquote>
<p>注意：下文我们不再区分 Git / Mercurial / SVN 多种版本管理方案，统一使用 Git 进行描述</p>
</blockquote>
<p>需要注意的是，中文中有两个概念（库和仓库），无论是哪种定义，都没有明确规定一个库一定是一个 Git / SVN 仓库，这意味着我们并没有假设代码库一定是被版本化管理的。当我们将代码文件打包成一个 zip 文件时（GitHub 的 zip 下载就是这种形式），即使这个 zip 文件失去了所有的 Git 历史，它仍然是一个代码库。</p>
<p>代码的版本实质上是<mark>作者的意图表达</mark>。目前最常见的管理方案是基于<a href="https://semver.org/">语义化版本</a>。</p>
<p>我推荐的版本存储方式是使用一个 <code>VERSION</code> 文件将版本存储在代码目录中。例如，Git 的 <a href="https://github.com/git/git/blob/master/GIT-VERSION-GEN">Version</a> 文件可以清楚地看到当前 Git 的版本是：</p>
<pre tabindex="0"><code>GVF=GIT-VERSION-FILE
DEF_VER=v2.42.GIT
</code></pre><p>其中的 <code>.GIT</code> 也明确说明了这个代码是一个开发模式下的版本。如果我们切换到一个发布版本的代码，例如 <a href="https://github.com/git/git/blob/v2.39.3/GIT-VERSION-GEN">v2.39.3</a> 版本，我们可以看到 <code>DEF_VER=v2.39.3</code>，这是一个遵循标准的制品（Artifacts）格式。这里还有两个最佳实践：</p>
<ul>
<li>使用文件来保存源代码的版本。</li>
<li>源代码中的版本文件始终处于 <code>dev</code> 模式，只有在进行标记封版之后才会成为正式版本号。</li>
</ul>
<p>源代码的最终产物不仅包括二进制文件、可执行文件和动态库（<code>.dll</code> / <code>.so</code> / <code>.dylib</code>），还包括相应的启动配置文件。这些启动配置文件通常与对应的版本一起进行管理。例如，Nginx 的启动文件 <code>nginx.conf</code> 和 Redis 的启动文件 <code>redis.conf</code>，这些启动配置文件也应该纳入版本管理。</p>
<p>从源代码仓库构建出来的内容就是制品（Artifacts）。制品已经具有两个版本：</p>
<ul>
<li>源代码版本，即使用 <code>VERSION</code> 文件中定义的版本。</li>
<li>源代码仓库版本，即 Git Revision</li>
</ul>
<h2 id="制品的版本管理">制品的版本管理<a hidden class="anchor" aria-hidden="true" href="#制品的版本管理">#</a></h2>
<p>引入制品版本管理后，问题变得更加复杂，因为制品带来了更多的问题：</p>
<ul>
<li>制品是什么，由什么构成？（上文已经回答）</li>
<li>制品如何进行安装，安装程序（Installer）是什么，运行时（Runtime）是什么？</li>
<li>制品信息如何进行集中管理，数据如何管理？</li>
<li>制品之间是否存在依赖关系，如何处理依赖关系，版本如何约束？</li>
</ul>
<p>制品的概念非常重要，其中最核心的一个理念是：<mark>制品可以通过打包器形成新的制品</mark>。</p>
<p>由于制品具有版本，而新的制品将形成新的版本，我们将进入多层嵌套。为了避免最原始的版本信息丢失，我们将 Version 的概念扩展为 <mark>Upstream Version</mark>，这是软件作者人为指定的版本，是所有版本的源头。</p>
<p>为什么制品可以形成新的制品呢？我举一个 Kubernetes 容器环境下的例子。
容器是一种交付形式，它将可执行文件和启动配置文件写入镜像文件中，并可以在容器环境中运行。形成的镜像文件存在于镜像仓库中，本身也是一种制品。</p>
<p>另外，Helm / Kustomize 也是一种交付形式（打包工具链）。
每个构建层解决其特定问题，并且可以在特定环境（例如容器、Kubernetes、云基础设施）中运行。</p>
<p>每个制品都需要构建，过程中会有自己的<mark>额外描述信息（Packaging Info）</mark>，这些额外的描述信息本身也会发生变化，因此会增加一个版本。在实践中，我们希望制品的版本与其上游版本绑定。每种打包机制可能会包含自己的一些定义配置，但仍然遵循上游的版本。例如，Kubernetes 的 Workload 包含一个镜像，Workload 的描述是附加信息，而镜像仍然受到上游控制。</p>
<p><mark>Artifact + Packaging Info = New Artifact</mark>，制品经过打包可以形成新的制品。直到最后的 Installer 放置到相应的环境中生效。</p>
<p>如果这些制品可以通过文件（IaC）进行描述，那么就形成了各种 IaC 仓库，这些仓库成为了 GitOps 的核心对象。</p>
<h2 id="概念梳理">概念梳理<a hidden class="anchor" aria-hidden="true" href="#概念梳理">#</a></h2>
<p>让我们来理清一下这些略有晦涩的概念：</p>
<table>
<thead>
<tr>
<th>中文</th>
<th>英文</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>源代码</td>
<td>Source Code</td>
<td>程序、应用的源文件集合</td>
</tr>
<tr>
<td>代码仓库</td>
<td>Source Code Repo</td>
<td>源代码放到版本管理系统中的管理单元</td>
</tr>
<tr>
<td>版本</td>
<td>Version</td>
<td>源代码对应的应用版本，人为定义，语义化，有些场景会说 Upstream Version</td>
</tr>
<tr>
<td>可执行文件</td>
<td>Executable File</td>
<td>源代码构建出来的结果，一般是 ELF 可执行文件，也可以是 Lib 文件</td>
</tr>
<tr>
<td>启动配置文件</td>
<td>Configuration File</td>
<td>配套 ELF / Lib 的启动配置文件，区别于广泛意义上的配置文件（比如 Kubernetes YAML）</td>
</tr>
<tr>
<td>制品</td>
<td>Artifact</td>
<td>包含可执行文件和启动配置文件的集合，可以运行在运行时下面，一般是文件形态。制品可以嵌套制品。</td>
</tr>
<tr>
<td>安装器</td>
<td>Installer</td>
<td>将制品安装到运行时的工具</td>
</tr>
<tr>
<td>运行时</td>
<td>Runtime</td>
<td>制品的运行环境，比如特定操作系统，Kubernetes，Docker Engine。</td>
</tr>
<tr>
<td>打包器</td>
<td>Packer</td>
<td>将制品打包成特定格式（新的制品）的工具</td>
</tr>
<tr>
<td>打包附属信息</td>
<td>Packaging Info</td>
<td>制品打包时候需要的额外信息，比如容器的操作系统，进程的运行容量，默认环境变量等</td>
</tr>
</tbody>
</table>
<p>这些概念共同构成了制品版本管理的核心要素，帮助我们管理和跟踪制品的不同版本，以及它们之间的关联和依赖关系。</p>
<h3 id="打包器-packer">打包器 Packer<a hidden class="anchor" aria-hidden="true" href="#打包器-packer">#</a></h3>
<p>打包器是一种工具，通过打包操作（Packaging）将制品组织成特定的格式，形成全新的制品。
打包的过程涉及编译、链接、合并和存档等常见概念。</p>
<p>它通常以上游（Upstream）作为输入，上游可以是源码，也可以是其他系统生成的制品（Artifacts）。</p>
<p>例如，在打包 Docker Compose 时，输入是镜像（Image），而对于 Helm，输入则包括镜像、启动配置文件和 Helm 模板，而输出则是 YAML 文件。</p>
<h3 id="制品-artifacts">制品 Artifacts<a hidden class="anchor" aria-hidden="true" href="#制品-artifacts">#</a></h3>
<p>制品是一种数据集合，可以在特定环境中运行。
它由可执行文件和启动配置文件等组成，通常以文件形式存在，并且可以在运行时环境下运行。制品具有嵌套的能力，可以包含其他制品。</p>
<p>最常见的形态是二进制文件（ELF），也可以是适用于特定环境的运行物，如容器镜像。</p>
<p>制品通常以文件形式进行传输。</p>
<h3 id="安装器-installer">安装器 Installer<a hidden class="anchor" aria-hidden="true" href="#安装器-installer">#</a></h3>
<p>安装器是一种工具，用于将制品安装到运行时环境中。
它负责将制品部署到目标环境并确保其正常运行。
例如，dpkg、Pacman 是常见的安装器工具，而在 Windows 平台上，我们常见自引导的安装器。</p>
<p>对于特定的环境如 Kubernetes，我们可以使用 kubectl 命令进行安装，而 Helm 则使用<code>helm</code>命令来进行安装。</p>
<h2 id="linux-社区实践">Linux 社区实践<a hidden class="anchor" aria-hidden="true" href="#linux-社区实践">#</a></h2>
<p>当我们理解了这些概念后，我们或许会惊讶地发现，这些概念与 Linux 社区多年来的实践是如此相似。抛开云原生等新概念，Linux 社区早就拥有了完整的解决方案。</p>
<blockquote>
<p>自豪地使用 ArchLinux。</p>
</blockquote>
<h3 id="arch-linux-社区的实践">Arch Linux 社区的实践<a hidden class="anchor" aria-hidden="true" href="#arch-linux-社区的实践">#</a></h3>
<p>Arch Linux 使用 <a href="https://wiki.archlinux.org/title/Pacman">Pacman</a> 作为包安装器，并且拥有一套完整的<a href="https://wiki.archlinux.org/title/Arch_build_system">构建方案</a>。</p>
<p>在 Arch Linux 中，<code>PKGBUILD</code> <a href="https://wiki.archlinux.org/title/PKGBUILD">link</a>用于描述包的构建方式，它本身是 Bash 的子集，是描述包的核心文件。</p>
<p>版本管理方面，Arch Linux 提供了清晰明确的方案，并且设计了完整的<mark>制品嵌套</mark>解决方案。
在 <code>PKGBUILD</code> 中，<code>pkgver</code> 表示上游版本，并经过适当的修正，使用 <code>_</code> 替代 <code>-</code>，并调整了时间戳的格式。而 <code>pkgrel</code> 则表示发布号，而不是构建号，每次发布都会增加该号码，用于管理 Arch Linux 的发布动作。当大部分 <code>PKGBUILD</code> 发生变化时，发布号都会发生变化。</p>
<p>此外，<code>epoch</code> 是一个强制构建版本的机制，默认为 0 并且隐藏起来。使用 <code>epoch</code> 是一种兜底的解决方案，通过破坏版本对比来强制进行新版本的升级。</p>
<p>另外，在 <code>PKGBUILD</code> 中，使用了版本依赖的方式来优雅地解决模块的问题。
例如，<code>base-devel</code> 包是对 26 个基础软件的依赖，而<a href="https://gitlab.archlinux.org/archlinux/packaging/packages/base-devel/-/blob/main/PKGBUILD">该包本身</a>并<mark>没有具体的内容</mark>。这种方案非常优雅，避免了引入一个新的模型（比如叫做 Group / 产品）。</p>
<h2 id="基于-gitops-的版本管理解决方案">基于 GitOps 的版本管理解决方案<a hidden class="anchor" aria-hidden="true" href="#基于-gitops-的版本管理解决方案">#</a></h2>
<p>最后让我们回归到 GitOps 版本管理本身，让我们重新面对文中的几个问题，通过以上的分析和调研，是否已经解决了这些问题呢？</p>
<ul>
<li>交付给客户的制品如何构成，如何定义这个制品的版本，以及如何呈现所有版本的制品？
<ul>
<li>使用 <code>VERSION</code> 文件来确定软件版本，也就是上游版本（Upstream Version）</li>
<li>不同形式的制品有独立的版本号，这些版本号需要与上游版本关联。例如，可以使用 <code>v1.2.3-afe12c</code> 的形式来追踪 Git 仓库中的版本，使用 <code>v1.2.3-afe12c-b1</code> 来追踪镜像构建物的版本。</li>
</ul>
</li>
<li>如果存在一组软件，如何解决这组软件之间的版本依赖问题？
<ul>
<li>这个问题可以交给具体的安装器处理，一般这些元信息会在对应的打包信息（Packaging Info）中定义，并由 Installer 识别和处理。</li>
</ul>
</li>
<li>如果一组软件形成了一套体系，如何表达这个体系？
<ul>
<li>可以创建一个没有上游版本的新制品，其中交付的内容可能为空，但包含相应的打包信息和依赖信息。</li>
<li>（或者）也可以真正抽象出一个新的概念来进行管理，这取决于打包器和安装器之间的协作。</li>
</ul>
</li>
</ul>
<h2 id="最后的-gitops-题外话">最后的 GitOps 题外话<a hidden class="anchor" aria-hidden="true" href="#最后的-gitops-题外话">#</a></h2>
<p>我们经常提到 GitOps，那么 GitOps 究竟解决了什么问题呢？是打包？发布？还是版本定义？</p>
<p>我认为 GitOps 的核心在于 IaC ，它提供了一种以终态描述的视角来描述我们期望系统处于的状态，并且这种期望是可透明、可持久化和可编程的。在 IaC 出现之前，我们可以使用传统的 Deb、RPM 等方式来完成部署，只是不太关注定制化配置和配置漂移检测的问题。</p>
<p>每一层制品都会引入新的配置（Config）/ 扩展（Extension）/ 值（Values）/ 环境变量（Env）等等，无论如何称呼，我们统一称之为配置。这种不确定性在大规模系统中是不稳定的，因此 GitOps 的版本管理显得尤为重要。而这些新加入的 Packaging Info 的描述在大规模集群管理下也带来了新的问题。Terraform 的 <a href="https://github.com/hashicorp/hcl/blob/main/hclsyntax/spec.md">HCL</a> 提供了一套描述抽象的 DSL，Google 的 <a href="https://github.com/cue-lang/cue">CUE</a> 也是尝试提供一套抽象的方案，而蚂蚁金服的 <a href="https://github.com/kcl-lang/kcl">KCL</a> 也是一种描述抽象。 <a href="https://www.pulumi.com/">Pulumi</a> 则放弃了 DSL 的抽象，转而使用通用编程语言来描述。</p>
<p>就像当年的 RPM / DEB / PKGBUILD 一样。</p>
<p><mark>复杂性是不会消失的，只是以另一种形式存在或被隐藏起来</mark>。好的抽象解决问题，而不好的抽象则会带来问题。当我们被新事物迷惑时，也许我们可以回头看看那些老家伙（如 Arch Linux、Debian、CentOS），他们是如何解决各种复杂问题的。</p>
<p>换个领域来描述，程序的依赖管理（Lib Dependencies）也是一个复杂的系统。有些人抱怨 Maven 太复杂，<code>go.mod</code> 难以使用，<code>pip</code> 太简单不够用，而 <code>node_modules</code> 则是个黑洞。</p>
<p>依然是同样的道理，复杂性无法消除，留给用户的只有掌控或随缘了。</p>

<hr />
<p>原文链接: <a href="https://blog.alswl.com/2023/09/gitops-and-version-management/">GitOps 和版本管理 | Log4D</a></p>
<p>3a1ff193cee606bd1e2ea554a16353ee</p>
<p>欢迎关注我的微信公众号：<a
href="http://mp.weixin.qq.com/mp/getmasssendmsg?__biz=MzIyNTIwMTU3MQ==#wechat_webview_type=1&amp;wechat_redirect">窥豹</a></p>
<figure>
<img
src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201605/qrcode_for_gh_17e2f9c2caa4_258.jpg"
alt="窥豹" />
<figcaption aria-hidden="true">窥豹</figcaption>
</figure>

    
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.alswl.com/tags/design/">Design</a></li>
      <li><a href="https://blog.alswl.com/tags/architecture/">Architecture</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://blog.alswl.com/2023/07/architecture-design-the-easy-way/">
    <span class="title">Next »</span>
    <br>
    <span>架构设计 the Easy Way</span>
  </a>
</nav>

  </footer><div id="waline"></div>
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';

    
    
    init({
      el: '#waline',
      serverURL: 'https://comments-waline.blog.alswl.com',
      emoji: false,
      search: false,
      reaction: true, 
      requiredMeta: ['nick', 'mail'],
      login: 'disable',
      imageUploader: false,
      texRenderer: false,
    });
</script>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://blog.alswl.com">Log4D</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
