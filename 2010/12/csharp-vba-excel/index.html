<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C#+VBA操作Excel总结 | Log4D</title><meta name=keywords content="dotnet,excel,office,vba"><meta name=description content="Excel在日常办公中应用非常广泛，这次我接到一个案子，需要往Excel中写入数据并能够打印出固定格式，前前后后大概花了将近2星期才搞定，现在做一些分享。
一、关于操作Excel的几种方式 我们导出Excel，大抵是有两种方法，一种是在服务器端用一些类库或者COM组件直接生成Excel成品，其二是在后台只写入数据，而不写入具体格式，等用户下载完 Excel之后再在客户端上利用vba生成Excel成品。
1.1使用&#34;自动化&#34;功能-后台生成成品 微软把后台使用COM组件称之为&#34;自动化&#34;，其实它本身是不建议这种用法，在257757 号文章（服务器端 Office 自动化注意事项）也明文标出&#34;Microsoft 目前建议不要从任何无人参与的、非交互式客户端应用程序或组件（包括 ASP、DCOM 和 NT Service）中进行 Microsoft Office 应用程序的&#34;自动化&#34;，也不为此提供支持，因为 Office 在这种环境中运行时可能会出现不稳定的现象并且/或者会死锁。&#34;
这种方法的优点是给用户更简洁的展现，毕竟原生的Excel成品比半成品来更容易接受，而且可以避免宏安全问题，万一客户端禁止了宏，就只能看到丑陋的模板界面+一坨 数据。
缺点是需要服务端支持，编写成本也比较高（VBA有时候可以直接录制）。服务端支持体现在需要安装一些微软或者第三方的类库。我当时采用的是Office类库，也就是 在安装有Office的机器上面使用Interop.Excel.dll这个中间动态链接库进行操作，需要麻烦的安全设置，效率低不说还会扯出Excel无法关闭的B ug。
关于效率低我深有体会，我使用这种方法生成5页数据大约2m，客户等的急死，其根本原因是由于COM组件在调用时候，每一个Range这种对象都会产生一个借口请求。
1.2、使用ADO.net传输数据+VBA控制模板和数据 这方法的优缺点正好与上文相反，由于只是写入数据，即通过ADO.net的连接方式INSERT一堆数据到Excel文件的隐藏Sheet里面去（别跟我说你不知道E xcel可以隐藏某个Sheet），所以速度后台速度极快。前台Excel文件虽然需要VBA编程支持，但是在理解Excel模型之后也不是很难的事情。
1.3 选择哪种方式，取决于你的需求，如果你在Java平台下面并且输出文件页面格式不复杂，我推荐第一种，如果是.net平台又或者要处理复杂的页面样式，就选用第二种吧 （我前期使用第一种，后来因为效率问题和无法关闭Excel的问题，重写逻辑，选用第二种）。
关于Excel导出方案的选择，微软官方也是不建议使用第一种方案，甚至不提供技术支持。它推荐了一些方案，包括使用报表导出Excel或者ADO.net方式导出（ 即第二种），具体文章见如何使用 Visual C# 2005 或 Visual C# .NET 向 Excel 工作簿传输数据。
二、Office Excel文档模型 在写操作Excel代码之前，需要了解一下Excel的文档模型，才能想当然的把代码写出来。
简单说来，我们只要了解Application 、Workbook 、Worksheet 、Range这四种类型，如果需要操作图像的话，还需要多了解一种Chart。
Application就是Excel实例，不仅仅是一个Excel文件，而是整体的Excel程序（Office都是MDI文档体系）。
WorkBook就是实质意义上的某个Excel文件，你可以进行保存操作等等。
Worksheet是某个工作簿类型。
Range是我们打交道最多的，可以理解成一个区域快，也就是常见的&#34;A2:B5&#34;这种表示方式。
了解这几种之后，我们就可以下手操作了。更详细的微软官方文档，可以在Excel 对象模型概述找到。
三、使用C#操作Excel 我虽然不推荐第一种，但是毕竟是一种解决方案。
需要使用的命名空间为using Excel = Microsoft.Office.Interop.Excel;（使用别名简化一下）
另外需要项目引用Office的类库，如果不是项目形式而是网站形式，则需要手动编译对应Interop.Excel.dll到网站bin目录下面，我使用Excel 2007编译出这个链接库，版本为1.6.0.0，需要的可以点击Interop.Excel.dll下载。
3.1 编译Interop.Excel.dll 编译的方法出自于&#34;[使用Office组件读取Excel，引用Microsoft.Office.Interop.Excel出现的问题](http://www. cnblogs.com/Mainz/archive/2009/11/11/Microsoft_Office_Interop_Excel.html)&#34;&nbs p_place_holder;
进入你的visual studio的sdk下的bin目录，找到TlbImp."><meta name=author content="alswl"><link rel=canonical href=https://blog.alswl.com/2010/12/csharp-vba-excel/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.alswl.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.alswl.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.alswl.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.alswl.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.alswl.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-8822123-3","auto"),ga("send","pageview"))</script><meta property="og:title" content="C#+VBA操作Excel总结"><meta property="og:description" content="Excel在日常办公中应用非常广泛，这次我接到一个案子，需要往Excel中写入数据并能够打印出固定格式，前前后后大概花了将近2星期才搞定，现在做一些分享。
一、关于操作Excel的几种方式 我们导出Excel，大抵是有两种方法，一种是在服务器端用一些类库或者COM组件直接生成Excel成品，其二是在后台只写入数据，而不写入具体格式，等用户下载完 Excel之后再在客户端上利用vba生成Excel成品。
1.1使用&#34;自动化&#34;功能-后台生成成品 微软把后台使用COM组件称之为&#34;自动化&#34;，其实它本身是不建议这种用法，在257757 号文章（服务器端 Office 自动化注意事项）也明文标出&#34;Microsoft 目前建议不要从任何无人参与的、非交互式客户端应用程序或组件（包括 ASP、DCOM 和 NT Service）中进行 Microsoft Office 应用程序的&#34;自动化&#34;，也不为此提供支持，因为 Office 在这种环境中运行时可能会出现不稳定的现象并且/或者会死锁。&#34;
这种方法的优点是给用户更简洁的展现，毕竟原生的Excel成品比半成品来更容易接受，而且可以避免宏安全问题，万一客户端禁止了宏，就只能看到丑陋的模板界面+一坨 数据。
缺点是需要服务端支持，编写成本也比较高（VBA有时候可以直接录制）。服务端支持体现在需要安装一些微软或者第三方的类库。我当时采用的是Office类库，也就是 在安装有Office的机器上面使用Interop.Excel.dll这个中间动态链接库进行操作，需要麻烦的安全设置，效率低不说还会扯出Excel无法关闭的B ug。
关于效率低我深有体会，我使用这种方法生成5页数据大约2m，客户等的急死，其根本原因是由于COM组件在调用时候，每一个Range这种对象都会产生一个借口请求。
1.2、使用ADO.net传输数据+VBA控制模板和数据 这方法的优缺点正好与上文相反，由于只是写入数据，即通过ADO.net的连接方式INSERT一堆数据到Excel文件的隐藏Sheet里面去（别跟我说你不知道E xcel可以隐藏某个Sheet），所以速度后台速度极快。前台Excel文件虽然需要VBA编程支持，但是在理解Excel模型之后也不是很难的事情。
1.3 选择哪种方式，取决于你的需求，如果你在Java平台下面并且输出文件页面格式不复杂，我推荐第一种，如果是.net平台又或者要处理复杂的页面样式，就选用第二种吧 （我前期使用第一种，后来因为效率问题和无法关闭Excel的问题，重写逻辑，选用第二种）。
关于Excel导出方案的选择，微软官方也是不建议使用第一种方案，甚至不提供技术支持。它推荐了一些方案，包括使用报表导出Excel或者ADO.net方式导出（ 即第二种），具体文章见如何使用 Visual C# 2005 或 Visual C# .NET 向 Excel 工作簿传输数据。
二、Office Excel文档模型 在写操作Excel代码之前，需要了解一下Excel的文档模型，才能想当然的把代码写出来。
简单说来，我们只要了解Application 、Workbook 、Worksheet 、Range这四种类型，如果需要操作图像的话，还需要多了解一种Chart。
Application就是Excel实例，不仅仅是一个Excel文件，而是整体的Excel程序（Office都是MDI文档体系）。
WorkBook就是实质意义上的某个Excel文件，你可以进行保存操作等等。
Worksheet是某个工作簿类型。
Range是我们打交道最多的，可以理解成一个区域快，也就是常见的&#34;A2:B5&#34;这种表示方式。
了解这几种之后，我们就可以下手操作了。更详细的微软官方文档，可以在Excel 对象模型概述找到。
三、使用C#操作Excel 我虽然不推荐第一种，但是毕竟是一种解决方案。
需要使用的命名空间为using Excel = Microsoft.Office.Interop.Excel;（使用别名简化一下）
另外需要项目引用Office的类库，如果不是项目形式而是网站形式，则需要手动编译对应Interop.Excel.dll到网站bin目录下面，我使用Excel 2007编译出这个链接库，版本为1.6.0.0，需要的可以点击Interop.Excel.dll下载。
3.1 编译Interop.Excel.dll 编译的方法出自于&#34;[使用Office组件读取Excel，引用Microsoft.Office.Interop.Excel出现的问题](http://www. cnblogs.com/Mainz/archive/2009/11/11/Microsoft_Office_Interop_Excel.html)&#34;&nbs p_place_holder;
进入你的visual studio的sdk下的bin目录，找到TlbImp."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.alswl.com/2010/12/csharp-vba-excel/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2010-12-14T00:00:00+08:00"><meta property="article:modified_time" content="2010-12-14T00:00:00+08:00"><meta property="og:site_name" content="Log4D"><meta name=twitter:card content="summary"><meta name=twitter:title content="C#+VBA操作Excel总结"><meta name=twitter:description content="Excel在日常办公中应用非常广泛，这次我接到一个案子，需要往Excel中写入数据并能够打印出固定格式，前前后后大概花了将近2星期才搞定，现在做一些分享。
一、关于操作Excel的几种方式 我们导出Excel，大抵是有两种方法，一种是在服务器端用一些类库或者COM组件直接生成Excel成品，其二是在后台只写入数据，而不写入具体格式，等用户下载完 Excel之后再在客户端上利用vba生成Excel成品。
1.1使用&#34;自动化&#34;功能-后台生成成品 微软把后台使用COM组件称之为&#34;自动化&#34;，其实它本身是不建议这种用法，在257757 号文章（服务器端 Office 自动化注意事项）也明文标出&#34;Microsoft 目前建议不要从任何无人参与的、非交互式客户端应用程序或组件（包括 ASP、DCOM 和 NT Service）中进行 Microsoft Office 应用程序的&#34;自动化&#34;，也不为此提供支持，因为 Office 在这种环境中运行时可能会出现不稳定的现象并且/或者会死锁。&#34;
这种方法的优点是给用户更简洁的展现，毕竟原生的Excel成品比半成品来更容易接受，而且可以避免宏安全问题，万一客户端禁止了宏，就只能看到丑陋的模板界面+一坨 数据。
缺点是需要服务端支持，编写成本也比较高（VBA有时候可以直接录制）。服务端支持体现在需要安装一些微软或者第三方的类库。我当时采用的是Office类库，也就是 在安装有Office的机器上面使用Interop.Excel.dll这个中间动态链接库进行操作，需要麻烦的安全设置，效率低不说还会扯出Excel无法关闭的B ug。
关于效率低我深有体会，我使用这种方法生成5页数据大约2m，客户等的急死，其根本原因是由于COM组件在调用时候，每一个Range这种对象都会产生一个借口请求。
1.2、使用ADO.net传输数据+VBA控制模板和数据 这方法的优缺点正好与上文相反，由于只是写入数据，即通过ADO.net的连接方式INSERT一堆数据到Excel文件的隐藏Sheet里面去（别跟我说你不知道E xcel可以隐藏某个Sheet），所以速度后台速度极快。前台Excel文件虽然需要VBA编程支持，但是在理解Excel模型之后也不是很难的事情。
1.3 选择哪种方式，取决于你的需求，如果你在Java平台下面并且输出文件页面格式不复杂，我推荐第一种，如果是.net平台又或者要处理复杂的页面样式，就选用第二种吧 （我前期使用第一种，后来因为效率问题和无法关闭Excel的问题，重写逻辑，选用第二种）。
关于Excel导出方案的选择，微软官方也是不建议使用第一种方案，甚至不提供技术支持。它推荐了一些方案，包括使用报表导出Excel或者ADO.net方式导出（ 即第二种），具体文章见如何使用 Visual C# 2005 或 Visual C# .NET 向 Excel 工作簿传输数据。
二、Office Excel文档模型 在写操作Excel代码之前，需要了解一下Excel的文档模型，才能想当然的把代码写出来。
简单说来，我们只要了解Application 、Workbook 、Worksheet 、Range这四种类型，如果需要操作图像的话，还需要多了解一种Chart。
Application就是Excel实例，不仅仅是一个Excel文件，而是整体的Excel程序（Office都是MDI文档体系）。
WorkBook就是实质意义上的某个Excel文件，你可以进行保存操作等等。
Worksheet是某个工作簿类型。
Range是我们打交道最多的，可以理解成一个区域快，也就是常见的&#34;A2:B5&#34;这种表示方式。
了解这几种之后，我们就可以下手操作了。更详细的微软官方文档，可以在Excel 对象模型概述找到。
三、使用C#操作Excel 我虽然不推荐第一种，但是毕竟是一种解决方案。
需要使用的命名空间为using Excel = Microsoft.Office.Interop.Excel;（使用别名简化一下）
另外需要项目引用Office的类库，如果不是项目形式而是网站形式，则需要手动编译对应Interop.Excel.dll到网站bin目录下面，我使用Excel 2007编译出这个链接库，版本为1.6.0.0，需要的可以点击Interop.Excel.dll下载。
3.1 编译Interop.Excel.dll 编译的方法出自于&#34;[使用Office组件读取Excel，引用Microsoft.Office.Interop.Excel出现的问题](http://www. cnblogs.com/Mainz/archive/2009/11/11/Microsoft_Office_Interop_Excel.html)&#34;&nbs p_place_holder;
进入你的visual studio的sdk下的bin目录，找到TlbImp."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.alswl.com/posts/"},{"@type":"ListItem","position":3,"name":"C#+VBA操作Excel总结","item":"https://blog.alswl.com/2010/12/csharp-vba-excel/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C#+VBA操作Excel总结","name":"C#\u002bVBA操作Excel总结","description":"Excel在日常办公中应用非常广泛，这次我接到一个案子，需要往Excel中写入数据并能够打印出固定格式，前前后后大概花了将近2星期才搞定，现在做一些分享。\n一、关于操作Excel的几种方式 我们导出Excel，大抵是有两种方法，一种是在服务器端用一些类库或者COM组件直接生成Excel成品，其二是在后台只写入数据，而不写入具体格式，等用户下载完 Excel之后再在客户端上利用vba生成Excel成品。\n1.1使用\u0026quot;自动化\u0026quot;功能-后台生成成品 微软把后台使用COM组件称之为\u0026quot;自动化\u0026quot;，其实它本身是不建议这种用法，在257757 号文章（服务器端 Office 自动化注意事项）也明文标出\u0026quot;Microsoft 目前建议不要从任何无人参与的、非交互式客户端应用程序或组件（包括 ASP、DCOM 和 NT Service）中进行 Microsoft Office 应用程序的\u0026quot;自动化\u0026quot;，也不为此提供支持，因为 Office 在这种环境中运行时可能会出现不稳定的现象并且/或者会死锁。\u0026quot;\n这种方法的优点是给用户更简洁的展现，毕竟原生的Excel成品比半成品来更容易接受，而且可以避免宏安全问题，万一客户端禁止了宏，就只能看到丑陋的模板界面+一坨 数据。\n缺点是需要服务端支持，编写成本也比较高（VBA有时候可以直接录制）。服务端支持体现在需要安装一些微软或者第三方的类库。我当时采用的是Office类库，也就是 在安装有Office的机器上面使用Interop.Excel.dll这个中间动态链接库进行操作，需要麻烦的安全设置，效率低不说还会扯出Excel无法关闭的B ug。\n关于效率低我深有体会，我使用这种方法生成5页数据大约2m，客户等的急死，其根本原因是由于COM组件在调用时候，每一个Range这种对象都会产生一个借口请求。\n1.2、使用ADO.net传输数据+VBA控制模板和数据 这方法的优缺点正好与上文相反，由于只是写入数据，即通过ADO.net的连接方式INSERT一堆数据到Excel文件的隐藏Sheet里面去（别跟我说你不知道E xcel可以隐藏某个Sheet），所以速度后台速度极快。前台Excel文件虽然需要VBA编程支持，但是在理解Excel模型之后也不是很难的事情。\n1.3 选择哪种方式，取决于你的需求，如果你在Java平台下面并且输出文件页面格式不复杂，我推荐第一种，如果是.net平台又或者要处理复杂的页面样式，就选用第二种吧 （我前期使用第一种，后来因为效率问题和无法关闭Excel的问题，重写逻辑，选用第二种）。\n关于Excel导出方案的选择，微软官方也是不建议使用第一种方案，甚至不提供技术支持。它推荐了一些方案，包括使用报表导出Excel或者ADO.net方式导出（ 即第二种），具体文章见如何使用 Visual C# 2005 或 Visual C# .NET 向 Excel 工作簿传输数据。\n二、Office Excel文档模型 在写操作Excel代码之前，需要了解一下Excel的文档模型，才能想当然的把代码写出来。\n简单说来，我们只要了解Application 、Workbook 、Worksheet 、Range这四种类型，如果需要操作图像的话，还需要多了解一种Chart。\nApplication就是Excel实例，不仅仅是一个Excel文件，而是整体的Excel程序（Office都是MDI文档体系）。\nWorkBook就是实质意义上的某个Excel文件，你可以进行保存操作等等。\nWorksheet是某个工作簿类型。\nRange是我们打交道最多的，可以理解成一个区域快，也就是常见的\u0026quot;A2:B5\u0026quot;这种表示方式。\n了解这几种之后，我们就可以下手操作了。更详细的微软官方文档，可以在Excel 对象模型概述找到。\n三、使用C#操作Excel 我虽然不推荐第一种，但是毕竟是一种解决方案。\n需要使用的命名空间为using Excel = Microsoft.Office.Interop.Excel;（使用别名简化一下）\n另外需要项目引用Office的类库，如果不是项目形式而是网站形式，则需要手动编译对应Interop.Excel.dll到网站bin目录下面，我使用Excel 2007编译出这个链接库，版本为1.6.0.0，需要的可以点击Interop.Excel.dll下载。\n3.1 编译Interop.Excel.dll 编译的方法出自于\u0026quot;[使用Office组件读取Excel，引用Microsoft.Office.Interop.Excel出现的问题](http://www. cnblogs.com/Mainz/archive/2009/11/11/Microsoft_Office_Interop_Excel.html)\u0026quot;\u0026amp;nbs p_place_holder;\n进入你的visual studio的sdk下的bin目录，找到TlbImp.","keywords":["dotnet","excel","office","vba"],"articleBody":"Excel在日常办公中应用非常广泛，这次我接到一个案子，需要往Excel中写入数据并能够打印出固定格式，前前后后大概花了将近2星期才搞定，现在做一些分享。\n一、关于操作Excel的几种方式 我们导出Excel，大抵是有两种方法，一种是在服务器端用一些类库或者COM组件直接生成Excel成品，其二是在后台只写入数据，而不写入具体格式，等用户下载完 Excel之后再在客户端上利用vba生成Excel成品。\n1.1使用\"自动化\"功能-后台生成成品 微软把后台使用COM组件称之为\"自动化\"，其实它本身是不建议这种用法，在257757 号文章（服务器端 Office 自动化注意事项）也明文标出\"Microsoft 目前建议不要从任何无人参与的、非交互式客户端应用程序或组件（包括 ASP、DCOM 和 NT Service）中进行 Microsoft Office 应用程序的\"自动化\"，也不为此提供支持，因为 Office 在这种环境中运行时可能会出现不稳定的现象并且/或者会死锁。\"\n这种方法的优点是给用户更简洁的展现，毕竟原生的Excel成品比半成品来更容易接受，而且可以避免宏安全问题，万一客户端禁止了宏，就只能看到丑陋的模板界面+一坨 数据。\n缺点是需要服务端支持，编写成本也比较高（VBA有时候可以直接录制）。服务端支持体现在需要安装一些微软或者第三方的类库。我当时采用的是Office类库，也就是 在安装有Office的机器上面使用Interop.Excel.dll这个中间动态链接库进行操作，需要麻烦的安全设置，效率低不说还会扯出Excel无法关闭的B ug。\n关于效率低我深有体会，我使用这种方法生成5页数据大约2m，客户等的急死，其根本原因是由于COM组件在调用时候，每一个Range这种对象都会产生一个借口请求。\n1.2、使用ADO.net传输数据+VBA控制模板和数据 这方法的优缺点正好与上文相反，由于只是写入数据，即通过ADO.net的连接方式INSERT一堆数据到Excel文件的隐藏Sheet里面去（别跟我说你不知道E xcel可以隐藏某个Sheet），所以速度后台速度极快。前台Excel文件虽然需要VBA编程支持，但是在理解Excel模型之后也不是很难的事情。\n1.3 选择哪种方式，取决于你的需求，如果你在Java平台下面并且输出文件页面格式不复杂，我推荐第一种，如果是.net平台又或者要处理复杂的页面样式，就选用第二种吧 （我前期使用第一种，后来因为效率问题和无法关闭Excel的问题，重写逻辑，选用第二种）。\n关于Excel导出方案的选择，微软官方也是不建议使用第一种方案，甚至不提供技术支持。它推荐了一些方案，包括使用报表导出Excel或者ADO.net方式导出（ 即第二种），具体文章见如何使用 Visual C# 2005 或 Visual C# .NET 向 Excel 工作簿传输数据。\n二、Office Excel文档模型 在写操作Excel代码之前，需要了解一下Excel的文档模型，才能想当然的把代码写出来。\n简单说来，我们只要了解Application 、Workbook 、Worksheet 、Range这四种类型，如果需要操作图像的话，还需要多了解一种Chart。\nApplication就是Excel实例，不仅仅是一个Excel文件，而是整体的Excel程序（Office都是MDI文档体系）。\nWorkBook就是实质意义上的某个Excel文件，你可以进行保存操作等等。\nWorksheet是某个工作簿类型。\nRange是我们打交道最多的，可以理解成一个区域快，也就是常见的\"A2:B5\"这种表示方式。\n了解这几种之后，我们就可以下手操作了。更详细的微软官方文档，可以在Excel 对象模型概述找到。\n三、使用C#操作Excel 我虽然不推荐第一种，但是毕竟是一种解决方案。\n需要使用的命名空间为using Excel = Microsoft.Office.Interop.Excel;（使用别名简化一下）\n另外需要项目引用Office的类库，如果不是项目形式而是网站形式，则需要手动编译对应Interop.Excel.dll到网站bin目录下面，我使用Excel 2007编译出这个链接库，版本为1.6.0.0，需要的可以点击Interop.Excel.dll下载。\n3.1 编译Interop.Excel.dll 编译的方法出自于\"[使用Office组件读取Excel，引用Microsoft.Office.Interop.Excel出现的问题](http://www. cnblogs.com/Mainz/archive/2009/11/11/Microsoft_Office_Interop_Excel.html)\"\u0026nbs p_place_holder;\n进入你的visual studio的sdk下的bin目录，找到TlbImp.exe文件，如果没有，请用光盘安装此文件，详细说明请参照MSDN。\u0026nbsp _place_holder;\n命令行(cmd)进入bin目录，运行TlbImp /out:Interop.Excel.dll Office安装目录+Excel.exe\n此时很可能会报错：TlbImp error: Unable to locate input type library: ‘c:program filesmcrosoft officeofficeEXCEL.EXE’\n此问题很有可能是TlbImp的bug，不支持空格式的路径；（具体原因不明）不要紧，将Excel.exe拷贝入bin目录，直接运行TlbImp /out:Interop.Excel.dll Excel.exe,提示\"Type library imported to Interop.Excel.dll路径\"\n在bin目录下找到Interop.Excel.dll文件。在你的visual studio里将其引用即可。\n3.2 封装的一个C#操作Excel类库 我把我之前封装的C#操作Excel类库分享一下\n注：这个类的Dispose仍然没有解决Excel文件生成之后Excel进程无法正常关闭的问题，目前看来只有杀死进程方法才能起实质性作用。\n其实我觉得这个类库除了让我熟悉一下Excel模型之外，并没派上实质的用场~\n/// /// Excel帮助类 /// Add by alswl 20101130 /// public class ExcelHelper : IDisposable { private Excel._Application excelApplication = null; public Excel._Workbook workbook = null; public Excel._Worksheet worksheet = null; private object missing = System.Reflection.Missing.Value; public ExcelHelper()\n{\nif (excelApplication == null)\n{\nexcelApplication = new Excel.ApplicationClass();\n}\n}\n/// /// ~\n/// ~ExcelHelper()\n{\nif (excelApplication != null)\nexcelApplication.Quit();\n}\n/// /// 释放非托管资源\n/// public void Dispose()\n{\ntry\n{\nif (excelApplication != null)\n{\nif (!workbook.Saved)\nthis.Close(false);\nexcelApplication.Quit();\nSystem.Runtime.InteropServices.Marshal.ReleaseComObject(worksheet);\nSystem.Runtime.InteropServices.Marshal.ReleaseComObject(workbook);\nSystem.Runtime.InteropServices.Marshal.ReleaseComObject(excelApplication);\nGC.Collect(System.GC.GetGeneration(worksheet));\nGC.Collect(System.GC.GetGeneration(workbook));\nGC.Collect(System.GC.GetGeneration(excelApplication));\nif (excelApplication != null)\n{\nexcelApplication = null;\n}\nGC.WaitForPendingFinalizers();\nGC.Collect();\nGC.WaitForPendingFinalizers();\nGC.Collect();\n}\n}\ncatch\n{\n}\nfinally\n{\nGC.Collect();\n}\n}\n/// /// 设置当前工作表\n/// public int CurrentWorksheetIndex\n{\nset\n{\nif (value \u003c= 0 || value \u003e workbook.Worksheets.Count)\nthrow new ArgumentException(“索引超出范围”);\nelse\n{\nobject index = value;\nworksheet = workbook.Worksheets[index] as Excel._Worksheet;\n}\n}\n}\n/// /// 打开一个Excel工作薄\n/// /// public void OpenWorkbook(string fileName)\n{\nworkbook = excelApplication.Workbooks.Open(fileName, missing, missing, missing, missing, missing,\nmissing, missing, missing, missing, missing, missing, missing, missing, missing);\nif (workbook.Worksheets.Count \u003e 0)\n{\nint index = 1;\nworksheet = workbook.Worksheets[index] as Excel._Worksheet;\n}\n}\n/// /// 添加一个工作表\n/// /// /// public Excel.Worksheet AddSheet(string sheetName)\n{\nExcel.Worksheet worksheet = (Excel.Worksheet)workbook.Worksheets.Add(Type.Missing, Type.Missing, Type.Missing, Type.Missing);\nworksheet.Name = sheetName;\nreturn worksheet;\n}\n/// /// 删除一个Sheet\n/// /// public void DeleteSheet(string sheetName)\n{\nExcel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;\nexcelApplication.DisplayAlerts = false;\nsheet.Delete();\nexcelApplication.DisplayAlerts = true;\n}\n/// /// 保存数据\n/// public void Save()\n{\nif (workbook != null)\n{\nworkbook.Save();\n}\n}\n/// /// 关闭文档\n/// /// public void Close(bool isSave)\n{\nobject obj_Save = isSave;\nworkbook.Close(obj_Save, missing, missing);\n}\n/// /// 设置当前工作表中某单元格的值\n/// /// /// public void SetRangeValue(string range, object value)\n{\nSetRangeValue(worksheet.Name, range, value);\n}\n/// /// 设置工作表中某单元格的值\n/// /// /// /// public void SetRangeValue(string sheetName, string range, object value)\n{\nExcel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;\nsheet.get_Range(range, missing).Value2 = value;\n}\n/// /// 删除某个Range，右侧左移\n/// /// /// public void DeleteRange(string sheetName, string rangeStr)\n{\nExcel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;\nsheet.get_Range(rangeStr, missing).Delete(Excel.XlDeleteShiftDirection.xlShiftToLeft);\n}\n/// /// 删除某个Range，右侧左移\n/// /// /// public void DeleteRange(string rangeStr)\n{\nDeleteRange(worksheet.Name, rangeStr);\n}\n/// /// 合并单元格\n/// /// /// /// public void Merge(string sheetName, string range1, string range2)\n{\nExcel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;\nExcel.Range range = worksheet.get_Range(range1, range2);\nrange.Merge(true);\n}\n/// /// 合并单元格\n/// /// /// public void Merge(string range1, string range2)\n{\nMerge(worksheet.Name, range1, range2);\n}\n/// /// 设置一个单元格的属性\n/// /// /// /// 大小\n/// 字体\n/// 颜色\n/// 对齐方式\npublic void SetCellProperty(string sheetName, string rangeStr, double fontSize, string fontName,\ndouble height, Excel.Constants horizontalStyle)\n{\nExcel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;\nExcel.Range range = sheet.get_Range(rangeStr, missing);\nrange.Font.Size = fontSize;\nrange.Font.Name = fontName;\n//range.Font.Color = fontColor;\nrange.RowHeight = height;\nrange.HorizontalAlignment = horizontalStyle;\n}\n/// /// 设置一个单元格的属性\n/// /// /// /// /// /// public void SetCellProperty(string range, double fontSize, string fontName,\ndouble height, Excel.Constants horizontalStyle)\n{\nSetCellProperty(worksheet.Name, range, fontSize, fontName,\nheight, horizontalStyle);\n}\n/// /// 设定Range的边框格式\n/// /// /// /// /// /// /// public void SetRangeBorderStyle(string sheetName, string rangeStr, Excel.XlLineStyle topStyle,\nExcel.XlLineStyle rightStyle, Excel.XlLineStyle bottomStyle, Excel.XlLineStyle leftStyle)\n{\nExcel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;\nExcel.Range range = sheet.get_Range(rangeStr, missing);\nrange.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeTop].LineSty le = topStyle;\nrange.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeRight].LineS tyle = rightStyle;\nrange.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeBottom].Line Style = bottomStyle;\nrange.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeLeft].LineSt yle = leftStyle;\n}\n/// /// 设定Range的边框格式\n/// /// /// /// /// /// public void SetRangeBorderStyle(string rangeStr, Excel.XlLineStyle topStyle,\nExcel.XlLineStyle rightStyle, Excel.XlLineStyle bottomStyle, Excel.XlLineStyle leftStyle)\n{\nSetRangeBorderStyle(worksheet.Name, rangeStr, topStyle,\nrightStyle, bottomStyle, leftStyle);\n}\n/// /// 设定Range数字格式\n/// /// /// /// public void SetRangeNumberFormat(string sheetName, string rangeStr, string format)\n{\nExcel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;\nExcel.Range range = sheet.get_Range(rangeStr, missing);\nrange.NumberFormat = format;//0%\n}\n/// /// 设定Range数字格式\n/// /// /// public void SetRangeNumberFormat(string rangeStr, string format)\n{\nSetRangeNumberFormat(worksheet.Name, rangeStr, format);\n}\n/// /// 将数据表格添加到Excel指定工作表的指定位置\n/// /// /// /// /// public void AddTable(System.Data.DataTable dt, int startX, int startY)\n{\nfor (int i = 0; i \u003c= dt.Rows.Count - 1; i++)\n{\nfor (int j = 0; j \u003c= dt.Columns.Count - 1; j++)\n{\nworksheet.Cells[i + startX, j + startY] = dt.Rows[i][j];\n}\n}\n}\n/// /// 加入分页符\n/// /// /// public void AddPageBreak(string rangeStr, int lineNumber)\n{\nExcel.Range range = worksheet.get_Range(“A” + lineNumber.ToString(), missing);\nworksheet.HPageBreaks.Add(range);\n}\n/// /// 加入分页符\n/// /// public void AddPageBreak(int lineNumber)\n{\nAddPageBreak(worksheet.Name, lineNumber);\n}\n/// /// 从当前工作表数据区域复制数据到另一个区域\n/// /// /// public void CopyRange2Range(string sheetFromRange, string sheetToRange)\n{\nCopyRange2Range(worksheet.Name, worksheet.Name, sheetFromRange, sheetToRange);\n}\n/// /// 从一个表的某个数据区域复制数据到另一个表的某个区域\n/// /// /// /// /// public void CopyRange2Range(string sheetFromName, string sheetToName, string sheetFromRange, string sheetToRange)\n{\nExcel.Worksheet sheetFrom = workbook.Worksheets[sheetFromName] as Excel.Worksheet;\nExcel.Worksheet sheetTo = workbook.Worksheets[sheetToName] as Excel.Worksheet;\nsheetFrom.get_Range(sheetFromRange, missing).Copy(sheetTo.get_Range(sheetToRange, missing));\n}\n/// /// 移动Range到另一个Range\n/// /// /// public void MoveRange2Range(string FromRange, string ToRange)\n{\nMoveRange2Range(worksheet.Name, FromRange, ToRange);\n}\n/// /// 移动Range到另一个Range\n/// /// /// /// public void MoveRange2Range(string sheetName, string FromRange, string ToRange)\n{\nExcel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;\nsheet.get_Range(FromRange, missing).Cut(sheet.get_Range(ToRange, missing));\n}\n/// /// 重设当前工作目录的打印区域\n/// public void ResetPrintArea()\n{\nSetPrintArea(worksheet.Name, “”);\n}\n/// /// 重设工作目录的打印区域\n/// public void ResetPrintArea(string sheetName)\n{\nSetPrintArea(sheetName, “”);\n}\n/// /// 设定工作目录的打印区域\n/// /// public void SetPrintArea(string area)\n{\nSetPrintArea(worksheet.Name, area);\n}\n/// /// 设定工作目录的打印区域\n/// /// /// public void SetPrintArea(string sheetName, string area)\n{\nExcel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;\nsheet.PageSetup.PrintArea = area;\n}\n/// /// 将当前工作表中的表格数据复制到剪切板\n/// public void Copy()\n{\nif (worksheet != null)\n{\ntry\n{\nworksheet.UsedRange.Select();\n}\ncatch { }\nworksheet.UsedRange.Copy(missing);\n}\n}\n}\n四、使用ADO.net+VBA操作Excel 我手头的这个案子在用第一种方法撰写一个星期之后遇到效率瓶颈，无奈改为第二种方法，由于对Excel的文档模型有了较全面的认识，几个主流函数也很清楚，所以写的速 度很快。\n这里我还是要佩服一下微软，曾经我对Office很不屑，后来看完《[Word排版艺术](http://book.douban.com/subject/1193 565/)》才开始认识Office，再之后深入PPT和Excel，更是感觉文档模型了不起。。。咳咳咳，扯远了~\n4.1 使用ADO.net写入数据到Excel文件 废话不说了，上核心代码\nSystem.Data.OleDb.OleDbConnection objConn = new System.Data.OleDb.OleDbConnection(\"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=\" + destFileName + \";Extended Properties=Excel 8.0;\"); objConn.Open(); System.Data.OleDb.OleDbCommand objCmd = new System.Data.OleDb.OleDbCommand();\nobjCmd.Connection = objConn;\nforeach (DataRow row in dt.Rows)\n{ StringBuilder stringBuilder = new StringBuilder();\nstringBuilder.AppendFormat(“INSERT INTO [{0}$] (”, sheetName);\nfor (int i = 0; i \u003c dt.Columns.Count; i++)\n{\nif (i \u003c dt.Columns.Count - 1)\nstringBuilder.Append(dt.Columns[i].ColumnName + “,”);\nelse\nstringBuilder.Append(dt.Columns[i].ColumnName + “) VALUES (”);\n}\nfor (int i = 0; i \u003c dt.Columns.Count; i++)\n{\nif (i \u003c dt.Columns.Count - 1)\nstringBuilder.Append(\"@\" + dt.Columns[i].ColumnName + “,”);\nelse\nstringBuilder.Append(\"@\" + dt.Columns[i].ColumnName + “);”);\n}\nobjCmd.Parameters.Clear();\nfor (int i = 0; i \u003c dt.Columns.Count; i++)\n{\nobjCmd.Parameters.Add(dt.Columns[i].ColumnName, row[i]);\n}\nobjCmd.CommandText = stringBuilder.ToString();\nobjCmd.ExecuteNonQuery();\n}\n注意点就是INSERT的表明就是Sheet的名字加上中括号和$符号。\n4.2 使用VBA操作模板和数据 使用VBA操作模板和数据的过程是一个assign的过程，就是把数据和模板杂糅起来，类似于MVC中C控制M输出到V中，我建议针对不同类型的页面制作多个模板，而 不要使用VBA进行各种样式修改操作，减少代码量。我这个案子中使用了8个不同类型模板，毕竟直接使用鼠标拖拽出一个模板比用VBA代码修改处一个模板简单的多。\nExcel2007的VBA界面在\"开发工具\"-“Visual Basic\"中打开，千万不要以为写VBA就是录制宏呀~另外附赠一个小技巧，在VBA编辑界面里面使用Ctrl+J可以自动补全，相当实用。\n我把项目分成5个模块：Golbal 、Init 、Insert 、Finalize 、Utils，看名字就知道意思了，其中Utils包含一个中文大写数字转换的函数，供前面使用。\n我们需要在Excel自动打开时候进行操作，需要使用函数Workbook_Open，另有Auto_Open，两个有不同之处，可以Google之。\n启用代码如下：\n'开启工作簿时候动作 Private Sub Workbook_Open() MAIN_SHEET = \"报价模板\" For Each Sheet In Sheets If Sheet.Name = MAIN_SHEET Then Exit Sub End If Next If Sheets(\"OPTION\").Range(\"B2\").Value = \"\" Then '如果不存在DH行数，则退出 Exit Sub End If MsgBox (\"初始化数据，请稍等片刻！\") Call Run Call DeleteSheets 'Call ActiveWorkbook.Save MsgBox (\"初始化数据完成，请保存Excel文件！\") End Sub\n核心代码的话。。。其实没什么核心代码，就是频繁的使用赋值和Copy函数。。。。\n五、相关资料链接 [C#操作Excel开发报表系列整理](http://www.cnblogs.com/dahuzizyd/archive/2007/04/11/CSharp _Excel_Report_Chart_All.html)\n检索 COM 类工厂中 CLSID 为 {00024500-0000-0000-C000-000000000046} 的组件时失败，原因是出现以下错误: 80070005\nPS:8000401a的错误会在服务器上出现，不会在xp上出现，原因是交互式用户也没有Excel操作权限，这时候要给Excel手动制动一个有Excel操作权 限用户，比如administrator。\nOffice编程在dot Net环境中总结(Excel篇)\n好了，这就是我这次Excel学习的分享，谢谢大家耐着性子看完~\n","wordCount":"1171","inLanguage":"en","datePublished":"2010-12-14T00:00:00+08:00","dateModified":"2010-12-14T00:00:00+08:00","author":{"@type":"Person","name":"alswl"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.alswl.com/2010/12/csharp-vba-excel/"},"publisher":{"@type":"Organization","name":"Log4D","logo":{"@type":"ImageObject","url":"https://blog.alswl.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.alswl.com accesskey=h title="Log4D (Alt + H)">Log4D</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.alswl.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.alswl.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://blog.alswl.com/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://blog.alswl.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.alswl.com>Home</a>&nbsp;»&nbsp;<a href=https://blog.alswl.com/posts/>Posts</a></div><h1 class=post-title>C#+VBA操作Excel总结</h1><div class=post-meta><span title='2010-12-14 00:00:00 +0800 +0800'>2010-12-14</span>&nbsp;·&nbsp;alswl</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#一关于操作excel的几种方式>一、关于操作Excel的几种方式</a><ul><li><a href=#11使用自动化功能-后台生成成品>1.1使用"自动化"功能-后台生成成品</a></li><li><a href=#12使用adonet传输数据vba控制模板和数据>1.2、使用ADO.net传输数据+VBA控制模板和数据</a></li><li><a href=#13>1.3</a></li></ul></li><li><a href=#二office-excel文档模型>二、Office Excel文档模型</a></li><li><a href=#三使用c操作excel>三、使用C#操作Excel</a><ul><li><a href=#31-编译interopexceldll>3.1 编译Interop.Excel.dll</a></li><li><a href=#32-封装的一个c操作excel类库>3.2 封装的一个C#操作Excel类库</a></li></ul></li><li><a href=#四使用adonetvba操作excel>四、使用ADO.net+VBA操作Excel</a><ul><li><a href=#41-使用adonet写入数据到excel文件>4.1 使用ADO.net写入数据到Excel文件</a></li><li><a href=#42-使用vba操作模板和数据>4.2 使用VBA操作模板和数据</a></li></ul></li><li><a href=#五相关资料链接>五、相关资料链接</a></li></ul></nav></div></details></div><div class=post-content><p>Excel在日常办公中应用非常广泛，这次我接到一个案子，需要往Excel中写入数据并能够打印出固定格式，前前后后大概花了将近2星期才搞定，现在做一些分享。</p><h2 id=一关于操作excel的几种方式>一、关于操作Excel的几种方式<a hidden class=anchor aria-hidden=true href=#一关于操作excel的几种方式>#</a></h2><p>我们导出Excel，大抵是有两种方法，一种是在服务器端用一些类库或者COM组件直接生成Excel成品，其二是在后台只写入数据，而不写入具体格式，等用户下载完
Excel之后再在客户端上利用vba生成Excel成品。</p><h3 id=11使用自动化功能-后台生成成品>1.1使用"自动化"功能-后台生成成品<a hidden class=anchor aria-hidden=true href=#11使用自动化功能-后台生成成品>#</a></h3><p>微软把后台使用COM组件称之为"自动化"，其实它本身是不建议这种用法，在<a href=http://support.microsoft.com/kb/257757>257757 号文章（服务器端 Office
自动化注意事项）</a>也明文标出"Microsoft
目前建议不要从任何无人参与的、非交互式客户端应用程序或组件（包括 ASP、DCOM 和 NT Service）中进行 Microsoft Office
应用程序的"自动化"，也不为此提供支持，因为 Office 在这种环境中运行时可能会出现不稳定的现象并且/或者会死锁。"</p><p>这种方法的优点是给用户更简洁的展现，毕竟原生的Excel成品比半成品来更容易接受，而且可以避免宏安全问题，万一客户端禁止了宏，就只能看到丑陋的模板界面+一坨
数据。</p><p>缺点是需要服务端支持，编写成本也比较高（VBA有时候可以直接录制）。服务端支持体现在需要安装一些微软或者第三方的类库。我当时采用的是Office类库，也就是
在安装有Office的机器上面使用Interop.Excel.dll这个中间动态链接库进行操作，需要麻烦的安全设置，效率低不说还会扯出Excel无法关闭的B
ug。</p><p>关于效率低我深有体会，我使用这种方法生成5页数据大约2m，客户等的急死，其根本原因是由于COM组件在调用时候，每一个Range这种对象都会产生一个借口请求。</p><h3 id=12使用adonet传输数据vba控制模板和数据>1.2、使用ADO.net传输数据+VBA控制模板和数据<a hidden class=anchor aria-hidden=true href=#12使用adonet传输数据vba控制模板和数据>#</a></h3><p>这方法的优缺点正好与上文相反，由于只是写入数据，即通过ADO.net的连接方式INSERT一堆数据到Excel文件的隐藏Sheet里面去（别跟我说你不知道E
xcel可以隐藏某个Sheet），所以速度后台速度极快。前台Excel文件虽然需要VBA编程支持，但是在理解Excel模型之后也不是很难的事情。</p><h3 id=13>1.3<a hidden class=anchor aria-hidden=true href=#13>#</a></h3><p>选择哪种方式，取决于你的需求，如果你在Java平台下面并且输出文件页面格式不复杂，我推荐第一种，如果是.net平台又或者要处理复杂的页面样式，就选用第二种吧
（我前期使用第一种，后来因为效率问题和无法关闭Excel的问题，重写逻辑，选用第二种）。</p><p>关于Excel导出方案的选择，微软官方也是不建议使用第一种方案，甚至不提供技术支持。它推荐了一些方案，包括使用报表导出Excel或者ADO.net方式导出（
即第二种），具体文章见<a href=http://support.microsoft.com/kb/306023/zh-cn>如何使用 Visual C# 2005 或 Visual C# .NET 向 Excel
工作簿传输数据</a>。</p><h2 id=二office-excel文档模型>二、Office Excel文档模型<a hidden class=anchor aria-hidden=true href=#二office-excel文档模型>#</a></h2><p>在写操作Excel代码之前，需要了解一下Excel的文档模型，才能想当然的把代码写出来。</p><p>简单说来，我们只要了解Application 、Workbook 、Worksheet
、Range这四种类型，如果需要操作图像的话，还需要多了解一种Chart。</p><p>Application就是Excel实例，不仅仅是一个Excel文件，而是整体的Excel程序（Office都是MDI文档体系）。</p><p>WorkBook就是实质意义上的某个Excel文件，你可以进行保存操作等等。</p><p>Worksheet是某个工作簿类型。</p><p>Range是我们打交道最多的，可以理解成一个区域快，也就是常见的"A2:B5"这种表示方式。</p><p>了解这几种之后，我们就可以下手操作了。更详细的微软官方文档，可以在<a href="http://msdn.microsoft.com/zh-cn/library/wss56bz7(v=vs.80).aspx">Excel 对象模型概述</a>找到。</p><h2 id=三使用c操作excel>三、使用C#操作Excel<a hidden class=anchor aria-hidden=true href=#三使用c操作excel>#</a></h2><p>我虽然不推荐第一种，但是毕竟是一种解决方案。</p><p>需要使用的命名空间为using Excel = Microsoft.Office.Interop.Excel;（使用别名简化一下）</p><p>另外需要项目引用Office的类库，如果不是项目形式而是网站形式，则需要手动编译对应Interop.Excel.dll到网站bin目录下面，我使用Excel
2007编译出这个链接库，版本为1.6.0.0，需要的可以点击<a href=https://4ocf5n.dijingchao.com/2010/12/Interop_Excel.zip>Interop.Excel.dll</a>下载。</p><h3 id=31-编译interopexceldll>3.1 编译Interop.Excel.dll<a hidden class=anchor aria-hidden=true href=#31-编译interopexceldll>#</a></h3><p>编译的方法出自于"[使用Office组件读取Excel，引用Microsoft.Office.Interop.Excel出现的问题](http://www.
cnblogs.com/Mainz/archive/2009/11/11/Microsoft_Office_Interop_Excel.html)"&nbs
p_place_holder;</p><blockquote><p>进入你的visual studio的sdk下的bin目录，找到TlbImp.exe文件，如果没有，请用光盘安装此文件，详细说明请参照MSDN。&nbsp
_place_holder;</p></blockquote><p>命令行(cmd)进入bin目录，运行TlbImp /out:Interop.Excel.dll
Office安装目录+Excel.exe</p><p>此时很可能会报错：TlbImp error: Unable
to locate input
type library:
&lsquo;c:program filesmcrosoft officeofficeEXCEL.EXE&rsquo;</p><blockquote></blockquote><blockquote><p>此问题很有可能是TlbImp的bug，不支持空格式的路径；（具体原因不明）不要紧，将Excel.exe拷贝入bin目录，直接运行TlbImp
/out:Interop.Excel.dll Excel.exe,提示"Type library imported to
Interop.Excel.dll路径"</p></blockquote><blockquote></blockquote><blockquote><p>在bin目录下找到Interop.Excel.dll文件。在你的visual studio里将其引用即可。</p></blockquote><h3 id=32-封装的一个c操作excel类库>3.2 封装的一个C#操作Excel类库<a hidden class=anchor aria-hidden=true href=#32-封装的一个c操作excel类库>#</a></h3><p>我把我之前封装的C#操作Excel类库分享一下</p><p>注：这个类的Dispose仍然没有解决Excel文件生成之后Excel进程无法正常关闭的问题，目前看来只有杀死进程方法才能起实质性作用。</p><p>其实我觉得这个类库除了让我熟悉一下Excel模型之外，并没派上实质的用场~</p><pre><code>/// &lt;summary&gt;
/// Excel帮助类
/// Add by alswl 20101130
/// &lt;/summary&gt;
public class ExcelHelper : IDisposable
{
    private Excel._Application excelApplication = null;
    public Excel._Workbook workbook = null;
    public Excel._Worksheet worksheet = null;
    private object missing = System.Reflection.Missing.Value;
</code></pre><p>public ExcelHelper()</p><p>{</p><p>if (excelApplication == null)</p><p>{</p><p>excelApplication = new Excel.ApplicationClass();</p><p>}</p><p>}</p><p>/// <summary></p><p>/// ~</p><p>///</summary></p><p>~ExcelHelper()</p><p>{</p><p>if (excelApplication != null)</p><p>excelApplication.Quit();</p><p>}</p><p>/// <summary></p><p>/// 释放非托管资源</p><p>///</summary></p><p>public void Dispose()</p><p>{</p><p>try</p><p>{</p><p>if (excelApplication != null)</p><p>{</p><p>if (!workbook.Saved)</p><p>this.Close(false);</p><p>excelApplication.Quit();</p><p>System.Runtime.InteropServices.Marshal.ReleaseComObject(worksheet);</p><p>System.Runtime.InteropServices.Marshal.ReleaseComObject(workbook);</p><p>System.Runtime.InteropServices.Marshal.ReleaseComObject(excelApplication);</p><p>GC.Collect(System.GC.GetGeneration(worksheet));</p><p>GC.Collect(System.GC.GetGeneration(workbook));</p><p>GC.Collect(System.GC.GetGeneration(excelApplication));</p><p>if (excelApplication != null)</p><p>{</p><p>excelApplication = null;</p><p>}</p><p>GC.WaitForPendingFinalizers();</p><p>GC.Collect();</p><p>GC.WaitForPendingFinalizers();</p><p>GC.Collect();</p><p>}</p><p>}</p><p>catch</p><p>{</p><p>}</p><p>finally</p><p>{</p><p>GC.Collect();</p><p>}</p><p>}</p><p>/// <summary></p><p>/// 设置当前工作表</p><p>///</summary></p><p>public int CurrentWorksheetIndex</p><p>{</p><p>set</p><p>{</p><p>if (value &lt;= 0 || value > workbook.Worksheets.Count)</p><p>throw new ArgumentException(&ldquo;索引超出范围&rdquo;);</p><p>else</p><p>{</p><p>object index = value;</p><p>worksheet = workbook.Worksheets[index] as Excel._Worksheet;</p><p>}</p><p>}</p><p>}</p><p>/// <summary></p><p>/// 打开一个Excel工作薄</p><p>///</summary></p><p>/// <param name=fileName></param></p><p>public void OpenWorkbook(string fileName)</p><p>{</p><p>workbook = excelApplication.Workbooks.Open(fileName, missing, missing,
missing, missing, missing,</p><p>missing, missing, missing, missing, missing, missing, missing, missing,
missing);</p><p>if (workbook.Worksheets.Count > 0)</p><p>{</p><p>int index = 1;</p><p>worksheet = workbook.Worksheets[index] as Excel._Worksheet;</p><p>}</p><p>}</p><p>/// <summary></p><p>/// 添加一个工作表</p><p>///</summary></p><p>/// <param name=SheetName></param></p><p>/// <returns></returns></p><p>public Excel.Worksheet AddSheet(string sheetName)</p><p>{</p><p>Excel.Worksheet worksheet =
(Excel.Worksheet)workbook.Worksheets.Add(Type.Missing, Type.Missing,
Type.Missing, Type.Missing);</p><p>worksheet.Name = sheetName;</p><p>return worksheet;</p><p>}</p><p>/// <summary></p><p>/// 删除一个Sheet</p><p>///</summary></p><p>/// <param name=sheetName></param></p><p>public void DeleteSheet(string sheetName)</p><p>{</p><p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p><p>excelApplication.DisplayAlerts = false;</p><p>sheet.Delete();</p><p>excelApplication.DisplayAlerts = true;</p><p>}</p><p>/// <summary></p><p>/// 保存数据</p><p>///</summary></p><p>public void Save()</p><p>{</p><p>if (workbook != null)</p><p>{</p><p>workbook.Save();</p><p>}</p><p>}</p><p>/// <summary></p><p>/// 关闭文档</p><p>///</summary></p><p>/// <param name=isSave></param></p><p>public void Close(bool isSave)</p><p>{</p><p>object obj_Save = isSave;</p><p>workbook.Close(obj_Save, missing, missing);</p><p>}</p><p>/// <summary></p><p>/// 设置当前工作表中某单元格的值</p><p>///</summary></p><p>/// <param name=range></param></p><p>/// <param name=value></param></p><p>public void SetRangeValue(string range, object value)</p><p>{</p><p>SetRangeValue(worksheet.Name, range, value);</p><p>}</p><p>/// <summary></p><p>/// 设置工作表中某单元格的值</p><p>///</summary></p><p>/// <param name=sheetName></param></p><p>/// <param name=range></param></p><p>/// <param name=value></param></p><p>public void SetRangeValue(string sheetName, string range, object value)</p><p>{</p><p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p><p>sheet.get_Range(range, missing).Value2 = value;</p><p>}</p><p>/// <summary></p><p>/// 删除某个Range，右侧左移</p><p>///</summary></p><p>/// <param name=sheetName></param></p><p>/// <param name=rangeStr></param></p><p>public void DeleteRange(string sheetName, string rangeStr)</p><p>{</p><p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p><p>sheet.get_Range(rangeStr,
missing).Delete(Excel.XlDeleteShiftDirection.xlShiftToLeft);</p><p>}</p><p>/// <summary></p><p>/// 删除某个Range，右侧左移</p><p>///</summary></p><p>/// <param name=sheetName></param></p><p>/// <param name=rangeStr></param></p><p>public void DeleteRange(string rangeStr)</p><p>{</p><p>DeleteRange(worksheet.Name, rangeStr);</p><p>}</p><p>/// <summary></p><p>/// 合并单元格</p><p>///</summary></p><p>/// <param name=sheetName></param></p><p>/// <param name=range1></param></p><p>/// <param name=range2></param></p><p>public void Merge(string sheetName, string range1, string range2)</p><p>{</p><p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p><p>Excel.Range range = worksheet.get_Range(range1, range2);</p><p>range.Merge(true);</p><p>}</p><p>/// <summary></p><p>/// 合并单元格</p><p>///</summary></p><p>/// <param name=range1></param></p><p>/// <param name=range2></param></p><p>public void Merge(string range1, string range2)</p><p>{</p><p>Merge(worksheet.Name, range1, range2);</p><p>}</p><p>/// <summary></p><p>/// 设置一个单元格的属性</p><p>///</summary></p><p>/// <param name=sheetName></param></p><p>/// <param name=range></param></p><p>/// <param name=size>大小</param></p><p>/// <param name=name>字体</param></p><p>/// <param name=color>颜色</param></p><p>/// <param name=HorizontalAlignment>对齐方式</param></p><p>public void SetCellProperty(string sheetName, string rangeStr, double
fontSize, string fontName,</p><p>double height, Excel.Constants horizontalStyle)</p><p>{</p><p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p><p>Excel.Range range = sheet.get_Range(rangeStr, missing);</p><p>range.Font.Size = fontSize;</p><p>range.Font.Name = fontName;</p><p>//range.Font.Color = fontColor;</p><p>range.RowHeight = height;</p><p>range.HorizontalAlignment = horizontalStyle;</p><p>}</p><p>/// <summary></p><p>/// 设置一个单元格的属性</p><p>///</summary></p><p>/// <param name=range></param></p><p>/// <param name=fontSize></param></p><p>/// <param name=fontName></param></p><p>/// <param name=fontColor></param></p><p>/// <param name=horizontalStyle></param></p><p>public void SetCellProperty(string range, double fontSize, string fontName,</p><p>double height, Excel.Constants horizontalStyle)</p><p>{</p><p>SetCellProperty(worksheet.Name, range, fontSize, fontName,</p><p>height, horizontalStyle);</p><p>}</p><p>/// <summary></p><p>/// 设定Range的边框格式</p><p>///</summary></p><p>/// <param name=rangeStart></param></p><p>/// <param name=rangeEnd></param></p><p>/// <param name=topStyle></param></p><p>/// <param name=rightStyle></param></p><p>/// <param name=bottomStyle></param></p><p>/// <param name=leftStyle></param></p><p>public void SetRangeBorderStyle(string sheetName, string rangeStr,
Excel.XlLineStyle topStyle,</p><p>Excel.XlLineStyle rightStyle, Excel.XlLineStyle bottomStyle, Excel.XlLineStyle
leftStyle)</p><p>{</p><p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p><p>Excel.Range range = sheet.get_Range(rangeStr, missing);</p><p>range.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeTop].LineSty
le = topStyle;</p><p>range.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeRight].LineS
tyle = rightStyle;</p><p>range.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeBottom].Line
Style = bottomStyle;</p><p>range.Borders[Microsoft.Office.Interop.Excel.XlBordersIndex.xlEdgeLeft].LineSt
yle = leftStyle;</p><p>}</p><p>/// <summary></p><p>/// 设定Range的边框格式</p><p>///</summary></p><p>/// <param name=rangeStr></param></p><p>/// <param name=topStyle></param></p><p>/// <param name=rightStyle></param></p><p>/// <param name=bottomStyle></param></p><p>/// <param name=leftStyle></param></p><p>public void SetRangeBorderStyle(string rangeStr, Excel.XlLineStyle topStyle,</p><p>Excel.XlLineStyle rightStyle, Excel.XlLineStyle bottomStyle, Excel.XlLineStyle
leftStyle)</p><p>{</p><p>SetRangeBorderStyle(worksheet.Name, rangeStr, topStyle,</p><p>rightStyle, bottomStyle, leftStyle);</p><p>}</p><p>/// <summary></p><p>/// 设定Range数字格式</p><p>///</summary></p><p>/// <param name=sheetName></param></p><p>/// <param name=rangeStr></param></p><p>/// <param name=format></param></p><p>public void SetRangeNumberFormat(string sheetName, string rangeStr, string
format)</p><p>{</p><p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p><p>Excel.Range range = sheet.get_Range(rangeStr, missing);</p><p>range.NumberFormat = format;//0%</p><p>}</p><p>/// <summary></p><p>/// 设定Range数字格式</p><p>///</summary></p><p>/// <param name=rangeStr></param></p><p>/// <param name=format></param></p><p>public void SetRangeNumberFormat(string rangeStr, string format)</p><p>{</p><p>SetRangeNumberFormat(worksheet.Name, rangeStr, format);</p><p>}</p><p>/// <summary></p><p>/// 将数据表格添加到Excel指定工作表的指定位置</p><p>///</summary></p><p>/// <param name=dt></param></p><p>/// <param name=ws></param></p><p>/// <param name=startX></param></p><p>/// <param name=startY></param></p><p>public void AddTable(System.Data.DataTable dt, int startX, int startY)</p><p>{</p><p>for (int i = 0; i &lt;= dt.Rows.Count - 1; i++)</p><p>{</p><p>for (int j = 0; j &lt;= dt.Columns.Count - 1; j++)</p><p>{</p><p>worksheet.Cells[i + startX, j + startY] = dt.Rows[i][j];</p><p>}</p><p>}</p><p>}</p><p>/// <summary></p><p>/// 加入分页符</p><p>///</summary></p><p>/// <param name=rangeStr></param></p><p>/// <param name=lineNumber></param></p><p>public void AddPageBreak(string rangeStr, int lineNumber)</p><p>{</p><p>Excel.Range range = worksheet.get_Range(&ldquo;A&rdquo; + lineNumber.ToString(), missing);</p><p>worksheet.HPageBreaks.Add(range);</p><p>}</p><p>/// <summary></p><p>/// 加入分页符</p><p>///</summary></p><p>/// <param name=lineNumber></param></p><p>public void AddPageBreak(int lineNumber)</p><p>{</p><p>AddPageBreak(worksheet.Name, lineNumber);</p><p>}</p><p>/// <summary></p><p>/// 从当前工作表数据区域复制数据到另一个区域</p><p>///</summary></p><p>/// <param name=sheetFromRange></param></p><p>/// <param name=sheetToRange></param></p><p>public void CopyRange2Range(string sheetFromRange, string sheetToRange)</p><p>{</p><p>CopyRange2Range(worksheet.Name, worksheet.Name, sheetFromRange, sheetToRange);</p><p>}</p><p>/// <summary></p><p>/// 从一个表的某个数据区域复制数据到另一个表的某个区域</p><p>///</summary></p><p>/// <param name=sheetFromName></param></p><p>/// <param name=sheetToName></param></p><p>/// <param name=sheetFromRange></param></p><p>/// <param name=sheetToRange></param></p><p>public void CopyRange2Range(string sheetFromName, string sheetToName, string
sheetFromRange, string sheetToRange)</p><p>{</p><p>Excel.Worksheet sheetFrom = workbook.Worksheets[sheetFromName] as
Excel.Worksheet;</p><p>Excel.Worksheet sheetTo = workbook.Worksheets[sheetToName] as Excel.Worksheet;</p><p>sheetFrom.get_Range(sheetFromRange,
missing).Copy(sheetTo.get_Range(sheetToRange, missing));</p><p>}</p><p>/// <summary></p><p>/// 移动Range到另一个Range</p><p>///</summary></p><p>/// <param name=FromRange></param></p><p>/// <param name=ToRange></param></p><p>public void MoveRange2Range(string FromRange, string ToRange)</p><p>{</p><p>MoveRange2Range(worksheet.Name, FromRange, ToRange);</p><p>}</p><p>/// <summary></p><p>/// 移动Range到另一个Range</p><p>///</summary></p><p>/// <param name=sheetName></param></p><p>/// <param name=FromRange></param></p><p>/// <param name=ToRange></param></p><p>public void MoveRange2Range(string sheetName, string FromRange, string
ToRange)</p><p>{</p><p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p><p>sheet.get_Range(FromRange, missing).Cut(sheet.get_Range(ToRange, missing));</p><p>}</p><p>/// <summary></p><p>/// 重设当前工作目录的打印区域</p><p>///</summary></p><p>public void ResetPrintArea()</p><p>{</p><p>SetPrintArea(worksheet.Name, &ldquo;&rdquo;);</p><p>}</p><p>/// <summary></p><p>/// 重设工作目录的打印区域</p><p>///</summary></p><p>public void ResetPrintArea(string sheetName)</p><p>{</p><p>SetPrintArea(sheetName, &ldquo;&rdquo;);</p><p>}</p><p>/// <summary></p><p>/// 设定工作目录的打印区域</p><p>///</summary></p><p>/// <param name=area></param></p><p>public void SetPrintArea(string area)</p><p>{</p><p>SetPrintArea(worksheet.Name, area);</p><p>}</p><p>/// <summary></p><p>/// 设定工作目录的打印区域</p><p>///</summary></p><p>/// <param name=sheetName></param></p><p>/// <param name=area></param></p><p>public void SetPrintArea(string sheetName, string area)</p><p>{</p><p>Excel.Worksheet sheet = workbook.Worksheets[sheetName] as Excel.Worksheet;</p><p>sheet.PageSetup.PrintArea = area;</p><p>}</p><p>/// <summary></p><p>/// 将当前工作表中的表格数据复制到剪切板</p><p>///</summary></p><p>public void Copy()</p><p>{</p><p>if (worksheet != null)</p><p>{</p><p>try</p><p>{</p><p>worksheet.UsedRange.Select();</p><p>}</p><p>catch { }</p><p>worksheet.UsedRange.Copy(missing);</p><p>}</p><p>}</p><p>}</p><h2 id=四使用adonetvba操作excel>四、使用ADO.net+VBA操作Excel<a hidden class=anchor aria-hidden=true href=#四使用adonetvba操作excel>#</a></h2><p>我手头的这个案子在用第一种方法撰写一个星期之后遇到效率瓶颈，无奈改为第二种方法，由于对Excel的文档模型有了较全面的认识，几个主流函数也很清楚，所以写的速
度很快。</p><p>这里我还是要佩服一下微软，曾经我对Office很不屑，后来看完《[Word排版艺术](<a href=http://book.douban.com/subject/1193>http://book.douban.com/subject/1193</a>
565/)》才开始认识Office，再之后深入PPT和Excel，更是感觉文档模型了不起。。。咳咳咳，扯远了~</p><h3 id=41-使用adonet写入数据到excel文件>4.1 使用ADO.net写入数据到Excel文件<a hidden class=anchor aria-hidden=true href=#41-使用adonet写入数据到excel文件>#</a></h3><p>废话不说了，上核心代码</p><pre><code>System.Data.OleDb.OleDbConnection objConn = new System.Data.OleDb.OleDbConnection(&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=&quot; +
                    destFileName + &quot;;Extended Properties=Excel 8.0;&quot;);
objConn.Open();
</code></pre><p>System.Data.OleDb.OleDbCommand objCmd = new System.Data.OleDb.OleDbCommand();</p><p>objCmd.Connection = objConn;</p><p>foreach (DataRow row in dt.Rows)</p><p>{ StringBuilder stringBuilder = new StringBuilder();</p><p>stringBuilder.AppendFormat(&ldquo;INSERT INTO [{0}$] (&rdquo;, sheetName);</p><p>for (int i = 0; i &lt; dt.Columns.Count; i++)</p><p>{</p><p>if (i &lt; dt.Columns.Count - 1)</p><p>stringBuilder.Append(dt.Columns[i].ColumnName + &ldquo;,&rdquo;);</p><p>else</p><p>stringBuilder.Append(dt.Columns[i].ColumnName + &ldquo;) VALUES (&rdquo;);</p><p>}</p><p>for (int i = 0; i &lt; dt.Columns.Count; i++)</p><p>{</p><p>if (i &lt; dt.Columns.Count - 1)</p><p>stringBuilder.Append("@" + dt.Columns[i].ColumnName + &ldquo;,&rdquo;);</p><p>else</p><p>stringBuilder.Append("@" + dt.Columns[i].ColumnName + &ldquo;);&rdquo;);</p><p>}</p><p>objCmd.Parameters.Clear();</p><p>for (int i = 0; i &lt; dt.Columns.Count; i++)</p><p>{</p><p>objCmd.Parameters.Add(dt.Columns[i].ColumnName, row[i]);</p><p>}</p><p>objCmd.CommandText = stringBuilder.ToString();</p><p>objCmd.ExecuteNonQuery();</p><p>}</p><p>注意点就是INSERT的表明就是Sheet的名字加上中括号和$符号。</p><h3 id=42-使用vba操作模板和数据>4.2 使用VBA操作模板和数据<a hidden class=anchor aria-hidden=true href=#42-使用vba操作模板和数据>#</a></h3><p>使用VBA操作模板和数据的过程是一个assign的过程，就是把数据和模板杂糅起来，类似于MVC中C控制M输出到V中，我建议针对不同类型的页面制作多个模板，而
不要使用VBA进行各种样式修改操作，减少代码量。我这个案子中使用了8个不同类型模板，毕竟直接使用鼠标拖拽出一个模板比用VBA代码修改处一个模板简单的多。</p><p>Excel2007的VBA界面在"开发工具"-&ldquo;Visual
Basic"中打开，千万不要以为写VBA就是录制宏呀~另外附赠一个小技巧，在VBA编辑界面里面使用Ctrl+J可以自动补全，相当实用。</p><p>我把项目分成5个模块：Golbal 、Init 、Insert 、Finalize
、Utils，看名字就知道意思了，其中Utils包含一个中文大写数字转换的函数，供前面使用。</p><p>我们需要在Excel自动打开时候进行操作，需要使用函数Workbook_Open，另有Auto_Open，两个有不同之处，可以Google之。</p><p>启用代码如下：</p><pre><code>'开启工作簿时候动作
Private Sub Workbook_Open()
    
    MAIN_SHEET = &quot;报价模板&quot;
    For Each Sheet In Sheets
        If Sheet.Name = MAIN_SHEET Then
            Exit Sub
        End If
    Next
    If Sheets(&quot;OPTION&quot;).Range(&quot;B2&quot;).Value = &quot;&quot; Then '如果不存在DH行数，则退出
        Exit Sub
    End If
    
    MsgBox (&quot;初始化数据，请稍等片刻！&quot;)
    Call Run
    Call DeleteSheets
    'Call ActiveWorkbook.Save
    MsgBox (&quot;初始化数据完成，请保存Excel文件！&quot;)
</code></pre><p>End Sub</p><p>核心代码的话。。。其实没什么核心代码，就是频繁的使用赋值和Copy函数。。。。</p><h2 id=五相关资料链接>五、相关资料链接<a hidden class=anchor aria-hidden=true href=#五相关资料链接>#</a></h2><p>[C#操作Excel开发报表系列整理](<a href=http://www.cnblogs.com/dahuzizyd/archive/2007/04/11/CSharp>http://www.cnblogs.com/dahuzizyd/archive/2007/04/11/CSharp</a>
_Excel_Report_Chart_All.html)</p><p><a href=http://www.cnblogs.com/HQT/archive/2006/05/22/406345.html>检索 COM 类工厂中 CLSID 为 {00024500-0000-0000-C000-000000000046} 的组件时失败，原因是出现以下错误:
80070005</a></p><p>PS:8000401a的错误会在服务器上出现，不会在xp上出现，原因是交互式用户也没有Excel操作权限，这时候要给Excel手动制动一个有Excel操作权
限用户，比如administrator。</p><p><a href=http://archive.cnblogs.com/a/567305/>Office编程在dot Net环境中总结(Excel篇)</a></p><p>好了，这就是我这次Excel学习的分享，谢谢大家耐着性子看完~</p><hr><p>原文链接: <a href=https://blog.alswl.com/2010/12/csharp-vba-excel/>C#+VBA操作Excel总结 | Log4D</a></p><p>3a1ff193cee606bd1e2ea554a16353ee</p><p>欢迎关注我的微信公众号：<a href="http://mp.weixin.qq.com/mp/getmasssendmsg?__biz=MzIyNTIwMTU3MQ==#wechat_webview_type=1&wechat_redirect">窥豹</a></p><figure><img src=https://4ocf5n.dijingchao.com/upload_dropbox/201605/qrcode_for_gh_17e2f9c2caa4_258.jpg alt=窥豹><figcaption aria-hidden=true>窥豹</figcaption></figure><figure><img src=https://4ocf5n.dijingchao.com/upload_dropbox/meta/wechat-pay-s-crop.png alt="如果对你有帮助，给作者 ￥2 买张彩票吧。"><figcaption aria-hidden=true>如果对你有帮助，给作者 ￥2
买张彩票吧。</figcaption></figure></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.alswl.com/tags/dotnet/>dotnet</a></li><li><a href=https://blog.alswl.com/tags/excel/>excel</a></li><li><a href=https://blog.alswl.com/tags/office/>office</a></li><li><a href=https://blog.alswl.com/tags/vba/>vba</a></li></ul><nav class=paginav><a class=prev href=https://blog.alswl.com/2010/12/half-year/><span class=title>« Prev</span><br><span>半年</span></a>
<a class=next href=https://blog.alswl.com/2010/12/cook/><span class=title>Next »</span><br><span>脑袋大，脖子粗~</span></a></nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//log4d.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.alswl.com>Log4D</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>