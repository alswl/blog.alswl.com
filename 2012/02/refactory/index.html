<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>再读《重构》 | Log4D</title>
<meta name="keywords" content="综合技术, 读书笔记">
<meta name="description" content="Martin Fowler 的「重构-改善既有代码的设计」这本书，是我大学老师推荐给我的。
当时我在撰写代码过程中，发现当代码量到某个数量级时候（1000&#43;行），
就会逐渐失去对代码的控制能力。
昆哥推荐了两本书「UML 和模式应用」和「重构」这本书。









这本书是2年前购买的，可惜以我当时的代码感知和撰写能力，看起来颇为吃力。 半途就看得云里雾里而中断了。最近我又重新拾起这本书，
将书中所写的境况与我这两年多来遇到的问题相互印证，才感受到这本经典的力量。
Martin 其人：

ThoughtWorks 的首席科学家，当今世界软件开发领域最具影响力的五位大师之一。
他在 UML 推广普及、领域建模、企业应用开发和敏捷方法等方面建树卓著，被称为软件开发的教父。">
<meta name="author" content="alswl">
<link rel="canonical" href="https://blog.alswl.com/2012/02/refactory/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fd393d9f5641ed4046d063ea612203db6fe6a48fb1ef59a1359076d0c2ed9022.css" integrity="sha256-/Tk9n1ZB7UBG0GPqYSID22/mpI&#43;x71mhNZB20MLtkCI=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.alswl.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.alswl.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.alswl.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.alswl.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.alswl.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="text/markdown" href="https://blog.alswl.com/2012/02/refactory/index.md">
<link rel="alternate" hreflang="en" href="https://blog.alswl.com/2012/02/refactory/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-7S40P40QGJ"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-7S40P40QGJ');
        }
      </script><meta property="og:title" content="再读《重构》" />
<meta property="og:description" content="Martin Fowler 的「重构-改善既有代码的设计」这本书，是我大学老师推荐给我的。
当时我在撰写代码过程中，发现当代码量到某个数量级时候（1000&#43;行），
就会逐渐失去对代码的控制能力。
昆哥推荐了两本书「UML 和模式应用」和「重构」这本书。









这本书是2年前购买的，可惜以我当时的代码感知和撰写能力，看起来颇为吃力。 半途就看得云里雾里而中断了。最近我又重新拾起这本书，
将书中所写的境况与我这两年多来遇到的问题相互印证，才感受到这本经典的力量。
Martin 其人：

ThoughtWorks 的首席科学家，当今世界软件开发领域最具影响力的五位大师之一。
他在 UML 推广普及、领域建模、企业应用开发和敏捷方法等方面建树卓著，被称为软件开发的教父。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.alswl.com/2012/02/refactory/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-02-05T00:00:00+08:00" />
<meta property="article:modified_time" content="2012-02-05T00:00:00+08:00" /><meta property="og:site_name" content="Log4D" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="再读《重构》"/>
<meta name="twitter:description" content="Martin Fowler 的「重构-改善既有代码的设计」这本书，是我大学老师推荐给我的。
当时我在撰写代码过程中，发现当代码量到某个数量级时候（1000&#43;行），
就会逐渐失去对代码的控制能力。
昆哥推荐了两本书「UML 和模式应用」和「重构」这本书。









这本书是2年前购买的，可惜以我当时的代码感知和撰写能力，看起来颇为吃力。 半途就看得云里雾里而中断了。最近我又重新拾起这本书，
将书中所写的境况与我这两年多来遇到的问题相互印证，才感受到这本经典的力量。
Martin 其人：

ThoughtWorks 的首席科学家，当今世界软件开发领域最具影响力的五位大师之一。
他在 UML 推广普及、领域建模、企业应用开发和敏捷方法等方面建树卓著，被称为软件开发的教父。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.alswl.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "再读《重构》",
      "item": "https://blog.alswl.com/2012/02/refactory/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "再读《重构》",
  "name": "再读《重构》",
  "description": "Martin Fowler 的「重构-改善既有代码的设计」这本书，是我大学老师推荐给我的。 当时我在撰写代码过程中，发现当代码量到某个数量级时候（1000+行）， 就会逐渐失去对代码的控制能力。 昆哥推荐了两本书「UML 和模式应用」和「重构」这本书。\n这本书是2年前购买的，可惜以我当时的代码感知和撰写能力，看起来颇为吃力。 半途就看得云里雾里而中断了。最近我又重新拾起这本书， 将书中所写的境况与我这两年多来遇到的问题相互印证，才感受到这本经典的力量。\nMartin 其人：\nThoughtWorks 的首席科学家，当今世界软件开发领域最具影响力的五位大师之一。 他在 UML 推广普及、领域建模、企业应用开发和敏捷方法等方面建树卓著，被称为软件开发的教父。\n",
  "keywords": [
    "综合技术", "读书笔记"
  ],
  "articleBody": "Martin Fowler 的「重构-改善既有代码的设计」这本书，是我大学老师推荐给我的。 当时我在撰写代码过程中，发现当代码量到某个数量级时候（1000+行）， 就会逐渐失去对代码的控制能力。 昆哥推荐了两本书「UML 和模式应用」和「重构」这本书。\n这本书是2年前购买的，可惜以我当时的代码感知和撰写能力，看起来颇为吃力。 半途就看得云里雾里而中断了。最近我又重新拾起这本书， 将书中所写的境况与我这两年多来遇到的问题相互印证，才感受到这本经典的力量。\nMartin 其人：\nThoughtWorks 的首席科学家，当今世界软件开发领域最具影响力的五位大师之一。 他在 UML 推广普及、领域建模、企业应用开发和敏捷方法等方面建树卓著，被称为软件开发的教父。\n大学时候有段时间我对 Martin 的敏捷非常痴迷。现在对技术的选择没以前那么冲动了， 但是毫不妨碍我对 Martin 的敬仰之情。\n1. 重构原则 1.1. 重构的定义 对软件内部结构的一种调整，目的是在不改变\"软件之可察行为\"前提下，提高其可理解性，降低其修改成本。\n重构就是在代码写好之后改进它的设计。\n重构和添加新功能并不冲突，但是当开发者身份在两者之间切换时候，不能混淆在一起。 1.2. 重构的意义 优秀设计的根本是：消除重复部分！（DRY = Don’t repeat yourself） 重构让代码更清晰，更容易理解 清晰的代码可以更方便的找到 bug ，重构可以写出更强健的代码 良好的设计可以在长远时间上提高开发速度 1.3. 重构的时间 随时进行重构（在我看来，重构更是一种开发的习惯） 事不过三，代码重复不要超过三次（否则就要\"抽\"出来） 添加功能时候并一一重构（个人理解是，添加新功能之前，分析并重构，从而更方便添加新功能） 修补错误时 Code Review 时 1.4. 重构和开发进度 重构的意义之一也是提高开发进度。杀手锏是\"不要告诉经理\"。\n1.5. 重构的难题 数据层（数据模型）的变更压力 修改接口 那些难以通过重构改变的设计改动 代码不能运行 项目期限压力 Deadline 1.6. 重构与设计 编程不是机械的开发，（软件开发是艺术行为！） 设计和重构的平衡（预先设计的难度和重构灵活性的平衡） 1.7. 重构与性能 重构确实会在短期内降低代码执行效率，但优化阶段是可以调整的，而且调整会更容易。 提前优化是万恶之源 1.8. 那些Bad Smell 重复的代码（这才是真正万恶之源，鄙视一切Ctrl+C/P） 过长函数，会导致责任不明确/难以切割/难以理解等一系列问题 过大类，职责不明确，垃圾滋生地 过长参数列（面向对象不是说说而已） 发散式变化，一个类会响应多种需求而被修改 散弹式修改（其实就是没有封装变化处，由于一个需求，多处需要被修改） 依赖情节（一个类对其他类过多的依赖） 数据泥团（如果数据有意义，就将结构数据变成对象） Type code，使用 Class 替代 switch，少用，考虑多态 过多平行的类，使用类继承并联起来 冗余类，去除它 夸夸其谈的未来性（Matin 的文字，侯俊杰的翻译真是…出彩…） 临时值域，封装它 过度耦合的消息链，使用真正需要的函数和对象，而不要依赖于消息链 过度的 Deleate 过度使用其他类 private 值域 重复作用的类 不完美的类库，（类库老了，使用者也没办法阿） 纯数据类（类需要行为） 不纯粹的继承（拒绝父类的接口的类） 过多注释，注释多了，就说明代码不清楚了 1.9. 从测试开始 无测试，无重构，只依赖手工测试，重构时候人会崩溃的。\n重构的保真就是自动化测试（如果真的要无聊的手工测试，我也不反对） 单元测试 功能测试 1.10. Kent Back说 如果我纯粹为今天工作，明天我将完全无法工作。\n间接层的价值：\n允许逻辑共享 分开解释\"意图\"和\"实现\" 将变化加以隔离 将条件逻辑加以编码 计算机科学是这样一门学科：它相信所有问题都可以通过一个间接层来解决。\n–Dennis DeBruler\n我相信，撰写代码时候不仅仅考虑当下功能，要考虑到有可能出现的情况， 在可能的平衡下面，为将来的扩展做好准备。（也许不仅仅是自己的明天， 还要考虑团队成员的今天工作内容）\n2. 重构名录 2.1. 重新组织函数 Extract Method（提炼函数）\n将一段独立的，不依赖上下文的代码组织并独立出来。\nInline Method（将函数内联化）\n当函数内部代码简短而容易理解时候，去除这个非必要的间接层。\nInline Temp（将临时变量内联化）\n去除只被赋值一次的临时变量。（当有意义时候，应该保留）\nReplace Temp with Query（以查询取代临时变量）\n将临时变量提取到一个独立函数，并将原来变量引用替换为函数调用。 （我还是担心性能的问题，另外将临时变量限定在一个段落中，可以避免额外的引用）\nIntroduce Explainning Variable（引入解释性变量）\n将复杂表达式的结果放入临时变量，并用变量名来解释表达式用途。 （自注释代码的表现）\nSplit Temporary Variable（剖析临时变量）\n除了循环变量和临时集合变量，临时变量赋值不能超过一次。\nRemove Assignments to Parameters（移除对参数的赋值动作）\n不对函数参数进行赋值动作，如果要赋值，创建一个新的临时变量。\nReplace Method with Method Object（以函数对象取代函数）\n把函数变成对象，再把临时变量变成对象值域。该方法在分解函数时候常用。 （Martin 对小型函数特别迷恋，我认为这个方法更应该用在有逻辑意义的方法上面）\nSubstitute Algorithm（替换算法）\n用更清晰的算法。 （码农都知道）\n2.2. 在对象之间搬移特性 （面向对象编程原则之一就是职责归属，搬移其实也就意味着职责重新规划）\nMove Method（搬移函数）\n将函数移动到被最多次调用的类里面去。 （往往在逻辑意义上，这个函数就应该归属于这个类）\nMove Field（搬移值域）\n将值域移动到被最多次调用的类里面去。\nExtract Class（提炼类）\n将开发过程中逐渐变得臃肿的类拆分成数个类，形成清楚的抽象，明确的职责。\nInline Class（将类内联化）\n将不再担任足够职责的类搬到另外一个类中，并移除这个原始类。\nHide Delegate（隐藏委托关系）\n将直接调用变成间接，在中间添加一层，从而从容面对变更，隔离变化。 （“哪里变化，封装哪里\"这是设计模式的一个经典原则）\nRemove Middle Man（移除中间人）\n和Hide Delegate相反，移除做了过多简单委托的类。 （应该Hide Delegate需要加入成本，多维护一层，这需要控制一种平衡）\nIntroduce Foreign Method（引入外加函数）\n当类无法进行修改时候，使用静态函数接受这种类型的类实例，\nIntroduce Local Extenstion（引入本地扩展）\n使用子类继承/Wrapper 类来实现额外的函数。\n2.3. 重新组织数据 Self Encapsulate Field（自封装值域）\n使用getter/setter。 （个人觉得这样很繁琐，.net 中的属性方式处理的不错）\nReplace Date Value with Object （以对象取代数据值）\n当数据项有额外的数据和行为时候，将它变成一个类\nChange Value to Reference（将实值对象改为引用对象）\n有一些类型，比如日期、星期，不需要保存太多副本。\nChange Reference to Value（将引用对象改为实值对象）\n和楼上相反的情况，引用会带来复杂的内存分配，在分布式系统中，实值对象特别有用。\nReplace Array with Object（以对象取代数组）\n不应该将不同的元素存放到数组中，应该使用值域。\nDuplicate Observed Data（复制被监视数据）\n通过观察者模式，将业务数据和 GUI 数据进行同步控制\nChange Unidirectional Association to Bidirectional（将单向关联改为双向）\n使用双向连接，从而能让两个类能互相使用对方特性。\nChange Bidirectional Assicuation to Unidirectional（将双向关联改为单向）\n当一个类不再需要另外一个类特性时候作修改。\nReplace Magic Number with Symbolic Constant（以符号常量/字面常量取代魔法数）\n使用有意义的名称，比如pi, gravity。\nEncapsulate Field（封装值域）\n使用getter/setter。\nEncapsulate Collection（封装集群）\n避免直接修改容器对象，而是封装出类方法来修改。将变化控制在既有方法内。\nReplace Record with Data Class（以数据类取代记录）\n将传统编程中的结构体转换为数据类。\nReplace Type Code with Class（以类别取代型别码）\n使用类型集合类来替换型别码。\nReplace Type Code with Subclass（以子类取代型别码）\n使用多态来替换型别码，发挥面向对象编程的优势。 （小心处理 ORM 映射）\nReplace Type Code with State/Strategy（以State/Strategy取代型别码）\n使用State/Strategy模式来因对type code会发生变化的情况。 将状态类作为父类，再进行继承。\nReplace Subclass with Fields（以值域取代子类）\n当子类的差异仅仅体现在返回常量数据的函数上时候，进行这样的替换。\n2.4. 简化条件表达式 简化的核心思想，是将过程式的 if / else 替换为面向对象的多态。\nDecompose Conditional（分解条件式）\n将复杂的条件式提炼为独立函数。\nConsolidate Conditional Expression（合并条件式）\n将多个条件式判断提炼成一个独立函数。这和上面的分解条件式都需要一个前提： 这几个条件式是要有逻辑关联的。\nConsolidate Duplicate Conditional Fragments（合并重复的条件判断）\n将所有分支里面都拥有的代码提炼到分支判断之后运行。\nRemove Control Flag（移除控制标志）\n使用 break/return 取代控制标记。单一出口，多出口。控制标记让程序接口看上去混乱。\nReplace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件式）\n保留正常情况下面下的顺序执行，提前对非正常情况进行单独检查并返回。 （我更倾向于使用 Exception）\nReplace Conditional with Polymorphism（以多态取代条件式）\n将条件式的每个分支放入一个Subclass 内覆写函数中，然后将原始函数生命为抽象函数。 （这个方法之前的 5 种重构手段是代码小手段，引入多态才能充分发挥 OOP 优势）\nIntroduce Null Object（引入 Null 对象）\n将无效值替换为Null Object，从而可以让程序正常运行。 （这好象是一种 Hack 方法，我倾向使用 Exception，作者的用以可能是通过 Null 来减少判断代码）\nIntroduce Assertion（引入断言）\n通过断言来发现程序错误，实际使用中，可以配合 Debug Mode 使用。\n2.5. 简化函数调用 Rename Method（重命名函数）\nA good name is better than a line of comment.\nAdd Parameter（添加参数）\n你没看错，就是添加参数。 （啊？Matin老师，不带这么水的阿）\nRemove Parameter（移除参数）\n不要就丢掉。\nSeparate Query from Modifier（将查询参数和修改参数分离）\n将一个即查询状态又修改状态的函数分离开来，职责分离清楚。 （我以前很喜欢写多面手函数～）\nParameterize Method（令函数携带参数）\n同一逻辑功能函数，通过重载接受不同参数。而不要建立多个同样的函数。\nReplace Parameter with Explicit Methods（以明确函数取代参数）\n将单一函数分解为多个函数从而去掉参数，前提是这几个函数的逻辑功能区别较大。\nPreserve Whole Object（保持对象完整）\n传递完整的对象，取代几个参数的传递。\nReplace Parameter with Methods（以函数取代参数）\n如果目标函数需要的是几个参数操作的结果，就直接传递这个结果，而不是数个参数。\nIntroduce Parameter Object(引入参数对象)\n当几个参数经常同时出现，就封装他们。 （他们之间往往就有逻辑关系）\nRemove Setting Method（移除设值函数）\n如果类的某个值域初始化后不再改变，就去掉它的 setting 方法。 （我理解为原则：“减少疑惑，保持唯一”）\nHide Method（隐藏某个函数）\n使用 private 标记未被其他类调用的方法。\nReplace Constructor with Factory Method（以工厂函数取代构造函数）\n引入工厂模式。\nEncapsulate Downcast（封装向下转型动作）\n当知道什么类型时候，将其封装在产生函数里面，减少引用者的困扰。\nReplace Error Code with Exception（以异常取代错误码）\n如其名。 （关于异常使用的时机，抛出的方式，捕捉的粒度，我困惑了很久。 最后的总结的经验是：在什么层级处理并且仅处理该层级的异常。等有时间详细成文送出）\nReplace Exception with Test（以测试取代异常）\n异常不是条件判断。\n2.6. 处理概括关系 关于 OOP 继承的那些事儿。\nPull Up Field（值域上移）\n子类重复的值域放到父类去。 （其实还是基于责任归属的问题）\nPull Up Method（函数上移）\n子类中重复函数移到父类。\nPull Up Construction Body（构造函数本体上移）\n共用的构造函数片段上移。\nPush Down Method（函数下移）\n将父类中近被某个子类调用的函数下移。\nPush Down Field（值域下移）\n同上。\nExtract Subclass（提炼子类）\n当某个类只有部分特性被用到，就需要提取出子类。\nExtract Superclass（提炼超类）\n和上面相反。\nExtract Interface（提炼接口）\n将相同的子集提取接口。\nCollapse hierarchy（折叠继承体系）\n父类和子类并无太大区别时候，合体吧亲。\nFrom Template Mehod（塑造模板函数）\n将子类的同功能不同实现函数上移到父类，并在子类提供同名不同实现被调用的子函数。\nReplace Inheritance with Delegation（以委托取代继承）\n将父类变成一个值域，在调用这个值域的方法。is-a -\u003e has-a （继承太多就会出问题）\nReplace Delegation with Inheritance（以继承取代委托）\n和上面相反的应用，当子类和父类出现明显的继承关系时候使用。\n2.7. 大型重构 这一章讲的内容有点高屋建瓴，这里就不概括了，建议读原文。\nTease Apart Inheritance（梳理并分解继承体系） Convert Procedural Design to Objects（将过程化设计转化为对象设计） Separate Domain from Presentation（将领域和表述/显示分离） Extract hierarchy（提炼继承体系） 少年，Coding 时候重构你的代码吧！\n",
  "wordCount" : "5206",
  "inLanguage": "en",
  "datePublished": "2012-02-05T00:00:00+08:00",
  "dateModified": "2012-02-05T00:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "alswl"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.alswl.com/2012/02/refactory/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Log4D",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.alswl.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.alswl.com/" accesskey="h" title="Log4D (Alt + H)">Log4D</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://en.blog.alswl.com/" title="English Blog">
                    <span>English Blog</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/archives/" title="存档">
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="https://blog.alswl.com/about/" title="关于我">
                    <span>关于我</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.alswl.com/">Home</a>&nbsp;»&nbsp;<a href="https://blog.alswl.com/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      再读《重构》
    </h1>
    <div class="post-meta"><span title='2012-02-05 00:00:00 +0800 +0800'>2012-02-05</span>&nbsp;·&nbsp;alswl

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-重构原则">1. 重构原则</a>
      <ul>
        <li><a href="#11-重构的定义">1.1. 重构的定义</a></li>
        <li><a href="#12-重构的意义">1.2. 重构的意义</a></li>
        <li><a href="#13-重构的时间">1.3. 重构的时间</a></li>
        <li><a href="#14-重构和开发进度">1.4. 重构和开发进度</a></li>
        <li><a href="#15-重构的难题">1.5. 重构的难题</a></li>
        <li><a href="#16-重构与设计">1.6. 重构与设计</a></li>
        <li><a href="#17-重构与性能">1.7. 重构与性能</a></li>
        <li><a href="#18-那些bad-smell">1.8. 那些Bad Smell</a></li>
        <li><a href="#19-从测试开始">1.9. 从测试开始</a></li>
        <li><a href="#110-kent-back说">1.10. Kent Back说</a></li>
      </ul>
    </li>
    <li><a href="#2-重构名录">2. 重构名录</a>
      <ul>
        <li><a href="#21-重新组织函数">2.1. 重新组织函数</a></li>
        <li><a href="#22-在对象之间搬移特性">2.2. 在对象之间搬移特性</a></li>
        <li><a href="#23-重新组织数据">2.3. 重新组织数据</a></li>
        <li><a href="#24-简化条件表达式">2.4. 简化条件表达式</a></li>
        <li><a href="#25-简化函数调用">2.5. 简化函数调用</a></li>
        <li><a href="#26-处理概括关系">2.6. 处理概括关系</a></li>
        <li><a href="#27-大型重构">2.7. 大型重构</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>Martin Fowler 的「<a href="http://book.douban.com/subject/1229923/">重构-改善既有代码的设计</a>」这本书，是我大学老师推荐给我的。
当时我在撰写代码过程中，发现当代码量到某个数量级时候（1000+行），
就会逐渐失去对代码的控制能力。
昆哥推荐了两本书「<a href="http://book.douban.com/subject/1792387/">UML 和模式应用</a>」和「重构」这本书。</p>
<p>




<img loading="lazy" src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201202/s1669771_l.jpg" alt="Refactory"  />


</p>
<p>这本书是2年前购买的，可惜以我当时的代码感知和撰写能力，看起来颇为吃力。 半途就看得云里雾里而中断了。最近我又重新拾起这本书，
将书中所写的境况与我这两年多来遇到的问题相互印证，才感受到这本经典的力量。</p>
<p>Martin 其人：</p>
<blockquote>
<p>ThoughtWorks 的首席科学家，当今世界软件开发领域最具影响力的五位大师之一。
他在 UML 推广普及、领域建模、企业应用开发和敏捷方法等方面建树卓著，被称为软件开发的教父。</p>
</blockquote>
<p>大学时候有段时间我对 Martin 的敏捷非常痴迷。现在对技术的选择没以前那么冲动了， 但是毫不妨碍我对 Martin 的敬仰之情。</p>
<h2 id="1-重构原则">1. 重构原则<a hidden class="anchor" aria-hidden="true" href="#1-重构原则">#</a></h2>
<h3 id="11-重构的定义">1.1. 重构的定义<a hidden class="anchor" aria-hidden="true" href="#11-重构的定义">#</a></h3>
<blockquote>
<p>对软件内部结构的一种调整，目的是在不改变&quot;软件之可察行为&quot;前提下，提高其可理解性，降低其修改成本。</p>
</blockquote>
<p>重构就是在代码写好之后改进它的设计。</p>
<ul>
<li>重构和添加新功能并不冲突，但是当开发者身份在两者之间切换时候，不能混淆在一起。</li>
</ul>
<h3 id="12-重构的意义">1.2. 重构的意义<a hidden class="anchor" aria-hidden="true" href="#12-重构的意义">#</a></h3>
<ul>
<li>优秀设计的根本是：消除重复部分！（DRY = Don&rsquo;t repeat yourself）</li>
<li>重构让代码更清晰，更容易理解</li>
<li>清晰的代码可以更方便的找到 bug ，重构可以写出更强健的代码</li>
<li>良好的设计可以在长远时间上提高开发速度</li>
</ul>
<h3 id="13-重构的时间">1.3. 重构的时间<a hidden class="anchor" aria-hidden="true" href="#13-重构的时间">#</a></h3>
<ul>
<li>随时进行重构（在我看来，重构更是一种开发的习惯）</li>
<li>事不过三，代码重复不要超过三次（否则就要&quot;抽&quot;出来）</li>
<li>添加功能时候并一一重构（个人理解是，添加新功能之前，分析并重构，从而更方便添加新功能）</li>
<li>修补错误时</li>
<li>Code Review 时</li>
</ul>
<h3 id="14-重构和开发进度">1.4. 重构和开发进度<a hidden class="anchor" aria-hidden="true" href="#14-重构和开发进度">#</a></h3>
<p>重构的意义之一也是提高开发进度。杀手锏是&quot;不要告诉经理&quot;。</p>
<h3 id="15-重构的难题">1.5. 重构的难题<a hidden class="anchor" aria-hidden="true" href="#15-重构的难题">#</a></h3>
<ul>
<li>数据层（数据模型）的变更压力</li>
<li>修改接口</li>
<li>那些难以通过重构改变的设计改动</li>
<li>代码不能运行</li>
<li>项目期限压力 Deadline</li>
</ul>
<h3 id="16-重构与设计">1.6. 重构与设计<a hidden class="anchor" aria-hidden="true" href="#16-重构与设计">#</a></h3>
<ul>
<li>编程不是机械的开发，（软件开发是艺术行为！）</li>
<li>设计和重构的平衡（预先设计的难度和重构灵活性的平衡）</li>
</ul>
<h3 id="17-重构与性能">1.7. 重构与性能<a hidden class="anchor" aria-hidden="true" href="#17-重构与性能">#</a></h3>
<ul>
<li>重构确实会在短期内降低代码执行效率，但优化阶段是可以调整的，而且调整会更容易。</li>
<li>提前优化是万恶之源</li>
</ul>
<h3 id="18-那些bad-smell">1.8. 那些Bad Smell<a hidden class="anchor" aria-hidden="true" href="#18-那些bad-smell">#</a></h3>
<ul>
<li>重复的代码（这才是真正万恶之源，鄙视一切Ctrl+C/P）</li>
<li>过长函数，会导致责任不明确/难以切割/难以理解等一系列问题</li>
<li>过大类，职责不明确，垃圾滋生地</li>
<li>过长参数列（面向对象不是说说而已）</li>
<li>发散式变化，一个类会响应多种需求而被修改</li>
<li>散弹式修改（其实就是没有封装变化处，由于一个需求，多处需要被修改）</li>
<li>依赖情节（一个类对其他类过多的依赖）</li>
<li>数据泥团（如果数据有意义，就将结构数据变成对象）</li>
<li>Type code，使用 Class 替代</li>
<li><code>switch</code>，少用，考虑多态</li>
<li>过多平行的类，使用类继承并联起来</li>
<li>冗余类，去除它</li>
<li>夸夸其谈的未来性（Matin 的文字，侯俊杰的翻译真是…出彩…）</li>
<li>临时值域，封装它</li>
<li>过度耦合的消息链，使用真正需要的函数和对象，而不要依赖于消息链</li>
<li>过度的 Deleate</li>
<li>过度使用其他类 <code>private</code> 值域</li>
<li>重复作用的类</li>
<li>不完美的类库，（类库老了，使用者也没办法阿）</li>
<li>纯数据类（类需要行为）</li>
<li>不纯粹的继承（拒绝父类的接口的类）</li>
<li>过多注释，注释多了，就说明代码不清楚了</li>
</ul>
<h3 id="19-从测试开始">1.9. 从测试开始<a hidden class="anchor" aria-hidden="true" href="#19-从测试开始">#</a></h3>
<p>无测试，无重构，只依赖手工测试，重构时候人会崩溃的。</p>
<ul>
<li>重构的保真就是自动化测试（如果真的要无聊的手工测试，我也不反对）</li>
<li>单元测试</li>
<li>功能测试</li>
</ul>
<h3 id="110-kent-back说">1.10. Kent Back说<a hidden class="anchor" aria-hidden="true" href="#110-kent-back说">#</a></h3>
<blockquote>
<p>如果我纯粹为今天工作，明天我将完全无法工作。</p>
</blockquote>
<p>间接层的价值：</p>
<ul>
<li>允许逻辑共享</li>
<li>分开解释&quot;意图&quot;和&quot;实现&quot;</li>
<li>将变化加以隔离</li>
<li>将条件逻辑加以编码</li>
</ul>
<blockquote>
<p>计算机科学是这样一门学科：它相信所有问题都可以通过一个间接层来解决。</p>
<p>&ndash;Dennis DeBruler</p>
</blockquote>
<p>我相信，撰写代码时候不仅仅考虑当下功能，要考虑到有可能出现的情况，
在可能的平衡下面，为将来的扩展做好准备。（也许不仅仅是自己的明天，
还要考虑团队成员的今天工作内容）</p>
<h2 id="2-重构名录">2. 重构名录<a hidden class="anchor" aria-hidden="true" href="#2-重构名录">#</a></h2>
<h3 id="21-重新组织函数">2.1. 重新组织函数<a hidden class="anchor" aria-hidden="true" href="#21-重新组织函数">#</a></h3>
<p>Extract Method（提炼函数）</p>
<blockquote>
<p>将一段独立的，不依赖上下文的代码组织并独立出来。</p>
</blockquote>
<p>Inline Method（将函数内联化）</p>
<blockquote>
<p>当函数内部代码简短而容易理解时候，去除这个非必要的间接层。</p>
</blockquote>
<p>Inline Temp（将临时变量内联化）</p>
<blockquote>
<p>去除只被赋值一次的临时变量。（当有意义时候，应该保留）</p>
</blockquote>
<p>Replace Temp with Query（以查询取代临时变量）</p>
<blockquote>
<p>将临时变量提取到一个独立函数，并将原来变量引用替换为函数调用。 （我还是担心性能的问题，另外将临时变量限定在一个段落中，可以避免额外的引用）</p>
</blockquote>
<p>Introduce Explainning Variable（引入解释性变量）</p>
<blockquote>
<p>将复杂表达式的结果放入临时变量，并用变量名来解释表达式用途。 （自注释代码的表现）</p>
</blockquote>
<p>Split Temporary Variable（剖析临时变量）</p>
<blockquote>
<p>除了循环变量和临时集合变量，临时变量赋值不能超过一次。</p>
</blockquote>
<p>Remove Assignments to Parameters（移除对参数的赋值动作）</p>
<blockquote>
<p>不对函数参数进行赋值动作，如果要赋值，创建一个新的临时变量。</p>
</blockquote>
<p>Replace Method with Method Object（以函数对象取代函数）</p>
<blockquote>
<p>把函数变成对象，再把临时变量变成对象值域。该方法在分解函数时候常用。 （Martin 对小型函数特别迷恋，我认为这个方法更应该用在有逻辑意义的方法上面）</p>
</blockquote>
<p>Substitute Algorithm（替换算法）</p>
<blockquote>
<p>用更清晰的算法。 （码农都知道）</p>
</blockquote>
<h3 id="22-在对象之间搬移特性">2.2. 在对象之间搬移特性<a hidden class="anchor" aria-hidden="true" href="#22-在对象之间搬移特性">#</a></h3>
<p>（面向对象编程原则之一就是职责归属，搬移其实也就意味着职责重新规划）</p>
<p>Move Method（搬移函数）</p>
<blockquote>
<p>将函数移动到被最多次调用的类里面去。 （往往在逻辑意义上，这个函数就应该归属于这个类）</p>
</blockquote>
<p>Move Field（搬移值域）</p>
<blockquote>
<p>将值域移动到被最多次调用的类里面去。</p>
</blockquote>
<p>Extract Class（提炼类）</p>
<blockquote>
<p>将开发过程中逐渐变得臃肿的类拆分成数个类，形成清楚的抽象，明确的职责。</p>
</blockquote>
<p>Inline Class（将类内联化）</p>
<blockquote>
<p>将不再担任足够职责的类搬到另外一个类中，并移除这个原始类。</p>
</blockquote>
<p>Hide Delegate（隐藏委托关系）</p>
<blockquote>
<p>将直接调用变成间接，在中间添加一层，从而从容面对变更，隔离变化。 （&ldquo;哪里变化，封装哪里&quot;这是设计模式的一个经典原则）</p>
</blockquote>
<p>Remove Middle Man（移除中间人）</p>
<blockquote>
<p>和Hide Delegate相反，移除做了过多简单委托的类。 （应该Hide Delegate需要加入成本，多维护一层，这需要控制一种平衡）</p>
</blockquote>
<p>Introduce Foreign Method（引入外加函数）</p>
<blockquote>
<p>当类无法进行修改时候，使用静态函数接受这种类型的类实例，</p>
</blockquote>
<p>Introduce Local Extenstion（引入本地扩展）</p>
<blockquote>
<p>使用子类继承/Wrapper 类来实现额外的函数。</p>
</blockquote>
<h3 id="23-重新组织数据">2.3. 重新组织数据<a hidden class="anchor" aria-hidden="true" href="#23-重新组织数据">#</a></h3>
<p>Self Encapsulate Field（自封装值域）</p>
<blockquote>
<p>使用getter/setter。 （个人觉得这样很繁琐，.net 中的属性方式处理的不错）</p>
</blockquote>
<p>Replace Date Value with Object （以对象取代数据值）</p>
<blockquote>
<p>当数据项有额外的数据和行为时候，将它变成一个类</p>
</blockquote>
<p>Change Value to Reference（将实值对象改为引用对象）</p>
<blockquote>
<p>有一些类型，比如日期、星期，不需要保存太多副本。</p>
</blockquote>
<p>Change Reference to Value（将引用对象改为实值对象）</p>
<blockquote>
<p>和楼上相反的情况，引用会带来复杂的内存分配，在分布式系统中，实值对象特别有用。</p>
</blockquote>
<p>Replace Array with Object（以对象取代数组）</p>
<blockquote>
<p>不应该将不同的元素存放到数组中，应该使用值域。</p>
</blockquote>
<p>Duplicate Observed Data（复制被监视数据）</p>
<blockquote>
<p>通过观察者模式，将业务数据和 GUI 数据进行同步控制</p>
</blockquote>
<p>Change Unidirectional Association to Bidirectional（将单向关联改为双向）</p>
<blockquote>
<p>使用双向连接，从而能让两个类能互相使用对方特性。</p>
</blockquote>
<p>Change Bidirectional Assicuation to Unidirectional（将双向关联改为单向）</p>
<blockquote>
<p>当一个类不再需要另外一个类特性时候作修改。</p>
</blockquote>
<p>Replace Magic Number with Symbolic Constant（以符号常量/字面常量取代魔法数）</p>
<blockquote>
<p>使用有意义的名称，比如pi, gravity。</p>
</blockquote>
<p>Encapsulate Field（封装值域）</p>
<blockquote>
<p>使用getter/setter。</p>
</blockquote>
<p>Encapsulate Collection（封装集群）</p>
<blockquote>
<p>避免直接修改容器对象，而是封装出类方法来修改。将变化控制在既有方法内。</p>
</blockquote>
<p>Replace Record with Data Class（以数据类取代记录）</p>
<blockquote>
<p>将传统编程中的结构体转换为数据类。</p>
</blockquote>
<p>Replace Type Code with Class（以类别取代型别码）</p>
<blockquote>
<p>使用类型集合类来替换型别码。</p>
</blockquote>
<p>Replace Type Code with Subclass（以子类取代型别码）</p>
<blockquote>
<p>使用多态来替换型别码，发挥面向对象编程的优势。 （小心处理 ORM 映射）</p>
</blockquote>
<p>Replace Type Code with State/Strategy（以State/Strategy取代型别码）</p>
<blockquote>
<p>使用State/Strategy模式来因对type code会发生变化的情况。 将状态类作为父类，再进行继承。</p>
</blockquote>
<p>Replace Subclass with Fields（以值域取代子类）</p>
<blockquote>
<p>当子类的差异仅仅体现在返回常量数据的函数上时候，进行这样的替换。</p>
</blockquote>
<h3 id="24-简化条件表达式">2.4. 简化条件表达式<a hidden class="anchor" aria-hidden="true" href="#24-简化条件表达式">#</a></h3>
<p>简化的核心思想，是将过程式的 <code>if</code> / <code>else</code> 替换为面向对象的多态。</p>
<p>Decompose Conditional（分解条件式）</p>
<blockquote>
<p>将复杂的条件式提炼为独立函数。</p>
</blockquote>
<p>Consolidate Conditional Expression（合并条件式）</p>
<blockquote>
<p>将多个条件式判断提炼成一个独立函数。这和上面的分解条件式都需要一个前提： 这几个条件式是要有逻辑关联的。</p>
</blockquote>
<p>Consolidate Duplicate Conditional Fragments（合并重复的条件判断）</p>
<blockquote>
<p>将所有分支里面都拥有的代码提炼到分支判断之后运行。</p>
</blockquote>
<p>Remove Control Flag（移除控制标志）</p>
<blockquote>
<p>使用 break/return 取代控制标记。单一出口，多出口。控制标记让程序接口看上去混乱。</p>
</blockquote>
<p>Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件式）</p>
<blockquote>
<p>保留正常情况下面下的顺序执行，提前对非正常情况进行单独检查并返回。 （我更倾向于使用 Exception）</p>
</blockquote>
<p>Replace Conditional with Polymorphism（以多态取代条件式）</p>
<blockquote>
<p>将条件式的每个分支放入一个Subclass 内覆写函数中，然后将原始函数生命为抽象函数。
（这个方法之前的 5 种重构手段是代码小手段，引入多态才能充分发挥 OOP 优势）</p>
</blockquote>
<p>Introduce Null Object（引入 Null 对象）</p>
<blockquote>
<p>将无效值替换为Null Object，从而可以让程序正常运行。 （这好象是一种 Hack 方法，我倾向使用 Exception，作者的用以可能是通过 Null 来减少判断代码）</p>
</blockquote>
<p>Introduce Assertion（引入断言）</p>
<blockquote>
<p>通过断言来发现程序错误，实际使用中，可以配合 Debug Mode 使用。</p>
</blockquote>
<h3 id="25-简化函数调用">2.5. 简化函数调用<a hidden class="anchor" aria-hidden="true" href="#25-简化函数调用">#</a></h3>
<p>Rename Method（重命名函数）</p>
<blockquote>
<p>A good name is better than a line of comment.</p>
</blockquote>
<p>Add Parameter（添加参数）</p>
<blockquote>
<p>你没看错，就是添加参数。 （啊？Matin老师，不带这么水的阿）</p>
</blockquote>
<p>Remove Parameter（移除参数）</p>
<blockquote>
<p>不要就丢掉。</p>
</blockquote>
<p>Separate Query from Modifier（将查询参数和修改参数分离）</p>
<blockquote>
<p>将一个即查询状态又修改状态的函数分离开来，职责分离清楚。 （我以前很喜欢写多面手函数～）</p>
</blockquote>
<p>Parameterize Method（令函数携带参数）</p>
<blockquote>
<p>同一逻辑功能函数，通过重载接受不同参数。而不要建立多个同样的函数。</p>
</blockquote>
<p>Replace Parameter with Explicit Methods（以明确函数取代参数）</p>
<blockquote>
<p>将单一函数分解为多个函数从而去掉参数，前提是这几个函数的逻辑功能区别较大。</p>
</blockquote>
<p>Preserve Whole Object（保持对象完整）</p>
<blockquote>
<p>传递完整的对象，取代几个参数的传递。</p>
</blockquote>
<p>Replace Parameter with Methods（以函数取代参数）</p>
<blockquote>
<p>如果目标函数需要的是几个参数操作的结果，就直接传递这个结果，而不是数个参数。</p>
</blockquote>
<p>Introduce Parameter Object(引入参数对象)</p>
<blockquote>
<p>当几个参数经常同时出现，就封装他们。 （他们之间往往就有逻辑关系）</p>
</blockquote>
<p>Remove Setting Method（移除设值函数）</p>
<blockquote>
<p>如果类的某个值域初始化后不再改变，就去掉它的 setting 方法。 （我理解为原则：&ldquo;减少疑惑，保持唯一&rdquo;）</p>
</blockquote>
<p>Hide Method（隐藏某个函数）</p>
<blockquote>
<p>使用 private 标记未被其他类调用的方法。</p>
</blockquote>
<p>Replace Constructor with Factory Method（以工厂函数取代构造函数）</p>
<blockquote>
<p>引入工厂模式。</p>
</blockquote>
<p>Encapsulate Downcast（封装向下转型动作）</p>
<blockquote>
<p>当知道什么类型时候，将其封装在产生函数里面，减少引用者的困扰。</p>
</blockquote>
<p>Replace Error Code with Exception（以异常取代错误码）</p>
<blockquote>
<p>如其名。 （关于异常使用的时机，抛出的方式，捕捉的粒度，我困惑了很久。 最后的总结的经验是：在什么层级处理并且仅处理该层级的异常。等有时间详细成文送出）</p>
</blockquote>
<p>Replace Exception with Test（以测试取代异常）</p>
<blockquote>
<p>异常不是条件判断。</p>
</blockquote>
<h3 id="26-处理概括关系">2.6. 处理概括关系<a hidden class="anchor" aria-hidden="true" href="#26-处理概括关系">#</a></h3>
<p>关于 OOP 继承的那些事儿。</p>
<p>Pull Up Field（值域上移）</p>
<blockquote>
<p>子类重复的值域放到父类去。 （其实还是基于责任归属的问题）</p>
</blockquote>
<p>Pull Up Method（函数上移）</p>
<blockquote>
<p>子类中重复函数移到父类。</p>
</blockquote>
<p>Pull Up Construction Body（构造函数本体上移）</p>
<blockquote>
<p>共用的构造函数片段上移。</p>
</blockquote>
<p>Push Down Method（函数下移）</p>
<blockquote>
<p>将父类中近被某个子类调用的函数下移。</p>
</blockquote>
<p>Push Down Field（值域下移）</p>
<blockquote>
<p>同上。</p>
</blockquote>
<p>Extract Subclass（提炼子类）</p>
<blockquote>
<p>当某个类只有部分特性被用到，就需要提取出子类。</p>
</blockquote>
<p>Extract Superclass（提炼超类）</p>
<blockquote>
<p>和上面相反。</p>
</blockquote>
<p>Extract Interface（提炼接口）</p>
<blockquote>
<p>将相同的子集提取接口。</p>
</blockquote>
<p>Collapse hierarchy（折叠继承体系）</p>
<blockquote>
<p>父类和子类并无太大区别时候，合体吧亲。</p>
</blockquote>
<p>From Template Mehod（塑造模板函数）</p>
<blockquote>
<p>将子类的同功能不同实现函数上移到父类，并在子类提供同名不同实现被调用的子函数。</p>
</blockquote>
<p>Replace Inheritance with Delegation（以委托取代继承）</p>
<blockquote>
<p>将父类变成一个值域，在调用这个值域的方法。is-a -&gt; has-a （继承太多就会出问题）</p>
</blockquote>
<p>Replace Delegation with Inheritance（以继承取代委托）</p>
<blockquote>
<p>和上面相反的应用，当子类和父类出现明显的继承关系时候使用。</p>
</blockquote>
<h3 id="27-大型重构">2.7. 大型重构<a hidden class="anchor" aria-hidden="true" href="#27-大型重构">#</a></h3>
<p>这一章讲的内容有点高屋建瓴，这里就不概括了，建议读原文。</p>
<ul>
<li>Tease Apart Inheritance（梳理并分解继承体系）</li>
<li>Convert Procedural Design to Objects（将过程化设计转化为对象设计）</li>
<li>Separate Domain from Presentation（将领域和表述/显示分离）</li>
<li>Extract hierarchy（提炼继承体系）</li>
</ul>
<p>少年，Coding 时候重构你的代码吧！</p>

<hr />
<p>原文链接: <a href="https://blog.alswl.com/2012/02/refactory/">再读《重构》 | Log4D</a></p>
<p>3a1ff193cee606bd1e2ea554a16353ee</p>
<p>欢迎关注我的微信公众号：<a
href="http://mp.weixin.qq.com/mp/getmasssendmsg?__biz=MzIyNTIwMTU3MQ==#wechat_webview_type=1&amp;wechat_redirect">窥豹</a></p>
<figure>
<img
src="https://e25ba8-log4d-c.dijingchao.com/upload_dropbox/201605/qrcode_for_gh_17e2f9c2caa4_258.jpg"
alt="窥豹" />
<figcaption aria-hidden="true">窥豹</figcaption>
</figure>

    
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.alswl.com/tags/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/">综合技术</a></li>
      <li><a href="https://blog.alswl.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.alswl.com/2012/02/the-write-the-plugins-for-moinmoin/">
    <span class="title">« Prev</span>
    <br>
    <span>给MoinMoin写插件</span>
  </a>
  <a class="next" href="https://blog.alswl.com/2012/01/an-shi-jian/">
    <span class="title">Next »</span>
    <br>
    <span>暗时间读书笔记</span>
  </a>
</nav>

  </footer><div id="waline"></div>
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';

    
    
    init({
      el: '#waline',
      serverURL: 'https://comments-waline-d41d8cd98f.blog.alswl.com',
      emoji: false,
      search: false,
      reaction: true, 
      requiredMeta: ['nick', 'mail'],
      login: 'enable',
      imageUploader: false,
      texRenderer: false,
    });
</script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://blog.alswl.com/">Log4D</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
